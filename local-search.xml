<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>解决 Cmake 腾讯云COS  SDK 编译失败问题</title>
    <link href="/2023/12/03/Cpp/cpp-cos-compile/"/>
    <url>/2023/12/03/Cpp/cpp-cos-compile/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Cmake-腾讯云COS-SDK-编译失败问题"><a href="#解决-Cmake-腾讯云COS-SDK-编译失败问题" class="headerlink" title="解决 Cmake 腾讯云COS  SDK 编译失败问题"></a>解决 Cmake 腾讯云COS  SDK 编译失败问题</h1><p>对象存储 COS 的 XML C++ SDK 源码下载地址： </p><ul><li>Linux 版本&#x2F;Windows 版本&#x2F;macOS 版本： <a href="https://github.com/tencentyun/cos-cpp-sdk-v5" title="https://github.com/tencentyun/cos-cpp-sdk-v5">XML Linux C++ SDK</a>。</li><li>SDK 快速下载地址：<a href="https://cos-sdk-archive-1253960454.file.myqcloud.com/cos-cpp-sdk-v5/latest/cos-cpp-sdk-v5.zip" title="https://cos-sdk-archive-1253960454.file.myqcloud.com/cos-cpp-sdk-v5/latest/cos-cpp-sdk-v5.zip">XML C++ SDK</a>。</li><li>示例 Demo 下载地址：<a href="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/demo/cos_demo.cpp" title="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/demo/cos_demo.cpp">COS XML C++ SDK 示例</a>。</li><li>SDK 更新日志请参见 <a href="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/CHANGELOG.md" title="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/CHANGELOG.md">ChangeLog</a>。</li></ul><p>如果用比较漂亮的语言来描述腾讯云cos-cpp-sdk，我觉得可以说是站在巨人肩膀上的健将，结构设计的还是比较漂亮的。 不过仍然存在一些小问题，这里进行一点小小的调整。</p><h2 id="uint64-t-不是一个类型名"><a href="#uint64-t-不是一个类型名" class="headerlink" title="uint64_t 不是一个类型名"></a><code>uint64_t</code> 不是一个类型名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Bash">/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:82:3: 错误：‘uint64_t’不是一个类型名<br>   82 |   uint64_t GetRealByte() const &#123; <span class="hljs-built_in">return</span> m_real_byte; &#125;<br>      |   ^~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:14:1: 附注：‘uint64_t’ is defined <span class="hljs-keyword">in</span> header ‘&lt;cstdint&gt;’; did you forget to ‘<span class="hljs-comment">#include &lt;cstdint&gt;’?</span><br>   13 | <span class="hljs-comment">#include &lt;string&gt;</span><br>  +++ |+<span class="hljs-comment">#include &lt;cstdint&gt;</span><br>   14 | <br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:98:20: 错误：‘uint64_t’未声明<br>   98 |   void SetRealByte(uint64_t real_byte) &#123; m_real_byte = real_byte; &#125;<br>      |                    ^~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:118:3: 错误：‘uint64_t’不是一个类型名<br>  118 |   uint64_t m_real_byte;<br>      |   ^~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:118:3: 附注：‘uint64_t’ is defined <span class="hljs-keyword">in</span> header ‘&lt;cstdint&gt;’; did you forget to ‘<span class="hljs-comment">#include &lt;cstdint&gt;’?</span><br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h: In copy constructor ‘qcloud_cos::CosResult::CosResult(const qcloud_cos::CosResult&amp;)’:<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:40:5: 错误：‘m_real_byte’在此作用域中尚未声明<br>   40 |     m_real_byte = other.m_real_byte;<br>      |     ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:40:25: 错误：‘const class qcloud_cos::CosResult’ has no member named ‘m_real_byte’<br>   40 |     m_real_byte = other.m_real_byte;<br>      |                         ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h: In member <span class="hljs-keyword">function</span> ‘qcloud_cos::CosResult&amp; qcloud_cos::CosResult::operator=(const qcloud_cos::CosResult&amp;)’:<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:52:7: 错误：‘m_real_byte’在此作用域中尚未声明<br>   52 |       m_real_byte = other.m_real_byte;<br>      |       ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:52:27: 错误：‘const class qcloud_cos::CosResult’ has no member named ‘m_real_byte’<br>   52 |       m_real_byte = other.m_real_byte;<br>      |                           ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h: In member <span class="hljs-keyword">function</span> ‘void qcloud_cos::CosResult::SetRealByte(int)’:<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:98:42: 错误：‘m_real_byte’ was not declared <span class="hljs-keyword">in</span> this scope; did you mean ‘real_byte’?<br>   98 |   void SetRealByte(uint64_t real_byte) &#123; m_real_byte = real_byte; &#125;<br>      |                                          ^~~~~~~~~~~<br>      |                                          real_byte<br>make[2]: *** [src/CMakeFiles/cossdk.dir/build.make:149：src/CMakeFiles/cossdk.dir/op/cos_result.cpp.o] 错误 1<br>make[2]: 离开目录“/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/build”<br>make[1]: *** [CMakeFiles/Makefile2:121：src/CMakeFiles/cossdk.dir/all] 错误 2<br>make[1]: 离开目录“/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/build”<br>make: *** [Makefile:94：all] 错误 2<br><br></code></pre></td></tr></table></figure><p><strong>修复方式</strong></p><ol><li><p>转到 <code>include/op/cos_result.h</code> 添加头文件<code>&lt;cstdint&gt;</code>或者<code>&lt;stdint.h&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>转到<code>include/util/test_utils.h</code> 添加头文件 <code>&lt;cstdint&gt;</code> 或者 &lt;cstdint.h&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> qcloud_cos &#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUtils</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">WriteStringtoFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> std::string&amp; str)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">WriteRandomDatatoFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file, <span class="hljs-type">unsigned</span> len)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">RemoveFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">GetRandomString</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> size)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcFileMd5</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcStreamMd5</span><span class="hljs-params">(std::istream&amp; is)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcStringMd5</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcStreamSHA1</span><span class="hljs-params">(std::istream&amp; is)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">GetEnvVar</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; env_var_name)</span></span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GetEnvVar TestUtils::GetEnvVar</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileInfo</span> &#123;<br>  std::string m_object_name;<br>  std::string m_local_file;<br>  std::string m_local_file_download;<br>  <span class="hljs-type">uint64_t</span> m_file_size;<br>  <span class="hljs-type">uint64_t</span> m_file_crc64_origin;<br>  std::string m_file_md5_origin;<br>  <span class="hljs-type">int</span> m_op_type;<br>&#125;;<br><br>&#125;  <span class="hljs-comment">// namespace qcloud_cos</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="undefined-referenct-to-‘xxxx-so’"><a href="#undefined-referenct-to-‘xxxx-so’" class="headerlink" title="undefined referenct to ‘xxxx.so’"></a>undefined referenct to ‘xxxx.so’</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `EVP_get_cipherbyname@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoNetSSL.so: undefined reference to `SSL_CTX_flush_sessions@libssl.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `d2i_PKCS12_bio@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoNetSSL.so: undefined reference to `FIPS_mode@libcrypto.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `BN_bn2bin@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `sk_num@libcrypto.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `EVP_BytesToKey@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `BIO_new_mem_buf@libcrypto.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoNetSSL.so: undefined reference to `SSL_CTX_use_PrivateKey_file@libssl.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string"># 还有一堆 undefined referenct to &#x27;</span>xxxx<span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p><strong>是因为现在的poco库默认已经使用c++14标准库，然而CMakeList.txt中设置仍然是c++11标准，于是修改为C++14</strong></p><p>将-std&#x3D;c11 修改为 -std&#x3D;c14或者17 </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><span class="hljs-keyword">CMAKE_policy</span>(<span class="hljs-keyword">SET</span> CMP0015 NEW)<br><span class="hljs-keyword">project</span>(cos-cpp-sdk)<br><br><span class="hljs-keyword">set</span>(CMAKE_VERBOSE_MAKEFILE  <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><br><span class="hljs-keyword">option</span>(BUILD_UNITTEST <span class="hljs-string">&quot;Build unittest&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span>(BUILD_DEMO <span class="hljs-string">&quot;Build demo&quot;</span> <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">option</span>(BUILD_SHARED_LIB <span class="hljs-string">&quot;Build shared library&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span>(ENABLE_COVERAGE <span class="hljs-string">&quot;Enable Coverage&quot;</span> <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-keyword">if</span>(APPLE)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;APPLE&quot;</span>)<br><span class="hljs-keyword">elseif</span>(UNIX)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;LINUX&quot;</span>)<br><span class="hljs-keyword">elseif</span>(WIN32)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;unkonwn os type&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;Android&quot;</span>)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;Android&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;SYSTEM_PROCESSOR: $&#123;CMAKE_SYSTEM_PROCESSOR&#125;&quot;</span>)<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;iOS&quot;</span>)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;iOS&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;SYSTEM_PROCESSOR: $&#123;CMAKE_SYSTEM_PROCESSOR&#125;&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;OS type: $&#123;OS_TYPE&#125;&quot;</span>)<br><br><span class="hljs-keyword">set</span>(POCO_INCLUDE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/<span class="hljs-keyword">include</span>/)<br><span class="hljs-keyword">set</span>(POCO_LIBS PocoNetSSL PocoNet PocoCrypto PocoUtil PocoJSON PocoXML PocoFoundation)<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17&quot;</span>)<br>    <span class="hljs-keyword">set</span>(BUILD_TARGET <span class="hljs-string">&quot;Win32&quot;</span>)<br>    <span class="hljs-keyword">if</span> (CMAKE_CL_64)<br>        <span class="hljs-keyword">set</span>(BUILD_TARGET <span class="hljs-string">&quot;x64&quot;</span>)<br>    <span class="hljs-keyword">endif</span>()<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build target: $&#123;BUILD_TARGET&#125;&quot;</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DEFINED</span> <span class="hljs-variable">$&#123;CMAKE_BUILD_TYPE&#125;</span>)<br>        <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Release&quot;</span>)<br>    <span class="hljs-keyword">endif</span>()<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build type: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br>    <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;BUILD_TARGET&#125;</span>/poco)<br><br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS <span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-comment">#需要加该参数，不然VS会报错</span><br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; /utf-8&quot;</span>)<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;iOS&quot;</span>)<br>    <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/poco/)<br>    <span class="hljs-keyword">set</span>(OPENSSL_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/openssl/)<br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS stdc++ pthread) <br>    <span class="hljs-keyword">set</span>(OPENSSL_LIBS ssl crypto)<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;Android&quot;</span>)<br>    <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/poco/)<br>    <span class="hljs-keyword">set</span>(OPENSSL_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/openssl/)<br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS stdc++)<br>    <span class="hljs-keyword">set</span>(OPENSSL_LIBS ssl crypto)<br><span class="hljs-comment"># Linux or MacOs</span><br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;APPLE&quot;</span>)<br>        <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/macOS/poco/)<br>        <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">else</span>()<br>        <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/linux/poco/)<br>        <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">endif</span>()<br><br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS stdc++ pthread)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(ENABLE_COVERAGE)<br><span class="hljs-comment"># coverage option</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">add_subdirectory</span>(src)<br><br><span class="hljs-keyword">if</span>(BUILD_UNITTEST)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build unittest&quot;</span>)<br><br>    <span class="hljs-keyword">set</span>(GTEST_INCLUDE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/<span class="hljs-keyword">include</span>/gtest/)<br>    <span class="hljs-keyword">set</span>(GTEST_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/linux/gtest/)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br>        <span class="hljs-keyword">set</span>(GTEST_LINK_DIR  <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;BUILD_TARGET&#125;</span>/gtest)<br>    <span class="hljs-keyword">endif</span>()<br>    <span class="hljs-keyword">set</span>(GTEST_LIBS gtest gtest_main)<br><br>    <span class="hljs-keyword">set</span>(UT_INCLUDE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/unittest/<span class="hljs-keyword">include</span>/)<br><br>    <span class="hljs-keyword">add_subdirectory</span>(unittest)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(BUILD_DEMO)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build demo&quot;</span>)<br>    <span class="hljs-keyword">add_subdirectory</span>(demo)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p><strong>编译出来的文件存在于 build&#x2F;lib&#x2F;中</strong></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>如果仍然在编译中出现失败的问题，尝试将编译demo选项关闭<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">option</span>(BUILD_UNITTEST <span class="hljs-string">&quot;Build unittest&quot;</span> <span class="hljs-keyword">OFF</span>) <span class="hljs-comment">#配置编译单元测试</span><br><span class="hljs-comment"># option(BUILD_DEMO &quot;Build demo&quot; ON) #配置编译 demo 测试代码</span><br><span class="hljs-keyword">option</span>(BUILD_DEMO <span class="hljs-string">&quot;Build demo&quot;</span> <span class="hljs-keyword">OFF</span>) <span class="hljs-comment">#配置编译 demo 测试代码</span><br><span class="hljs-keyword">option</span>(BUILD_SHARED_LIB <span class="hljs-string">&quot;Build shared library&quot;</span> <span class="hljs-keyword">OFF</span>) <span class="hljs-comment">#配置编译动态库</span><br></code></pre></td></tr></table></figure></li><li>POCO链接问题<ol><li>尝试将源代码中third_party中poco的库替换和当前系统环境一样的库</li><li>重新编译poco代码</li></ol></li><li>小甜品<br>   CMakeLists.txt中的单词还有一个拼错了<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">if</span>(APPLE)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;APPLE&quot;</span>)<br><span class="hljs-keyword">elseif</span>(UNIX)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;LINUX&quot;</span>)<br><span class="hljs-keyword">elseif</span>(WIN32)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;unkonwn os type&quot;</span>) <span class="hljs-comment"># 拼错了</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></li></ol><h2 id="个人输出"><a href="#个人输出" class="headerlink" title="个人输出"></a>个人输出</h2><p>tmd这个cos sdk真的是依托答辩，用了那么多库，疯狂叠buff, 即使是我使用了vcpkg来配置依赖库仍然麻烦的一批，有一种就是在用poco封装了一层的感觉。里面的详细代码就不评价了。最后奉上我个人测试使用的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.26</span>)<br><span class="hljs-keyword">project</span>(TestCos)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-keyword">find_package</span>(GTest CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(fmt CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(loguru CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(OpenSSL REQUIRED)<br><span class="hljs-keyword">find_package</span>(Poco REQUIRED COMPONENTS Foundation Crypto XML JSON Util Net NetSSL)<br><br><span class="hljs-keyword">set</span>(COS_SDK_H src/cos-cpp-sdk-v5/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;COS_SDK_H&#125;</span>)<br><br><span class="hljs-keyword">if</span> (WIN32)<br>    <span class="hljs-keyword">link_directories</span>(libs/Win32)<br><span class="hljs-keyword">elseif</span> (UNIX)<br>    <span class="hljs-keyword">link_directories</span>(libs/linux)<br><span class="hljs-keyword">elseif</span> (APPLE)<br>    <span class="hljs-keyword">link_directories</span>(libs/macOS)<br><span class="hljs-keyword">else</span> ()<br>    <span class="hljs-keyword">link_directories</span>(libs/x64)<br><br><span class="hljs-keyword">endif</span> ()<br><br><span class="hljs-keyword">set</span>(SRC src/main.cpp)<br><br><span class="hljs-keyword">add_executable</span>(TestCos <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(TestCos PRIVATE fmt::fmt loguru<br>        GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main<br>        OpenSSL::SSL OpenSSL::Crypto<br>        Poco::Foundation  Poco::Crypto Poco::XML Poco::JSON Poco::Util Poco::Net Poco::NetSSL<br>        libcossdk.a)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java小实验-封装一个类</title>
    <link href="/2023/11/29/Java/java-example-3/"/>
    <url>/2023/11/29/Java/java-example-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java小实验封装一个类"><a href="#Java小实验封装一个类" class="headerlink" title="Java小实验封装一个类"></a>Java小实验封装一个类</h1><p>设计一个基于控制台的购书系统。该系统主要有以下类完成</p><ol><li><p>设计一个图书类(Book)，该类处于shopping.book包中，该类具有以下成员变量和成员方法。</p><ol><li>成员变量：图书编号(bookid),图书名称(bookname),图书单价(bookprice),库存数量(bookstorage);其中图书单价和库存数量均被private修饰</li><li>成员方法：计算图书折扣率的方法getBookDiscount(),当库存数量&lt;50本时，原有价格打5折；当100&gt;库存数量&#x3D;&gt;50本时，原有价格打6折；当200&gt;库存数量&#x3D;&gt;100本时，原有价格打8折；当库存数量&gt;&#x3D;200时，不打折。</li><li>建议：由于同学们还未接触过数据库和文件存储数据，所以可以在Book类中直接为图书编号、图书名称、库存数量赋初值。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String bookname=<span class="hljs-string">&quot;Java程序设计&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">float</span> bookprice=<span class="hljs-number">28.2f</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookstorage=<span class="hljs-number">150</span>;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>设计一个图书管理类(BookManger),该类处于shopping.manager包中，该类的主要功能是接受控制台中来自用户的输入信息，并进行相应的处理，同时通过不同功能的成员方法将处理结果返回，如能够返回图书编号、价格、折扣价格和共支付总额的信息。建议每一个返回信息均通过不同的方法完成，如可在该类中创建getBookId()的方法，返回图书编号信息，其它依此类推。如当用户在命令行后输入：Java程序设计20BookManger类会将处理结果，图书编号：100123345，价格：28.2元，折扣价：20元，共支付：400元，分别通过getBookId()等4个不同的方法返回对应信息。</p></li><li><p>编写测试类AllUsers，当用户从命令行后输入书名和数量时，会显示该书图书编号、价格，以及用户需要支付的金额。</p><p>运行结果<br><img src="/img/java-example-3/sample.png" alt="运行结果" title="sample.png"></p></li></ol><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p><strong>shopping&#x2F;Manager.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> shopping;<br><br><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Book book;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String bookName, Double bookPrice, Integer bookStorage)</span> &#123;<br>        book = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>        <span class="hljs-type">var</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> Calendar.getInstance().getTimeInMillis();<br>        book.bookId = String.valueOf(date);<br>        book.SetStorage(bookStorage).SetPrice(bookPrice).SetBookName(bookName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">DisplayTotal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;图书编号: %s\t价格： %.2f\t折扣价：%.2f元\t共支付：%.2f元\n&quot;</span>,<br>                book.bookId,<br>                book.GetPrice(),<br>                book.GetBookDiscount(),<br>                book.GetStorage() * book.GetBookDiscount());<br><br>        <span class="hljs-comment">//var result = book.Id + book.GetPrice() + book.GetBookDiscount() +  ...</span><br>        System.out.println(result);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>shopping&#x2F;Book.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> shopping;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;  <br>    <span class="hljs-keyword">public</span> String bookId;  <br>    <span class="hljs-keyword">public</span> String bookName;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> bookPrice;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookStorage;  <br>  <br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">SetPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> &#123;  <br>        bookPrice = price;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">SetStorage</span><span class="hljs-params">(<span class="hljs-type">int</span> storage)</span> &#123;  <br>        bookStorage = storage;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">SetBookName</span><span class="hljs-params">(String name)</span> &#123;  <br>        bookName = name;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetPrice</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> bookPrice;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetStorage</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> bookStorage;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetBookDiscount</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (bookStorage &lt; <span class="hljs-number">50</span>) &#123;  <br>            <span class="hljs-keyword">return</span> calcDiscount(<span class="hljs-number">5</span>);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bookStorage &lt; <span class="hljs-number">100</span>) &#123;  <br>            <span class="hljs-keyword">return</span> calcDiscount(<span class="hljs-number">6</span>);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bookStorage &lt; <span class="hljs-number">200</span>) &#123;  <br>            <span class="hljs-keyword">return</span> calcDiscount(<span class="hljs-number">8</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> bookPrice;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> rate)</span> &#123;  <br>        <span class="hljs-keyword">return</span> bookStorage * rate * <span class="hljs-number">0.1</span>;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> shopping.Manager;  <br><span class="hljs-keyword">import</span> shopping.Book;  <br><span class="hljs-keyword">import</span> java.util.Scanner;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        Manager manager;  <br>        <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">3</span>) &#123;  <br>            manager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(args[<span class="hljs-number">0</span>], Double.valueOf(args[<span class="hljs-number">1</span>]), Integer.valueOf(args[<span class="hljs-number">2</span>]));  <br>            manager.DisplayTotal();  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">3</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Too few argument, at lest 4&quot;</span>);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Too many argument, 4 arguments at most&quot;</span>);  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;Too many argument, 4 arguments at most&quot;</span>);  <br>        &#125;  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.nextLine();  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> scanner.nextDouble();  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">storage</span> <span class="hljs-operator">=</span> scanner.nextInt();  <br>  <br>        manager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(name, price, storage);  <br>        manager.DisplayTotal();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>当命令行参数小于4个时，提示警告并且正确执行<br><img src="/img/java-example-3/too-low.jpg" alt="too-low" title="too low"></p><p>当命令行参数大于需要的参数个，系统抛出异常<br><img src="/img/java-example-3/too-many.jpg" alt="too-many" title="too many"></p><p>正常输出<br><img src="/img/java-example-3/standard-out.png" alt="stardand" title="standard-out"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nim- 迭代器iterator</title>
    <link href="/2023/11/29/Nim/nim-iterator/"/>
    <url>/2023/11/29/Nim/nim-iterator/</url>
    
    <content type="html"><![CDATA[<h2 id="Nim-迭代器-Iterator"><a href="#Nim-迭代器-Iterator" class="headerlink" title="Nim - 迭代器 Iterator"></a>Nim - 迭代器 Iterator</h2><p>让我们回到之前的示例代码：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;Counting to ten: &quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> countup(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>echo i<br></code></pre></td></tr></table></figure><p>可以编写一个支持此循环的计数过程吗（迭代器计数函数）？咱们试试吧：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> countup(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">var</span> res = a<br>  <span class="hljs-keyword">while</span> res &lt;= b:<br>    <span class="hljs-keyword">return</span> res<br>    inc(res)<br></code></pre></td></tr></table></figure><p>然而这不能工作，这个问题是此过程不仅仅返回最后进行了返回，而且在返回之后继续做了迭代递增的操作（<code>inc(res)</code>）。这个<code>return</code>和<code>continue</code>被称做<code>yield</code>语句。现在我们要做的事情就是用<code>iterator</code>关键字代替<code>proc</code>关键字，这就是我们的第一个迭代器了。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">iterator</span> countup(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">var</span> res = a<br>  <span class="hljs-keyword">while</span> res &lt;= b:<br>    <span class="hljs-keyword">yield</span> res<br>    inc(res)<br></code></pre></td></tr></table></figure><p>迭代器看起来和<code>过程</code>非常相似，但是还是有记得重要的区别的：</p><ul><li>迭代器只能在循环中调用</li><li>迭代器不能包含返回<code>return</code>语句（过程也不能包含<code>yield</code>语句）</li><li>迭代器没有隐式的结果变量。</li><li>迭代器不支持递归。</li><li>迭代器不能前向声明，因为编译器必须能够内联迭代器。(此限制将在编译器的未来版本中删除。)</li></ul><p>但是，你可以使用闭包（匿名）迭代器来获得一组不同的约束，查看 <a href="https://nim-lang.org/docs/manual.html#iterators-and-the-for-statement-firstminusclass-iterators">first-class iterators</a> 获得更多的细节。迭代器可以具有与进程相同的名称和参数，因为本质上它们有自己的名称空间。因此，通常将迭代器包装在同名的进程中，这些进程累积迭代器的结果并将其作为序列返回，就像从<code>structils module</code>中<code>split</code>一样。</p><p>一个简单的例子</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">iterator</span> addOne(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">var</span> res = a<br>  <span class="hljs-keyword">while</span> res &lt;= b:<br>    <span class="hljs-keyword">yield</span> res<br>    inc(res)<br><br><span class="hljs-keyword">iterator</span> reverseOut(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>    <span class="hljs-keyword">var</span> res = b<br>    <span class="hljs-keyword">while</span> res &gt;= a:<br>        <span class="hljs-keyword">yield</span> res<br>        dec(res)<br><br><span class="hljs-keyword">when</span> isMainModule:<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> addOne(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    echo i<br><br><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reverseOut(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    echo i<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 链表结构</title>
    <link href="/2023/11/28/DataStructure/c-link-list/"/>
    <url>/2023/11/28/DataStructure/c-link-list/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C-example</tag>
      
      <tag>Data-Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 一些有用的函数</title>
    <link href="/2023/11/28/Haskell/haskell-useful-function/"/>
    <url>/2023/11/28/Haskell/haskell-useful-function/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-函数式程序员工具箱"><a href="#Haskell-函数式程序员工具箱" class="headerlink" title="Haskell - 函数式程序员工具箱"></a>Haskell - 函数式程序员工具箱</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">map</span> :: ( a -&gt; b ) -&gt; [a] -&gt; [b]<br><span class="hljs-title">map</span> _ [] = []<br><span class="hljs-title">map</span> f (x:xs) = f x : map f xs<br></code></pre></td></tr></table></figure><p>接受两个参数，第一个参数是一个函数，第二个参数是一个列表，返回一个函数。看起来就是很简单的工具函数，实际使用中就可以玩出来很多花里胡哨的东西</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">map</span> (+<span class="hljs-number">3</span>) [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>]<br><span class="hljs-title">map</span> (++ <span class="hljs-string">&quot;!&quot;</span>) [<span class="hljs-string">&quot;BIFF&quot;</span>, <span class="hljs-string">&quot;BANG&quot;</span>, <span class="hljs-string">&quot;POW&quot;</span>]<br><span class="hljs-title">map</span> (replicate <span class="hljs-number">3</span>) [<span class="hljs-number">3</span>..<span class="hljs-number">6</span>]<br><span class="hljs-title">map</span> (map (^<span class="hljs-number">2</span>)) [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>取一个谓词和一个列表，返回由列表中所有符合该条件的元素组成的列表。很像C#中的linq （可恶，为什么C++没有linq）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">filter</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]<br><span class="hljs-title">filter</span> _ [] = []<br><span class="hljs-title">filter</span> p (x:xs)<br>| p x       = x : filter p xs<br>| otherwise = filter p xs<br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">filter</span> (&gt;<span class="hljs-number">3</span>) [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-title">filter</span> (==<span class="hljs-number">3</span>) [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-title">filter</span> even [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 一些高级函数</title>
    <link href="/2023/11/27/Haskell/haskell-hyper-function/"/>
    <url>/2023/11/27/Haskell/haskell-hyper-function/</url>
    
    <content type="html"><![CDATA[<h2 id="Haskell-一些高级函数"><a href="#Haskell-一些高级函数" class="headerlink" title="Haskell - 一些高级函数"></a>Haskell - 一些高级函数</h2><p>在haskell中的函数可以将一个函数作为参数传入，也可以返回一个参数。这样的玩法就非常丰富了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a<br><span class="hljs-title">applyTwice</span> f x = f (f x)<br></code></pre></td></tr></table></figure><p>如何使用它</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print $ applyTwice (+<span class="hljs-number">3</span>) <span class="hljs-number">10</span><br>    print $ applyTwice (*<span class="hljs-number">2</span>) <span class="hljs-number">10</span><br>    print $ applyTwice (++ <span class="hljs-string">&quot;lol&quot;</span>) <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">&gt; 16<br>&gt; 40<br>&gt; <span class="hljs-string">&quot;hellolollol&quot;</span><br></code></pre></td></tr></table></figure><p>定义了一个名为<code>applyTwice</code>的函数，它接受两个参数：一个是要应用两次的函数<code>f</code>，另一个是要应用<code>f</code>的参数<code>x</code>。<code>applyTwice</code>函数的返回值是<code>f</code> applied to <code>f(x)</code>，即<code>f</code> applied twice to <code>x</code>。</p><p>这个函数的实现非常简单，它的表达式式<code>f (f x)</code>表示先对<code>x</code>应用<code>f</code>，然后对结果再应用<code>f</code>。这个表达式的意思是：<code>applyTwice f x</code>等于<code>f</code> applied to <code>f(x)</code>。</p><p>因为这里使用的类型和返回类型都是<code>a</code>， 所以不用在意到底传的是什么类型，也就是什么类型都可以传入进去。比如传入 (+3) 10，首先是括号内部，执行了 10 + 3的操作，得到一个一元函数后再对括号外面的<code>f</code>再进行操作一次，最终得到了结果是16。<br>函数签名也可以理解，先做括号里的a, 这里标明了第一个参数是第一个参数与返回值都是a的函数，第二个参数与返回值的类型也都是a。</p><h2 id="实现zipWith"><a href="#实现zipWith" class="headerlink" title="实现zipWith"></a>实现zipWith</h2><p>为了帮助理解高阶函数，书上给了一个例子，复刻标准库中的zipWith函数。他取一个函数和两个列表作为参数，然后使用两个列表中对应的元素去调用该函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">zipWith&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]<br><span class="hljs-title">zipWith&#x27;</span> _ [] _ = []<br><span class="hljs-title">zipWith&#x27;</span> _ _ [] = []<br><span class="hljs-title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y: zipWith&#x27; f xs ys<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ zipWith&#x27; (+) [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>    print $ zipWith&#x27; (*) [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>其中，<code>a</code>、<code>b</code>和<code>c</code>是表示输入数据类型的参数，<code>[a]</code>和<code>[b]</code>是表示输入数据的列表，<code>[c]</code>是表示输出数据的列表。</p><p><code>zipWith&#39;</code>函数的实现依赖于一个名为<code>_</code>的匿名函数，它表示一个忽略输入参数的函数。这个匿名函数被传递给<code>zipWith&#39;</code>函数，用于处理输入数据。</p><p><code>zipWith&#39;</code>函数的实现首先检查两个输入列表是否都为空，如果是，则返回一个空列表。接下来，它检查第一个输入列表是否为空，如果是，则返回第二个输入列表的元素组成的列表。然后，它使用给定的函数处理第一个输入列表的第一个元素和第二个输入列表的第一个元素，并将结果添加到输出列表中。最后，它递归地调用<code>zipWith&#39;</code>函数，并将输出列表传递给下一个递归调用。</p><p><code>zipWith&#39;</code>函数的参数分为两部分：</p><ol><li>函数参数：这个参数是一个函数，它定义了如何将两个输入数据（如列表中的元素）组合成输出数据。这个函数的参数有两个，分别是<code>a</code>和<code>b</code>，它们表示输入数据和输出数据的类型。在<code>zipWith&#39;</code>函数中，这个函数被传递给<code>_</code>匿名函数，用于处理输入数据。</li><li>列表参数：这个参数是一个列表，它包含了两个子列表，分别表示输入数据和输出数据。在<code>zipWith&#39;</code>函数中，这两个子列表分别是<code>[a]</code>和<code>[b]</code>，它们表示输入数据的列表和输出数据的列表。在<code>zipWith&#39;</code>函数的实现中，这两个子列表被传递给<code>_</code>匿名函数，用于处理输入数据。</li></ol><p><code>zipWith&#39;</code>函数的签名中的三个参数分别表示输入数据的类型、输入数据的列表和输出数据的列表。在<code>zipWith&#39;</code>函数的实现中，这三个参数被传递给<code>_</code>匿名函数，用于处理输入数据。</p><p>重新来看函数签名<code>zipWith&#39; :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code><br>函数接收了三个参数 <code>( a -&gt; b -&gt; c )</code>、<code>[a]</code>、<code>[b]</code> 结果返回<code>[c]</code><br>前面两个函数没有什么多说的必要，就是如果有一个列表是空的就返回一个空列表，事情到了第三个列表就有意思了起来，f 匹配的是<code>(a -&gt; b -&gt; c)</code>， <code>(x:xs)</code>取了 <code>[a]</code>， <code>(y:ys)</code>取<code>[b]</code>。然后再做了一个递归运算，将列表的每一个元素拿出来，进行函数操作，十分的巧妙。</p><h2 id="实现-flip"><a href="#实现-flip" class="headerlink" title="实现 flip"></a>实现 flip</h2><p>取一个函数作为参数，返回一个效果相同的新参数，两个函数的唯一区别是，新函数的前两个参数的顺序和原来的函数前个参数的顺序正好颠倒。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">flip&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)<br><span class="hljs-title">flip&#x27;</span> f = g<br>    <span class="hljs-keyword">where</span> g x y = f y x<br></code></pre></td></tr></table></figure><p>这个函数 <code>flip&#39;</code> 接受一个二元函数 <code>f</code> 作为参数，并返回一个新的二元函数 <code>g</code>。<code>g</code> 函数的参数顺序与 <code>f</code> 函数的参数顺序相反。</p><p>具体来说，<code>g</code> 函数接受两个参数 <code>x</code> 和 <code>y</code>，并将它们传递给 <code>f</code> 函数，但将参数顺序反转。也就是说，如果 <code>f</code> 函数接受 <code>x</code> 和 <code>y</code> 作为参数，那么 <code>g</code> 函数将接受 <code>y</code> 和 <code>x</code> 作为参数。</p><p>这个 <code>flip&#39;</code> 函数的主要目的是将一个二元函数的参数顺序反转，使得在调用这个函数时，参数顺序与函数定义时相反。这在某些编程任务中非常有用，例如在编写接受和返回参数的函数时，将参数顺序反转可以使得函数更易于使用。</p><p>下面是一个使用 <code>flip&#39;</code> 函数的例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-comment">-- 定义一个二元函数</span><br><span class="hljs-title">double</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">double</span> x = x * <span class="hljs-number">2</span><br><br><span class="hljs-comment">-- 使用 flip&#x27; 函数将参数顺序反转</span><br><span class="hljs-title">triple</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">triple</span> x = double x x<br><br><span class="hljs-comment">-- 调用 triple 函数</span><br><span class="hljs-title">print</span> triple <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">15<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>double</code> 函数，它接受一个整数参数并返回它的两倍。然后我们使用 <code>flip&#39;</code> 函数将 <code>double</code> 函数的参数顺序反转，得到了 <code>triple</code> 函数，它接受两个整数参数并返回它们的和。最后我们调用 <code>triple</code> 函数并打印结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-过程(procedure)</title>
    <link href="/2023/11/25/Nim/nim-procedure/"/>
    <url>/2023/11/25/Nim/nim-procedure/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim-procedure"><a href="#Nim-procedure" class="headerlink" title="Nim - procedure"></a>Nim - procedure</h1><p>要定义示例中的echo和readLine等新命令，需要<code>过程</code>的概念。您可能习惯了它们在其他语言中被称为方法或函数，但是Nim区分了这些概念。在Nim中，新过程是用proc关键字定义的:</p><p>其实函数叫做过程这个名字还是很贴切的，我们平时一直区分一个语言是面向过程的还是面向对象的，比如说C语言是一个面向对象的语言。在C语言中内存被分为四大类：全局区、静态区、堆区和栈区。而栈区主要依赖于函数，而有些翻译就会将栈区翻译为存储过程。从C语言的角度来看，每一个程序就是一个过程，这个过程在执行的途中会有很多其他的子过程也就是其他的函数。一个程序就是若干个过程嵌套凭借组合的结果。</p><p>所以在这里叫做过程没有丝毫的问题，而且很直观。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> yes(question: <span class="hljs-type">string</span>): <span class="hljs-type">bool</span> =<br>  echo question, <span class="hljs-string">&quot; (y/n)&quot;</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:<br>    <span class="hljs-keyword">case</span> readLine(<span class="hljs-built_in">stdin</span>)<br>    <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>, <span class="hljs-string">&quot;Yes&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>, <span class="hljs-string">&quot;No&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span>: echo <span class="hljs-string">&quot;Please be clear: yes or no&quot;</span><br><br><span class="hljs-keyword">if</span> yes(<span class="hljs-string">&quot;Should I delete all your important files?&quot;</span>):<br>  echo <span class="hljs-string">&quot;I&#x27;m sorry Dave, I&#x27;m afraid I can&#x27;t do that.&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;I think you know what the problem is just as well as I do.&quot;</span><br></code></pre></td></tr></table></figure><p>这个例子展示了一个叫做<code>yes</code>的过程，他接受一个叫做<code>question</code>类型为<code>string</code>的形式参数，返回一个布尔类型。</p><p>过程的第一句<code>echo</code>输出 question的内容以及 (y&#x2F;n) 然后进入一个”死循环“中，然后使用<code>case</code>判断用户输入的内容，匹配到”y”, “Y”, “yes”, “Yes” 就返回 <code>true</code>， 匹配到”n”, “N”, “no”, “No” 将返回<code>false</code>。如果不是上述两种情况就进入else兜底，输出”Please be clear: yes or no” 之后进入下一次循环。</p><p>之后的if就不再是yes过程的内容了，则是调用yes后对其返回值进行一些处理。<strong>下面是原文的翻译</strong></p><blockquote><p>这个例子展示了一个名为yes的过程，它向用户询问一个问题，如果他们回答“是”(或类似的东西)就返回true，如果他们回答“否”(或类似的东西)就返回false。return语句立即离开过程(因此也离开while循环)。(question: string): bool语法描述了过程期望一个名为question的字符串类型的参数，并返回bool类型的值。bool类型是内置的:bool的唯一有效值是true和false。if或while语句中的条件必须是bool类型。</p><p>一些术语:在示例中，问题被称为(形式)参数，“我应该…”被称为传递给该参数的实参。</p></blockquote><h2 id="结果变量"><a href="#结果变量" class="headerlink" title="结果变量"></a>结果变量</h2><p>返回值的过程声明了一个表示返回值的隐式结果变量。没有表达式的返回语句是返回结果的简写。如果在退出处没有返回语句，则总是在过程结束时自动返回结果值。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> sumTillNegative(x: <span class="hljs-type">varargs</span>[<span class="hljs-type">int</span>]): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span>:<br>      <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">result</span> = <span class="hljs-built_in">result</span> + i<br><br>echo sumTillNegative() <span class="hljs-comment"># echoes 0</span><br>echo sumTillNegative(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment"># echoes 12</span><br>echo sumTillNegative(<span class="hljs-number">3</span>, <span class="hljs-number">4</span> , -<span class="hljs-number">1</span> , <span class="hljs-number">6</span>) <span class="hljs-comment"># echoes 7</span><br></code></pre></td></tr></table></figure><p>结果变量已经在函数的开头隐式地声明了，因此再次用’var result’声明它，例如，将使用同名的普通变量来遮蔽它。结果变量也已经用类型的默认值初始化了。注意，在过程开始时，引用数据类型将为nil，因此可能需要手动初始化。</p><p>没有任何返回语句且不使用特殊结果变量的过程返回其最后一个表达式的值。例如，这个程序</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> helloWorld(): <span class="hljs-type">string</span> =<br>  <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><p>结果就是返回一个”Hello, World”。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>过程体中的参数是不可变的。默认情况下，它们的值不能更改，因为这允许编译器以最有效的方式实现参数传递。如果过程中需要一个可变变量，则必须在过程体中使用var声明它。隐藏参数名是可能的，这实际上是一种习惯用法:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> printSeq(s: <span class="hljs-type">seq</span>, nprinted: <span class="hljs-type">int</span> = -<span class="hljs-number">1</span>) =<br>  <span class="hljs-keyword">var</span> nprinted = <span class="hljs-keyword">if</span> nprinted == -<span class="hljs-number">1</span>: s.len <span class="hljs-keyword">else</span>: min(nprinted, s.len)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; nprinted:<br>    echo s[i]<br></code></pre></td></tr></table></figure><p>如果过程需要修改调用者的参数，可以使用 var 参数（又是一个小细节）：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> divmod(a, b: <span class="hljs-type">int</span>; res, remainder: <span class="hljs-keyword">var</span> <span class="hljs-type">int</span>) =<br>  res = a <span class="hljs-keyword">div</span> b        <span class="hljs-comment"># integer division</span><br>  remainder = a <span class="hljs-keyword">mod</span> b  <span class="hljs-comment"># integer modulo operation</span><br><br><span class="hljs-keyword">var</span><br>  x, y: <span class="hljs-type">int</span><br>divmod(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, x, y) <span class="hljs-comment"># modifies x and y</span><br>echo x<br>echo y<br></code></pre></td></tr></table></figure><p>在示例中，<code>res</code> 和<code>remainder</code>是 <code>var</code> 参数。过程可以修改 <code>var</code> 参数，并且调用者可以看到更改。请注意，上面的示例最好使用元组作为返回值，而不是使用 var 参数。</p><h2 id="忽略语句"><a href="#忽略语句" class="headerlink" title="忽略语句"></a>忽略语句</h2><p>若要调用仅为其副作用返回值而忽略其返回值的过程，则必须使用discard语句。Nim不允许静默地丢弃返回值:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">discard</span> yes(<span class="hljs-string">&quot;May I ask a pointless question?&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果调用的proc&#x2F;迭代器已经被声明为可丢弃的pragma，则返回值可以被隐式忽略:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> p(x, y: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> <span class="hljs-meta">&#123;.discardable.&#125;</span> =<br>  <span class="hljs-keyword">return</span> x + y<br><br>p(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment"># now valid</span><br></code></pre></td></tr></table></figure><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>通常一个过程有许多参数，但并不清楚参数出现的顺序。对于构造复杂数据类型的过程尤其如此。因此，可以为过程的参数命名，以便清楚哪个参数属于哪个形参:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> createWindow(x, y, width, height: <span class="hljs-type">int</span>; title: <span class="hljs-type">string</span>;<br>                  show: <span class="hljs-type">bool</span>): <span class="hljs-type">Window</span> =<br>   <span class="hljs-comment"># ...</span><br><br><span class="hljs-keyword">var</span> w = createWindow(show = <span class="hljs-literal">true</span>, title = <span class="hljs-string">&quot;My Application&quot;</span>,<br>                     x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, height = <span class="hljs-number">600</span>, width = <span class="hljs-number">800</span>)<br></code></pre></td></tr></table></figure><p>简单来说就是在调用过程传参数时候，可以加上参数名字来指定参数到底传给谁。很直接。</p><p>现在我们使用命名参数来调用createWindow，参数顺序不再重要了。将命名参数与有序参数混合也是可能的，但不是很好读:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> w = createWindow(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, title = <span class="hljs-string">&quot;My Application&quot;</span>,<br>                     height = <span class="hljs-number">600</span>, width = <span class="hljs-number">800</span>, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>编译器检查每个形参是否只接收一个实参。</p><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>为了使createWindow过程更容易使用，它应该提供默认值;如果调用者没有指定这些值，则将它们用作参数:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> createWindow(x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, width = <span class="hljs-number">500</span>, height = <span class="hljs-number">700</span>,<br>                  title = <span class="hljs-string">&quot;unknown&quot;</span>,<br>                  show = <span class="hljs-literal">true</span>): <span class="hljs-type">Window</span> =<br>   <br><br><span class="hljs-keyword">var</span> w = createWindow(title = <span class="hljs-string">&quot;My Application&quot;</span>, height = <span class="hljs-number">600</span>, width = <span class="hljs-number">800</span>)<br></code></pre></td></tr></table></figure><p>现在，对createWindow的调用只需要设置与默认值不同的值。</p><p>请注意，类型推断适用于具有默认值的参数;例如，不需要写title: string &#x3D; “unknown”。</p><h2 id="重载过程"><a href="#重载过程" class="headerlink" title="重载过程"></a>重载过程</h2><p>Nim的过程重载和C++的函数重载很相似</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> toString(x: <span class="hljs-type">int</span>): <span class="hljs-type">string</span> =<br>  <span class="hljs-built_in">result</span> =<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>: <span class="hljs-string">&quot;negative&quot;</span><br>    <span class="hljs-keyword">elif</span> x &gt; <span class="hljs-number">0</span>: <span class="hljs-string">&quot;positive&quot;</span><br>    <span class="hljs-keyword">else</span>: <span class="hljs-string">&quot;zero&quot;</span><br><br><span class="hljs-keyword">proc</span> toString(x: <span class="hljs-type">bool</span>): <span class="hljs-type">string</span> =<br>  <span class="hljs-built_in">result</span> =<br>    <span class="hljs-keyword">if</span> x: <span class="hljs-string">&quot;yep&quot;</span><br>    <span class="hljs-keyword">else</span>: <span class="hljs-string">&quot;nope&quot;</span><br><br>assert toString(<span class="hljs-number">13</span>) == <span class="hljs-string">&quot;positive&quot;</span> <span class="hljs-comment"># calls the toString(x: int) proc</span><br>assert toString(<span class="hljs-literal">true</span>) == <span class="hljs-string">&quot;yep&quot;</span>    <span class="hljs-comment"># calls the toString(x: bool) proc</span><br></code></pre></td></tr></table></figure><p>(注意，toString通常是Nim中的$操作符。)编译器为toString调用选择最合适的过程。这里不讨论重载解析算法是如何工作的——详细信息请参阅手册。歧义调用被报告为错误。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Nim标准库大量使用了重载——其中一个原因是像+这样的每个操作符都只是一个重载的过程。解析器允许您以中缀符号(a + b)或前缀符号(+ a)使用操作符。中缀操作符总是接收两个参数，前缀操作符总是接收一个参数。(后缀操作符是不可能的，因为这将是模棱两可的:a@ @b是表示(a) @ (@b)还是(a@) @ (b)?它总是表示(a) @ (@b)，因为在Nim中没有后缀操作符。</p><p>除了一些内置的关键字操作符，如and, or, not，操作符总是由以下字符组成:+ - * \ &#x2F; &lt; &gt; &#x3D; @ $ ~ &amp; % !？ ^。|</p><p>允许使用用户定义的操作符。没有什么能阻止你定义自己的@!?+~操作符，但这样做可能会降低可读性。</p><p>操作符的优先级由它的第一个字符决定。详细信息可在手册中找到。</p><p>定义new操作符时，将操作符用反引号” ‘ “括起来:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> `$` (x: myDataType): <span class="hljs-type">string</span> = <br><span class="hljs-comment"># now the $ operator also works with myDataType, overloading resolution</span><br><span class="hljs-comment"># ensures that $ works for built-in types just like before</span><br></code></pre></td></tr></table></figure><h2 id="前置申明"><a href="#前置申明" class="headerlink" title="前置申明"></a>前置申明</h2><p>每个变量、过程等在使用之前都需要声明。(这样做的原因是，在像Nim这样广泛支持元编程的语言中避免这种需求是很重要的。)然而，对于相互递归的过程不能这样做:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># forward declaration:</span><br><span class="hljs-keyword">proc</span> even(n: <span class="hljs-type">int</span>): <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> odd(n: <span class="hljs-type">int</span>): <span class="hljs-type">bool</span> =<br>  assert(n &gt;= <span class="hljs-number">0</span>) <span class="hljs-comment"># makes sure we don&#x27;t run into negative recursion</span><br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">else</span>:<br>    n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> even(n-<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">proc</span> even(n: <span class="hljs-type">int</span>): <span class="hljs-type">bool</span> =<br>  assert(n &gt;= <span class="hljs-number">0</span>) <span class="hljs-comment"># makes sure we don&#x27;t run into negative recursion</span><br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">else</span>:<br>    n == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> odd(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里奇数取决于偶数，反之亦然。因此，甚至需要在编译器完全定义它之前引入它。这种前向声明的语法很简单:只需省略&#x3D;和过程体即可。assert只是添加边界条件，稍后将在模块一节中介绍。</p><p>该语言的后续版本将削弱对前向声明的要求。</p><p>该示例还显示了进程的主体可以由单个表达式组成，然后隐式返回该表达式的值。</p><h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>正如在介绍中提到的，Nim区分了过程、函数和方法，它们分别由proc、func和method关键字定义。在某些方面，Nim的定义比其他语言更迂腐。</p><p>函数更接近于纯数学函数的概念，如果你曾经做过函数式编程，你可能会对它很熟悉。本质上，它们是带有附加限制的过程:它们不能访问全局状态(除了const)，也不能产生副作用。func关键字基本上是带有{. nosideeffects .}标记的proc的别名。然而，函数仍然可以更改其可变参数，即那些标记为var的参数，以及任何ref对象。</p><p>与过程不同，方法是动态分派的。这听起来有点复杂，但它是一个与继承和面向对象编程密切相关的概念。如果您重载一个过程(两个具有相同名称但不同类型或具有不同参数集的过程被称为重载)，要使用的过程将在编译时确定。另一方面，方法依赖于从RootObj继承的对象。这将在本教程的第二部分进行更深入的讨论。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-控制流</title>
    <link href="/2023/11/23/Nim/nim-control-flow/"/>
    <url>/2023/11/23/Nim/nim-control-flow/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim-控制流"><a href="#Nim-控制流" class="headerlink" title="Nim 控制流"></a>Nim 控制流</h1><p>一个基本的程序拥有循环和分支是一件毫无争议的事情。修改以下之前最初始的代码，让我们一起看看新的东西。</p><h2 id="if-分支选择语句"><a href="#if-分支选择语句" class="headerlink" title="if 分支选择语句"></a>if 分支选择语句</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">let</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br><span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span>:<br>  echo <span class="hljs-string">&quot;Poor soul, you lost your name?&quot;</span><br><span class="hljs-keyword">elif</span> name == <span class="hljs-string">&quot;name&quot;</span>:<br>  echo <span class="hljs-string">&quot;Very funny, your name is name.&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;Hi, &quot;</span>, name, <span class="hljs-string">&quot;!&quot;</span><br></code></pre></td></tr></table></figure><p>程序中可以存在零个或者多个<code>elif</code>片段，<code>else</code>也是可选的。关键字<code>elif</code>相比其他语言中的<code>else if</code>更加简短，他也是<code>else if</code>的缩写，这可以避免产生过多的缩进。<br>上端代码首先从键盘中接受一串字符串，如果名字是空字符串（用户直接打了一个回车），则输出“Poor soul, you lost your name?” 如果用户输入的是”name”， 输入就是”Very funny, your name is name”。其他的情况就认为属于合理情况全部放到了else， 都输出 “hi + name + !”</p><h2 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h2><p>case 语句提供了另一种分支方式。 case 语句允许多个分支：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">let</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br><span class="hljs-keyword">case</span> name<br><span class="hljs-keyword">of</span> <span class="hljs-string">&quot;&quot;</span>:<br>  echo <span class="hljs-string">&quot;Poor soul, you lost your name?&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-string">&quot;name&quot;</span>:<br>  echo <span class="hljs-string">&quot;Very funny, your name is name.&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-string">&quot;Dave&quot;</span>, <span class="hljs-string">&quot;Frank&quot;</span>:<br>  echo <span class="hljs-string">&quot;Cool name!&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;Hi, &quot;</span>, name, <span class="hljs-string">&quot;!&quot;</span><br></code></pre></td></tr></table></figure><p>可以看出，对于 of 分支，还允许使用逗号分隔的值列表。</p><p>case中放置需要进行比较的值，每一个of 就是每个条件分支。 粗略看一眼感觉和<code>switch...case</code>差不多，不过这里的case 语句可以处理整数、其他序数类型和字符串。 （很快就会解释什么是序数类型。）对于整数或其他序数类型，值范围也是可能的：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">from</span> std/strutils <span class="hljs-keyword">import</span> parseInt<br><br><span class="hljs-keyword">let</span> score = parseInt(readLine(<span class="hljs-built_in">stdin</span>))<br><span class="hljs-keyword">case</span> score<br><span class="hljs-keyword">of</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span>:<br>    echo <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">8</span>:<br>    echo <span class="hljs-string">&quot;B&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">7</span>:<br>    echo <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">6</span>:<br>    echo <span class="hljs-string">&quot;D&quot;</span><br><span class="hljs-keyword">else</span>:<br>    echo <span class="hljs-string">&quot;F&quot;</span><br></code></pre></td></tr></table></figure><p>因为使用readLine()函数读取到的是一个字符串，然后我们这里需要用到一个<code>int</code>, 那么就需要做一个转换来完成这个事情，这就用到了<code>parseInt()</code>， 然后此函数需要导入一个包才能够使用，这就用到了第一句话<code>from std/strutils import parseInt</code></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># this statement will be explained later:</span><br><span class="hljs-keyword">from</span> std/strutils <span class="hljs-keyword">import</span> parseInt<br><br>echo <span class="hljs-string">&quot;A number please: &quot;</span><br><span class="hljs-keyword">let</span> n = parseInt(readLine(<span class="hljs-built_in">stdin</span>))<br><span class="hljs-keyword">case</span> n<br><span class="hljs-keyword">of</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span>, <span class="hljs-number">4</span>..<span class="hljs-number">7</span>: echo <span class="hljs-string">&quot;The number is in the set: &#123;0, 1, 2, 4, 5, 6, 7&#125;&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">3</span>, <span class="hljs-number">8</span>: echo <span class="hljs-string">&quot;The number is 3 or 8&quot;</span><br></code></pre></td></tr></table></figure><p>这段代码看起来不错，用来分辨一个数字，但是实际上这段代码无法通过编译。因为case语句并没有覆盖所有的情况，列出所有的情况也不是一个很实际的动作，更倾向于忽略掉剩下的情况。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">case</span> n<br><span class="hljs-keyword">of</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span>, <span class="hljs-number">4</span>..<span class="hljs-number">7</span>: echo <span class="hljs-string">&quot;The number is in the set: &#123;0, 1, 2, 4, 5, 6, 7&#125;&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">3</span>, <span class="hljs-number">8</span>: echo <span class="hljs-string">&quot;The number is 3 or 8&quot;</span><br><span class="hljs-keyword">else</span>: <span class="hljs-keyword">discard</span><br></code></pre></td></tr></table></figure><p>这个空的<code>discard</code>语句会告诉编译器这里什么也不做，编译器知道else部分的语句不会判断失败，因此错误会消失。注意，不可能涵盖所有可能的字符串值:这就是为什么字符串情况总是需要一个else分支。</p><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;What&#x27;s your name? &quot;</span><br><span class="hljs-keyword">var</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br><span class="hljs-keyword">while</span> name == <span class="hljs-string">&quot;&quot;</span>:<br>  echo <span class="hljs-string">&quot;Please tell me your name: &quot;</span><br>  name = readLine(<span class="hljs-built_in">stdin</span>) <span class="hljs-comment"># no `var`, because we do not declare a new variable here</span><br></code></pre></td></tr></table></figure><p>这里给的案例比较简单，使用<code>while</code>判断name是不是一个空字符串，如果是空字符串就执行<code>while</code>里面的内容，就是输出”Please tell me your name” 然后让用户再输入一次。当然，如果输入的字符串不是空的，那就跳出了循环。</p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>for语句是循环遍历迭代器提供的任何元素的构造。该示例使用内置计数迭代器:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;Counting to ten: &quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> countup(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>  echo i<br><span class="hljs-comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span><br></code></pre></td></tr></table></figure><p>变量I在 for循环中隐式的被定义为int 类型，这取决于<code>countup()</code>返回了的类型。在循环中i会从1开始经过每次循环最后成为10。使用<code>while</code>也能完成此操作。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;Counting to 10: &quot;</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">10</span>:<br>  echo i<br>  inc i <span class="hljs-comment"># increment i by 1</span><br><span class="hljs-comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span><br></code></pre></td></tr></table></figure><p>上面的代码中，通过<code>inc i</code>的方式让<code>i</code>每次循环都自身+1，他的效果和其他语言中使用到的<code>++i</code>是一样的。</p><p>由于计算时常在程序中发生，所以还有一个做同样事情的迭代器</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">10</span>:<br>  ...<br></code></pre></td></tr></table></figure><p>这样会从100一直递减到1</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> countdown(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>):<br>  sum += i<br>echo sum<br></code></pre></td></tr></table></figure><p>默认情况下，数的左右都是闭区间， 可以用<code>..&lt;</code>表示不到这个数</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; <span class="hljs-number">10</span>:<br>    <span class="hljs-comment"># the same as 0 .. 9</span><br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;some string&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; s.len:<br><span class="hljs-comment"># do something</span><br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;some string&quot;</span><br><span class="hljs-keyword">for</span> idx, c <span class="hljs-keyword">in</span> s[<span class="hljs-number">0</span> .. ^<span class="hljs-number">1</span>]:<br>   <span class="hljs-comment"># ^1 is the last element, ^2 would be one before it, and so on</span><br>   <span class="hljs-comment"># ^1是最后一个元素， ^2是倒数第二个元素</span><br></code></pre></td></tr></table></figure><p>还有一些其他有用的迭代器:</p><ul><li>Items和mitems，分别提供不可变元素和可变元素</li><li>Pairs和mpairs，提供元素和索引号(分别是不可变的和可变的)<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> index, item <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>].pairs:<br>  echo item, <span class="hljs-string">&quot; at index &quot;</span>, index<br><span class="hljs-comment"># =&gt; a at index 0</span><br><span class="hljs-comment"># =&gt; b at index 1</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="作用域和块语句"><a href="#作用域和块语句" class="headerlink" title="作用域和块语句"></a>作用域和块语句</h2><p>控制流语句有一个尚未涉及的特性:它们打开一个新的作用域。这意味着在下面的例子中，x在循环之外是不可访问的:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">while</span> <span class="hljs-literal">false</span>:<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;hi&quot;</span><br>echo x <span class="hljs-comment"># x在这里不工作</span><br></code></pre></td></tr></table></figure><p>while (for)语句引入了一个隐式块。标识符只在声明它们的块中可见。block语句可用于显式地打开一个新块:<br>这个效果类似在C#或者C++中用花括号开了一个block</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">block</span> myblock:<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;hi&quot;</span><br>echo x <span class="hljs-comment"># does not work either</span><br></code></pre></td></tr></table></figure><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>可以使用break语句提前离开块。break语句可以留下while语句、for语句或block语句。它离开最里面的构造，除非给出了块的标签:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">block</span> myblock:<br>  echo <span class="hljs-string">&quot;entering block&quot;</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:<br>    echo <span class="hljs-string">&quot;looping&quot;</span><br>    <span class="hljs-keyword">break</span> <span class="hljs-comment"># 离开了循环但是还在myblock块之中</span><br>  echo <span class="hljs-string">&quot;still in block&quot;</span><br>echo <span class="hljs-string">&quot;outside the block&quot;</span><br><br><span class="hljs-keyword">block</span> myblock2:<br>  echo <span class="hljs-string">&quot;entering block&quot;</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:<br>    echo <span class="hljs-string">&quot;looping&quot;</span><br>    <span class="hljs-keyword">break</span> myblock2 <span class="hljs-comment"># 离开了block,当然也离开了循环</span><br>  echo <span class="hljs-string">&quot;still in block&quot;</span> <span class="hljs-comment"># it won&#x27;t be printed</span><br>echo <span class="hljs-string">&quot;outside the block&quot;</span><br></code></pre></td></tr></table></figure><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p>和其他语言一样,continue会结束本次循环进入下一个循环中</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">5</span>:<br>  <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">3</span>: <span class="hljs-keyword">continue</span><br>  echo i <span class="hljs-comment"># will only print 4 and 5</span><br></code></pre></td></tr></table></figure><h2 id="when-语句"><a href="#when-语句" class="headerlink" title="when 语句"></a>when 语句</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">when</span> system.hostOS == <span class="hljs-string">&quot;windows&quot;</span>:<br>  echo <span class="hljs-string">&quot;running on Windows!&quot;</span><br><span class="hljs-keyword">elif</span> system.hostOS == <span class="hljs-string">&quot;linux&quot;</span>:<br>  echo <span class="hljs-string">&quot;running on Linux!&quot;</span><br><span class="hljs-keyword">elif</span> system.hostOS == <span class="hljs-string">&quot;macosx&quot;</span>:<br>  echo <span class="hljs-string">&quot;running on Mac OS X!&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;unknown operating system&quot;</span><br></code></pre></td></tr></table></figure><p>when语句与if语句几乎相同，但有以下区别:</p><ul><li>每个条件必须是一个常量表达式，因为它是由编译器求值的。</li><li>分支中的语句不会打开新的作用域。</li><li>编译器检查语义，并仅为属于第一个条件且计算结果为true的语句生成代码。</li></ul><p>when语句对于编写特定于平台的代码很有用，类似于C编程语言中的#ifdef构造。</p><h2 id="语句和缩进"><a href="#语句和缩进" class="headerlink" title="语句和缩进"></a>语句和缩进</h2><p>现在我们已经介绍了基本的控制流语句，让我们回到Nim缩进规则。</p><p>在Nim中，简单语句和复杂语句是有区别的。简单语句不能包含其他语句:赋值、过程调用或返回语句都是简单语句。if、when、for、while等复杂语句可以包含其他语句。为了避免歧义，复杂语句必须总是缩进，但单个简单语句不需要:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># no indentation needed for single-assignment statement:</span><br><span class="hljs-keyword">if</span> x: x = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># indentation needed for nested if statement:</span><br><span class="hljs-keyword">if</span> x:<br>  <span class="hljs-keyword">if</span> y:<br>    y = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">else</span>:<br>    y = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># indentation needed, because two statements follow the condition:</span><br><span class="hljs-keyword">if</span> x:<br>  x = <span class="hljs-literal">false</span><br>  y = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>表达式是语句的一部分，通常会产生一个值。if语句中的条件是表达式的一个例子。表达式可以在某些地方包含缩进以获得更好的可读性:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">if</span> thisIsaLongCondition() <span class="hljs-keyword">and</span><br>    thisIsAnotherLongCondition(<span class="hljs-number">1</span>,<br>       <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>):<br>  x = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>根据经验，表达式中的缩进可以在操作符、开括号和逗号之后进行。</p><p>使用括号和分号(;)可以使用只允许表达式的语句:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># computes fac(4) at compile time:</span><br><span class="hljs-keyword">const</span> fac4 = (<span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span>: x *= i; x)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-常量和变量</title>
    <link href="/2023/11/23/Nim/nim-constant-value/"/>
    <url>/2023/11/23/Nim/nim-constant-value/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim中的常量和变量"><a href="#Nim中的常量和变量" class="headerlink" title="Nim中的常量和变量"></a>Nim中的常量和变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量在创建的是否就需要明确的绑定一个值，编译器必须能够在编译时计算常量声明中的表达式。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&quot;abc&quot;</span>  <span class="hljs-comment"># 定一个一个值为&quot;abc&quot;的常量字符串:x</span><br></code></pre></td></tr></table></figure><p>如果要定义多个常量, 可以把const写在前面（ 让我感受到了go语言导包的味道）</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">const</span><br>x = <span class="hljs-number">1</span><br>y = <span class="hljs-number">2</span><br>z = y + <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a>let 语句</h2><p><code>let</code>语句的行为和<code>var</code>看起来差不多，都可以用来定义变量，但是<code>let</code>语句定义的变量在初始化完成之后就无法再次修改。可以理解是一个不可变变量。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">let</span> x = <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-comment"># 没毛病，申明一个新变量x并给他赋值为&quot;abc&quot;</span><br>x = <span class="hljs-string">&quot;xyz&quot;</span> <span class="hljs-comment"># 非法的，不可以再修改x的值</span><br></code></pre></td></tr></table></figure><p>let 和 const 的区别在于：let 引入了一个不能重新赋值的变量，const 的意思是“强制编译时评估并将其放入数据段”：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">const</span> input = readLine(<span class="hljs-built_in">stdin</span>) <span class="hljs-comment">#错误的，编译是无法明确input是什么</span><br><span class="hljs-keyword">let</span> input = readLine(<span class="hljs-built_in">stdin</span>) <span class="hljs-comment"># 正确的，他活了</span><br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>通过<code>var</code>声明的变量可进行多次赋值</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;abc&quot;</span><br>x = <span class="hljs-string">&quot;xyz&quot;</span><br></code></pre></td></tr></table></figure><p>&#x3D; 是赋值运算符。赋值运算符可以重载。您可以使用单个赋值语句声明多个变量，并且所有变量将具有相同的值：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> x, y = <span class="hljs-number">3</span>  <span class="hljs-comment"># assigns 3 to the variables `x` and `y`</span><br>echo <span class="hljs-string">&quot;x &quot;</span>, x  <span class="hljs-comment"># outputs &quot;x 3&quot;</span><br>echo <span class="hljs-string">&quot;y &quot;</span>, y  <span class="hljs-comment"># outputs &quot;y 3&quot;</span><br>x = <span class="hljs-number">42</span>        <span class="hljs-comment"># changes `x` to 42 without changing `y`</span><br>echo <span class="hljs-string">&quot;x &quot;</span>, x  <span class="hljs-comment"># outputs &quot;x 42&quot;</span><br>echo <span class="hljs-string">&quot;y &quot;</span>, y  <span class="hljs-comment"># outputs &quot;y 3&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-hello world</title>
    <link href="/2023/11/23/Nim/nim-hello/"/>
    <url>/2023/11/23/Nim/nim-hello/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim-Hello-world"><a href="#Nim-Hello-world" class="headerlink" title="Nim - Hello world!"></a>Nim - Hello world!</h1><p>这段时间一直在玩Haskell, 有点小腻。换个编程语言看看调节一下口味，本系列是对官方文档《 <a href="https://nim-lang.org/docs/tut1.html">Tutorial, part 1</a>》《  <a href="https://nim-lang.org/docs/tut2.html">Tutorial, part 2</a>》和《<a href="https://nim-lang.org/docs/tut3.html">Tutorial, part 3</a>》三部曲进行学习，然后增加了本人的一些思索过程，可全当作是官方学习手册的汉化版本。<br>话不多说，我们直接开始吧。上手，先来一个基本的小程序，问你的名字是什么，然后输出 “hi” + name + “!”。 </p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># This is a comment</span><br>echo <span class="hljs-string">&quot;What&#x27;s your name? &quot;</span><br><span class="hljs-keyword">var</span> name: <span class="hljs-type">string</span> = readLine(<span class="hljs-built_in">stdin</span>)<br>echo <span class="hljs-string">&quot;Hi, &quot;</span>, name, <span class="hljs-string">&quot;!&quot;</span><br></code></pre></td></tr></table></figure><p>将文件保存叫做greetings.nim， 之后就是编译运行他。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim compile --run greetings.nim<br></code></pre></td></tr></table></figure><p>添加上<code>--run</code>参数后便可以让nim编译文件通过后运行他，在文件名之后也可以添加运行参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim compile --run greetings.nim arg1 arg2<br></code></pre></td></tr></table></figure><p>常用的命令和开关都有缩写，因此您还可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim c -r greetings.nim<br></code></pre></td></tr></table></figure><p>在默认情况下编译采用的是<code>Debug</code>模式，如果想要以<code>Release</code>模式进行编译，需要显式添加参数<code>-d:release</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim c -d:release greetings.nim<br></code></pre></td></tr></table></figure><p>默认情况下，Nim 编译器会生成大量运行时检查，旨在满足您的调试乐趣。使用 -d:release 会关闭一些检查并打开优化。<br>对于基准测试或生产代码，请使用 -d:release 开关。要将性能与 C 等不安全语言进行比较，请使用 -d:danger 开关以获得有意义的、可比较的结果。否则，Nim 可能会受到 C 无法使用的检查的阻碍。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在使用到在字符串时，需要用双引号将字符串包起来，这样编译器才会认为这是一个字符串。 var 语句声明一个名为 name 的字符串类型的新变量，其值由 readLine 过程返回。由于编译器知道 readLine 返回一个字符串，因此您可以在声明中省略类型（这称为本地类型推断）。所以这也可以工作：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br></code></pre></td></tr></table></figure><p>请注意，这基本上是 Nim 中存在的唯一类型推断形式：它是简洁性和可读性之间的良好折衷。  </p><p>“hello world”程序包含编译器已知的几个标识符：echo、readLine 等。这些内置函数在系统模块中声明，并由任何其他模块隐式导入。</p><h2 id="词汇元素"><a href="#词汇元素" class="headerlink" title="词汇元素"></a>词汇元素</h2><p>让我们更详细地看看 Nim 的词汇元素：与其他编程语言一样，Nim 由（字符串）文字、标识符、关键字、注释、运算符和其他标点符号组成。</p><h3 id="字符串和符号字面量"><a href="#字符串和符号字面量" class="headerlink" title="字符串和符号字面量"></a>字符串和符号字面量</h3><p>字符串需要被一对双引号包裹在里面，特殊的字符（转义字符）使用<code>\</code> 转义符号进行修饰，<code>\n</code>表示换行，<code>\t</code>表示制表符缩进，还有很多别的符号。如果我们不需要转义的字符串，而是一个原始文本，那么在字符串前添加一个<code>r</code>即可。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-string">r&quot;C:\program files\nim&quot;</span><br></code></pre></td></tr></table></figure><p>在原始文字中，反斜杠不是转义字符。<br>编写字符串文字的第三种也是最后一种方法是长字符串文字。它们用三个引号写成：“”“…”“”；它们可以跨越多行，并且 \ 也不是转义字符。例如，它们对于嵌入 HTML 代码模板非常有用。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释以字符串或字符文字之外的任意位置开始，并以井号字符 # 开头。文档注释以##开头：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># A comment.</span><br><br><span class="hljs-keyword">var</span> myVariable: <span class="hljs-type">int</span> <span class="hljs-comment">## a documentation comment</span><br></code></pre></td></tr></table></figure><p>文档注释是标记;它们只允许出现在输入文件的特定位置，因为它们属于语法树!该特性支持更简单的文档生成器。<br>多行注释以#[ 开始，以]# 结束。多行注释也可以嵌套。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment">#[</span><br><span class="hljs-type">You</span> can have <span class="hljs-type">any</span> <span class="hljs-type">Nim</span> code text commented<br><span class="hljs-keyword">out</span> inside this <span class="hljs-keyword">with</span> no indentation restrictions.<br>      yes(<span class="hljs-string">&quot;May I ask a pointless question?&quot;</span>)<br>  <span class="hljs-comment">#[</span><br>     <span class="hljs-type">Note</span>: these can be nested!!<br>  ]<span class="hljs-comment">#</span><br>]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>数字文字的书写方式与大多数其他语言一样。作为一个特殊的变化，允许使用下划线以获得更好的可读性:1_000_000(一百万)。包含点(或’e’或’e’)的数字是浮点文字:10.e9(十亿)。十六进制字面值以0x为前缀，二进制字面值以0b为前缀，八进制字面值以0为前缀。单独的前导零不能产生八进制数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell-柯里函数</title>
    <link href="/2023/11/21/Haskell/haskell-currying/"/>
    <url>/2023/11/21/Haskell/haskell-currying/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-柯里函数"><a href="#Haskell-柯里函数" class="headerlink" title="Haskell - 柯里函数"></a>Haskell - 柯里函数</h1><p>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。<br>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//传统写法</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> result2 = <span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>);  <span class="hljs-comment">//柯里化</span><br></code></pre></td></tr></table></figure><p>在Haskell中所有的函数其实都只有一个参数，我们事实上编辑的所有多参数的函数都是柯里函数。柯里函数不会一次性读完所有参数，而是在每次调用时只取一个参数，并返回一个一元函数来取下一个函数。<br>所以说在Haskell中这两种调用方法是一样的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">max</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>(max <span class="hljs-number">4</span>) <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这是怎么实现的呢？先看一下函数原型是啥样子的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; :t max<br>max :: Ord a =&gt; a -&gt; a -&gt; a<br></code></pre></td></tr></table></figure><p>上面的申明也可以写成下面的样子：<code>max :: Ord a =&gt; a -&gt; (a -&gt; a)</code><br>只要在类型签名中看到 <code>-&gt;</code>，就一律意味着它是一个将箭头左侧是为参数类型并将箭头右侧的部分视作返回类型的函数。如果遇到<code>a -&gt; (a -&gt; a)</code>这样的类型签名，就是说它是一个函数，会接受一个a作为参数，然后返回一个函数，然后这个函数也是取a作为参数，返回一个类型为a的值。</p><p>这有什么好处呢？只要用部分参数来调用某个函数，就可以得到一个部分应用函数，此函数接受的参数的数量和之前少传入的参数数量一致。因此可以通过初始的一个简单函数来构造出更复杂的函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">multThree</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">multThree</span> x y z = x * y * z<br></code></pre></td></tr></table></figure><p>使用<code>((multThree 3) 5 ) 9</code> 的方式调用他，一开始接受一个参数3， 那么返回一个函数的一元函数，之后再给一个5， 就会得到3 * 5 的函数， 然后再传一个9， 最后返回135。</p><p>其实可以理解将一部分参数丢给一个函数，函数会返回一个带着他一部分结果的小函数，然后这个小函数再接受一个参数，然后再返回一个函数。最后直到函数被灌满结束。<br>通过这个，我们可以玩一个好玩的</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">multTwoWithNine</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">multTwoWithNine</span> = multThree <span class="hljs-number">9</span><br><span class="hljs-comment">-- 等价于</span><br><span class="hljs-comment">-- multTwoWith x y = multTHree 9 x y</span><br><br><span class="hljs-title">multTwoWithNine</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-comment">-- 返回54</span><br></code></pre></td></tr></table></figure><h2 id="截断（section）"><a href="#截断（section）" class="headerlink" title="截断（section）"></a>截断（section）</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">divideByTen</span> :: (<span class="hljs-type">Floating</span> a) =&gt; a -&gt; a<br><span class="hljs-title">divideByTen</span> = (/<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>用括号将一个中缀函数包裹起来，得到一个一元函数，其参数代表函数的剩余参数。这个<code>/</code>函数本来需要左右都有一个参数才可以使用，然后用括号包裹他之后就宛如截断了一样，然后<code>/</code>本来需要两个参数，现在填充了一个参数，<code>divideByTen</code>再提供一个参数。<br>这样的写法<code>divideByTen 200</code> 和 直接调用 <code>(/10) 200</code> 或者 <code>200 / 10</code>的效果是一样的。</p><h2 id="打印函数"><a href="#打印函数" class="headerlink" title="打印函数"></a>打印函数</h2><p>如果直接将函数打印出来会怎么样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; multThree 3 4<br><br>&lt;interactive&gt;:4:1: error:<br>    • No instance <span class="hljs-keyword">for</span> (Show (Integer -&gt; Integer))<br>        arising from a use of ‘<span class="hljs-built_in">print</span>’<br>        (maybe you haven<span class="hljs-string">&#x27;t applied a function to enough arguments?)</span><br><span class="hljs-string">    • In a stmt of an interactive GHCi command: print it</span><br></code></pre></td></tr></table></figure><p>GHCI： 表达式返回一个类型为 a -&gt; a 函数，但是不知道如何将他显示到屏幕上。函数g并非Show类型类的实例。<br>为什么我们执行 1+1的时候可以得到2呢？因为它会首先计算得到2, 然后调用<code>show</code> 得到该数字的字符串表示，然后再输出到屏幕上。</p><p><strong>所以一定要理解柯里函数的工作原理，在Haskell中真的非常重要！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 递归</title>
    <link href="/2023/11/21/Haskell/haskell-recursion/"/>
    <url>/2023/11/21/Haskell/haskell-recursion/</url>
    
    <content type="html"><![CDATA[<h1 id="你好，递归"><a href="#你好，递归" class="headerlink" title="你好，递归"></a>你好，递归</h1><p>递归是指在定义的应用自身的方式，将白了就是函数会自己调用自己。“从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，讲的是什么呢：从前有座山，山里有座庙……”<br>数学定义中存在的递归随处可见，比如斐波那契数列，杨辉三角形等。递归在函数式语言中能够发挥真正的威力，因为在函数式编程中，重要的不是给出求解的步骤，而是定义问题与解的描述。<br>在下文会使用Haskell和C++两种语言进行描述。</p><ol><li><p>求列表中元素的最大值</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">maximumNumber</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">maximumNumber</span> [] = error <span class="hljs-string">&quot;maximumNumber of empty list&quot;</span><br><span class="hljs-title">maximumNumber</span> [oneElement] = oneElement<br><span class="hljs-title">maximumNumber</span> (element : elements) = max element (maximumNumber elements)<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print $ maximumNumber [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure></li><li><p>求斐波那契数列</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">fibonacci</span> :: (<span class="hljs-type">Num</span> a, <span class="hljs-type">Ord</span> a) =&gt; a -&gt; a<br><span class="hljs-title">fibonacci</span> <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-title">fibonacci</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br><span class="hljs-title">fibonacci</span> n = fibonacci (n - <span class="hljs-number">1</span>) + fibonacci (n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> N&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> fibonacci = fibonacci&lt;N<span class="hljs-number">-1</span>&gt; + fibonacci&lt;N<span class="hljs-number">-2</span>&gt;;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> fibonacci&lt;<span class="hljs-number">1</span>&gt; = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> fibonacci&lt;<span class="hljs-number">0</span>&gt; = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>实现replicate</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">replicate&#x27;</span> :: <span class="hljs-type">Int</span> -&gt; a -&gt; [a]<br><span class="hljs-title">repllicte&#x27;</span> n x<br>| n &lt;= <span class="hljs-number">0</span> = []<br>| otherwise = x:replicate&#x27; (n-<span class="hljs-number">1</span>) x<br></code></pre></td></tr></table></figure></li><li><p>实现take</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">take&#x27;</span> :: (<span class="hljs-type">Num</span> i, <span class="hljs-type">Ord</span> i) =&gt; i -&gt; [a] -&gt; a<br><span class="hljs-title">take&#x27;</span> n _        <br>| n &lt;= <span class="hljs-number">0</span>     = []<br><span class="hljs-title">take&#x27;</span> _ []       = []<br><span class="hljs-title">take&#x27;</span> n (x:xs)   = x : take&#x27; (n-<span class="hljs-number">1</span>) xs<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell-case</title>
    <link href="/2023/11/21/Haskell/haskell-case/"/>
    <url>/2023/11/21/Haskell/haskell-case/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-case"><a href="#Haskell-case" class="headerlink" title="Haskell - case"></a>Haskell - case</h1><p>函数中模板匹配的本质实际上就是case语句的语法糖。case语句在函数式编程中用途往往比命令式要大很多，因为这样可以很流畅的定义出一个没有指令流程的函数，使得函数的定义更加流畅。<br>举一个简单的例子</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetterV1</span> :: [a] -&gt; a<br><span class="hljs-title">firstLetterV1</span> [] = error <span class="hljs-string">&quot;Null list&quot;</span><br><span class="hljs-title">firstLetterV1</span> [x:_] = x<br></code></pre></td></tr></table></figure><p>完全等价于这段代码</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetterV2</span> :: [a] -&gt; a<br><span class="hljs-title">firstLetterV2</span> str = <span class="hljs-keyword">case</span> str <span class="hljs-keyword">of</span> [] -&gt; error <span class="hljs-string">&quot;Null list&quot;</span><br>                                (x:_) -&gt; x<br></code></pre></td></tr></table></figure><p>从中我们可以看到case表达式语法长这个样子<br> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">case</span> expression <span class="hljs-keyword">of</span> pattern -&gt; result<br> pattern -&gt; result<br> pattern -&gt; result<br> <span class="hljs-comment">-- ....</span><br></code></pre></td></tr></table></figure></p><p>于是乎就可以写出这样的代码</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">scoreValue</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Char</span><br><span class="hljs-title">scoreValue</span> value =<br>    <span class="hljs-keyword">let</span> range = div value <span class="hljs-number">10</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span> range <span class="hljs-keyword">of</span> <span class="hljs-number">6</span> -&gt; <span class="hljs-string">&#x27;D&#x27;</span><br>                     <span class="hljs-number">7</span> -&gt; <span class="hljs-string">&#x27;C&#x27;</span><br>                     <span class="hljs-number">8</span> -&gt; <span class="hljs-string">&#x27;B&#x27;</span><br>                     <span class="hljs-number">9</span> -&gt; <span class="hljs-string">&#x27;A&#x27;</span><br>                     <span class="hljs-number">10</span> -&gt; <span class="hljs-string">&#x27;S&#x27;</span><br>                     _ -&gt; <span class="hljs-string">&#x27;F&#x27;</span><br><br><span class="hljs-title">describeList</span> :: [a] -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">describeList</span> ls = <span class="hljs-string">&quot;The list is &quot;</span> ++ str ls<br>    <span class="hljs-keyword">where</span> str [] = <span class="hljs-string">&quot;empty&quot;</span><br>          str [x] = <span class="hljs-string">&quot;a singleton list&quot;</span><br>          str ls = <span class="hljs-string">&quot;a longer list&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - let</title>
    <link href="/2023/11/21/Haskell/haskell-let/"/>
    <url>/2023/11/21/Haskell/haskell-let/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-let"><a href="#Haskell-let" class="headerlink" title="Haskell - let"></a>Haskell - let</h1><p>我们可以在函数中使用<code>where</code>比较轻松的在函数底部绑定变量，他对包括所有<code>guard</code>在内的整个函数可见。可我们还想要更多的功能，比如函数处理过程中可能需要一些局部变量，或者做一些临时运算，那么<code>let</code>可以完成这个功能。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">cylinder</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span><br><span class="hljs-title">cylinder</span> r h = <br>    <span class="hljs-keyword">let</span> sideArea = h * r * <span class="hljs-number">2</span><br>        topArea = pi * r * r<br>    <span class="hljs-keyword">in</span> sideArea + topArea<br>    <br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print $ cylinder <span class="hljs-number">3</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><em>let &lt; bindings &gt; in &lt; expressions &gt;</em> let中绑定的名字只能在in中使用<br>let 和 where最大的区别就是 let是一个表达式，表达式一定是有一个返回值的，而where不是。所以let可以在几乎任何地方使用。</p><p>从一个元组中取值</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell">(<span class="hljs-keyword">let</span> (a, b, c) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> a + b + c) * <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这里让a,b,c分别匹配到了数字1, 2, 3， 之后再相加乘以100，最后结果是600</p><h2 id="列表推导式中的let"><a href="#列表推导式中的let" class="headerlink" title="列表推导式中的let"></a>列表推导式中的let</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="hljs-keyword">let</span> bmi = w / h ^ <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="hljs-keyword">let</span> bmi = w / h ^ <span class="hljs-number">2</span>, bmi &gt; <span class="hljs-number">25.0</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java小实验-初步使用类</title>
    <link href="/2023/11/18/Java/java-example-2/"/>
    <url>/2023/11/18/Java/java-example-2/</url>
    
    <content type="html"><![CDATA[<h1 id="java小实验-初步使用类"><a href="#java小实验-初步使用类" class="headerlink" title="java小实验-初步使用类"></a>java小实验-初步使用类</h1><p>定义一个学生类，包含的成员有：姓名，学号，绩优成绩，总人数，平均绩优成绩等数据成员，和数据的getter 和setter方法，以及toString 方法，合理使用 public, private, static,final等限定词。主函数中创建５个学生对象，输出每个学生的个性信息，以及全部学生对象的全局信息。</p><p><strong>Student.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> String id;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> score;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> total;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> average;  <br>  <br>    Student(String name, String id, <span class="hljs-type">double</span> score) &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>        <span class="hljs-built_in">this</span>.score = score;  <br>        average = (average * total++ + score) / total;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetName</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetId</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetScore</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetName</span><span class="hljs-params">(String name)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetId</span><span class="hljs-params">(String id)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetScore</span><span class="hljs-params">(<span class="hljs-type">double</span> score)</span>&#123;  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">lastScore</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.score;  <br>        average =  (average * total - lastScore + score) / total;  <br>        <span class="hljs-built_in">this</span>.score = score;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetCount</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> total;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetAverage</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> average;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;学号%s 姓名%s 成绩%f&quot;</span>, GetId(), GetName(), GetScore());  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student1.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test2&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        student2.SetId(<span class="hljs-string">&quot;1919810&quot;</span>);  <br>        System.out.println(student2.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test3&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student3.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test4&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student4.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test5&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student5.toString());  <br>  <br>        System.out.println(<span class="hljs-string">&quot;平均成绩 &quot;</span> + student1.GetAverage());  <br>        student3.SetScore(<span class="hljs-number">80.5</span>);  <br>        System.out.println(<span class="hljs-string">&quot;平均成绩 &quot;</span> + student1.GetAverage());  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - where</title>
    <link href="/2023/11/16/Haskell/haskell-where/"/>
    <url>/2023/11/16/Haskell/haskell-where/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-where"><a href="#Haskell-where" class="headerlink" title="Haskell - where"></a>Haskell - where</h1><p> 引入一个小案例<br> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTest</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTest</span> weight height<br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">18.5</span> = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">25</span> = <span class="hljs-string">&quot;Normal&quot;</span><br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">30</span> = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br></code></pre></td></tr></table></figure><br>这是一个简单的bmi指数测试函数，使用了前一篇的guard完成，这样写挺好，但是还是不够完美。这里对bmi数值有三次重复的计算，如果输入的数据走到了otherwise就会算三次，血亏！<br>让我们稍加修改一下代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTestV2</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTestV2</span> weight height<br>    | bmi &lt;= underWeight = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | bmi &lt;= normal = <span class="hljs-string">&quot;Normal&quot;</span><br>    | bmi &lt;= overWeight = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span><br>          underWeight = <span class="hljs-number">18.5</span><br>          normal = <span class="hljs-number">25</span><br>          overWeight = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>看着代码应该就明白这个怎么回事了，但是有一点需要吐槽，就是这个缩进问题，他不是像python那样固定缩进到一个代码块就ok了，而是变量定义都必须对齐到同一列，如果不这样规范，Haskell就会搞不清楚他们各自位于哪个代码块中了。</p><h2 id="where的作用域"><a href="#where的作用域" class="headerlink" title="where的作用域"></a><code>where</code>的作用域</h2><p>函数where部分定义的名字只对本函数可见，所以不用担心存在大量的全局函数污染代码。当然如果想要一个全局变量，那么反而是要自己定义一下的。</p><h2 id="where中的模式模式匹配"><a href="#where中的模式模式匹配" class="headerlink" title="where中的模式模式匹配"></a><code>where</code>中的模式模式匹配</h2><p>在where中也可以使用到模式匹配，修改前面的BMI函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTestV2</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTestV2</span> weight height<br>    | bmi &lt;= underWeight = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | bmi &lt;= normal = <span class="hljs-string">&quot;Normal&quot;</span><br>    | bmi &lt;= overWeight = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span><br>          (underWright, normal, overHeight) = (<span class="hljs-number">18.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">30.0</span>)<br></code></pre></td></tr></table></figure><h2 id="where块中的函数"><a href="#where块中的函数" class="headerlink" title="where块中的函数"></a><code>where</code>块中的函数</h2><p>在where中也可以定义函数，美滋滋属于是了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>. <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs]<br><span class="hljs-keyword">where</span> bmi weight height = weight / height ^ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - guard</title>
    <link href="/2023/11/16/Haskell/haskell-guard/"/>
    <url>/2023/11/16/Haskell/haskell-guard/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-guard"><a href="#Haskell-guard" class="headerlink" title="Haskell - guard"></a>Haskell - guard</h1><p><strong>Haskell - guard</strong></p><p>在Haskell中，guard是一种编程技巧，用于在满足某个条件时执行一段代码，否则跳过该代码块。guard通常用于控制流语句（如if、elif和else）中，用于在满足某个条件时执行相应的代码。<br>除了使用其他语言基本都会存在的控制流语句之外，还可以使用**|** 来进行条件分支的处理，可读性更高而且与模式匹配契合的非常好</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">scoreLevel</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">scoreLevel</span> score<br>    | score &lt; <span class="hljs-number">60</span> = <span class="hljs-string">&quot;Failed!&quot;</span><br>    | score &lt; <span class="hljs-number">70</span> = <span class="hljs-string">&quot;Passed!&quot;</span><br>    | score &lt; <span class="hljs-number">80</span> = <span class="hljs-string">&quot;Good!&quot;</span><br>    | score &lt; <span class="hljs-number">90</span> = <span class="hljs-string">&quot;Excellent!&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Perfect!&quot;</span><br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (scoreLevel <span class="hljs-number">60</span>)<br>    print (scoreLevel <span class="hljs-number">70</span>)<br>    print (scoreLevel <span class="hljs-number">80</span>)<br>    print (scoreLevel <span class="hljs-number">90</span>)<br></code></pre></td></tr></table></figure><p>这段代码定义了一个名为<code>scoreLevel</code>的函数，接受一个<code>Double</code>类型的参数<code>score</code>，并返回一个字符串。该函数根据<code>score</code>的值，返回不同的字符串。otherwise会捕获剩下的所有条件。<br>一个竖线就是一个布尔表达式，如果计算是True就会选择对应的函数进入，如果是False就会走下面的表达式。一句题外话， |  不像 switch..case一样，进入一个case后就会执行下面的case所有语句。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">myCompare</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type">Ordering</span><br><span class="hljs-title">myCompare</span> x y<br>    | x &gt; y = <span class="hljs-type">GT</span><br>    | x == y = <span class="hljs-type">EQ</span><br>    | otherwise = <span class="hljs-type">LT</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 模式匹配</title>
    <link href="/2023/11/16/Haskell/haskell-pattern-matching/"/>
    <url>/2023/11/16/Haskell/haskell-pattern-matching/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-模式匹配"><a href="#Haskell-模式匹配" class="headerlink" title="Haskell - 模式匹配"></a>Haskell - 模式匹配</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>引子：假设我们要一个函数，这个函数可以处理一个数是不是7。按照之前的思路，我们可以这样写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">isSevenV1</span> x = <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;Is seven&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Is not seven&quot;</span><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ isSevenV1<br></code></pre></td></tr></table></figure><p>那么如果是判断一个数的是0-10中的哪一个，是否这样写会稍微麻烦一点，不过可能想到使用列表<code>[(1,&quot;one&quot;),(2,&quot;two&quot;)]</code>这样来处理。 </p><p>那么或许有一个不错的方法——模式匹配</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">isSevenV1</span> x = <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;Is seven&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Is not seven&quot;</span><br><br>  <br><br><span class="hljs-title">isSevenV2</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">isSevenV2</span> <span class="hljs-number">7</span> = <span class="hljs-string">&quot;Is seven&quot;</span><br><span class="hljs-title">isSevenV2</span> x = <span class="hljs-string">&quot;Is not seven&quot;</span><br><br>  <br><span class="hljs-title">sayNumber</span> ::<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">1</span> = <span class="hljs-string">&quot;One&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">2</span> = <span class="hljs-string">&quot;Two&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">3</span> = <span class="hljs-string">&quot;Three&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">4</span> = <span class="hljs-string">&quot;Four&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">5</span> = <span class="hljs-string">&quot;Five&quot;</span><br><span class="hljs-title">sayNumber</span> x = <span class="hljs-string">&quot;Not between 1 and 5&quot;</span><br><br>  <br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br><br><span class="hljs-title">print</span> $ isSevenV1 <span class="hljs-number">7</span><br><span class="hljs-title">print</span> $ isSevenV2 <span class="hljs-number">8</span><br><span class="hljs-title">print</span> $ isSevenV2 <span class="hljs-number">7</span><br><br>  <br><span class="hljs-title">print</span> $ sayNumber <span class="hljs-number">3</span><br><span class="hljs-title">print</span> $ sayNumber <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>在调用函数时，会将传入的参数从上往下顺序检查，一旦有匹配，对应的函数就会被调用。 如果给出一个x,y,z这样的参数，那么他就成为了一个万能模式，可以匹配到所有的参数， 一个好处就是可以处理最后情况之外的部分。<br>当然如果将万能模式丢到了函数最上面，那么很抱歉，万能模式函数之后的函数就永远都不会匹配到了。</p><p><em>使用模式匹配完成一个求阶乘</em></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">factorial</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">factorial</span> <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br><span class="hljs-title">factorial</span> n = n * factorial (n - <span class="hljs-number">1</span>)<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ factorial <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>不过有些函数看起来可以正常运行，但是实际上却会出发runtime error。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">charName</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;a&#x27;</span> = <span class="hljs-number">1</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;b&#x27;</span> = <span class="hljs-number">2</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;c&#x27;</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果我们在调用函数的时候，使用<code>charName &#39;h&#39;</code>。 可以得到<code>Non-exhaustive</code>因为这套模板没有不够全面，没有考虑到’a’ ‘b’ ‘c’三者之外的情况。那么程序也就会发生不可预料的问题，这里其实也有一定的防御式编程思想。</p><h2 id="元组的模式匹配"><a href="#元组的模式匹配" class="headerlink" title="元组的模式匹配"></a>元组的模式匹配</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">addVectorsV1</span> :: (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)<br><span class="hljs-title">addVectorsV1</span> a b = (fst a + fst b, snd a + snd b)<br><br><span class="hljs-title">addVectorsV2</span> :: (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)<br><span class="hljs-title">addVectorsV2</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)<br><br>  <br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ addVectorsV1 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>print $ addVectorsV2 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>虽然我们可以使用<code>addVectorV1</code>的方式去处理两个或者多个元组的之间的操作。针对于每一个元组用fst和snd取双元组的两个元素。可以运行,没有问题。但是有更加漂亮的做法<code>addVectorV2</code><br>参数直接上两个元组，还有了名字，用两个字来说：优雅。</p><p><strong>实现一个三元组</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">tupleFirst</span> :: (a,b,c) -&gt; a<br><span class="hljs-title">tupleFirst</span> (x,_,_) = x<br>  <br><span class="hljs-title">tupleSecond</span> :: (a,b,c) -&gt; b<br><span class="hljs-title">tupleSecond</span> (_,y,_) = y<br><br><span class="hljs-title">tuledThird</span> :: (a,b,c) -&gt; c<br><span class="hljs-title">tuledThird</span> (_,_,z) = z<br></code></pre></td></tr></table></figure><p>不用关心具体是什么类型，也不需要管具体的内容，给上一个泛变量就ok了。</p><h2 id="列表与列表推导式匹配"><a href="#列表与列表推导式匹配" class="headerlink" title="列表与列表推导式匹配"></a>列表与列表推导式匹配</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">xs</span> = [(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">5</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)]<br>[a + b | (a,b) &lt;- xs]<br></code></pre></td></tr></table></figure><p>可以得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ghci">[4,7,6,8,11] <br></code></pre></td></tr></table></figure><p><strong>做一个简单的head函数</strong><br><em>([1,2,3] 只是一个 1:2:3:[]的语法糖)</em></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">head</span>` :: [a] -&gt; a<br><span class="hljs-title">head</span>` [] = error &#x27;<span class="hljs-type">Can</span> not call head on a empty list&#x27;<br><span class="hljs-title">head</span>` (x:_) = x<br></code></pre></td></tr></table></figure><h2 id="As模式"><a href="#As模式" class="headerlink" title="As模式"></a>As模式</h2><p>允许按照模式将一个值分割成多个项，同时保留对其整体的引用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetter</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">firstLetter</span> <span class="hljs-string">&quot;&quot;</span> = <span class="hljs-string">&quot;Empty string&quot;</span><br><span class="hljs-title">firstLetter</span> all@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ firstLetter <span class="hljs-string">&quot;&quot;</span><br>    print $ firstLetter <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>这个函数接受一个字符串参数，并返回一个字符串。<br><code>firstLetter :: String -&gt; String</code></p><p>函数的实现分为两种情况：</p><ol><li>如果输入的字符串为空字符串（””），则返回字符串 “Empty string”。</li><li>如果输入的字符串非空，则返回字符串 “The first letter of [all] is [first letter]”。其中 <code>[all]</code> 和 <code>[first letter]</code> 分别表示输入的字符串 <code>all</code> 和第一个字母 <code>first letter</code>。</li></ol><p>函数的实现使用了一个As模式<code>all@(x:xs)</code>，它表示一个字符串 <code>all</code>，其中 <code>x</code> 是字符串 <code>xs</code> 的第一个字符。这里或许会因为变量名字觉得理解，xs是否是x+s这种情况，实际上也可以命名为(firstLetter : exceptFirstLetter)也是一样的。这也是上面说的列表的语法糖。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">all</span>@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x]<br></code></pre></td></tr></table></figure><p>这个匿名函数的目的是将字符串 <code>all</code> 的第一个字母替换为输入字符串 <code>all</code> 的第一个字母，并将结果与字符串 <code>[x]</code> 连接起来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 顺序表结构</title>
    <link href="/2023/11/15/DataStructure/c-seqlist/"/>
    <url>/2023/11/15/DataStructure/c-seqlist/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言顺序表结构"><a href="#C语言顺序表结构" class="headerlink" title="C语言顺序表结构"></a>C语言顺序表结构</h1><p>顺序表，也称作线性表，是数据结构的一种，由一系列数据元素组成，每个数据元素在内存中按顺序存放。顺序表中的数据元素可以是相同类型的数据，也可以是不同类型的数据。</p><p>在计算机科学中，顺序表通常用数组表示，数组是一个由相同类型的数据元素组成的集合。数组中的每个元素都存储在一个连续的内存地址中，并且可以通过它们的索引来访问。</p><p>例如，下面是一个用Python表示的顺序表，其中包含整数：<br><code>my_list = [1, 2, 3, 4, 5]</code></p><p>在这个例子中，<code>my_list</code>是一个包含五个整数的顺序表，它们的值分别为1、2、3、4、5。要访问其中某个元素的值，可以使用索引，例如：<br><code>first_element = my_list[0]  # first_element的值为1 second_element = my_list[1]  # second_element的值为2</code></p><p>顺序表可以用于存储各种类型的数据，如整数、浮点数、对象等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEQUENTIAL_LIST_H  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQUENTIAL_LIST_H  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];  <br>    <span class="hljs-type">int</span> age;  <br>&#125; Data;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>    Data *list_data;  <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEQUENTIAL_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQUENTIAL_LIST_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125; Data;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Data *list_data;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> max_length;<br>&#125; sequential_list;<br><br><span class="hljs-comment">// initialize the list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_init</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-built_in">list</span>-&gt;list_data = (Data *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Data) * size);<br>    <span class="hljs-built_in">list</span>-&gt;max_length = size;<br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// return the length of the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_length</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// append a new element to the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_append</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, Data data)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;length &gt;= <span class="hljs-built_in">list</span>-&gt;max_length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">list</span>-&gt;list_data[<span class="hljs-built_in">list</span>-&gt;length++] = data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// insert a new element to the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_insert</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index, Data data)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;max_length || index &gt; <span class="hljs-built_in">list</span>-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// shift the elements to the right</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">list</span>-&gt;length; i &gt; index; i--) &#123;<br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// insert the new element</span><br>    <span class="hljs-built_in">list</span>-&gt;list_data[index] = data;<br>    <span class="hljs-built_in">list</span>-&gt;length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// delete an element from the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_delete</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span>(index &lt;<span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// shift the elements to the left</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index; i&lt;<span class="hljs-built_in">list</span>-&gt;length; i--)&#123;<br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> --<span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_get_index</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, Data data)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(data.age == <span class="hljs-built_in">list</span>-&gt;list_data[i].age &amp;&amp; <span class="hljs-built_in">strcmp</span>(data.name, <span class="hljs-built_in">list</span>-&gt;list_data[i].name) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>Data* <span class="hljs-title function_">set_get_element</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-built_in">list</span>-&gt;list_data[index];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_clean</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span>&#123;  <br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">list</span>-&gt;list_data);  <br>    <span class="hljs-built_in">list</span>-&gt;max_length = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data = <span class="hljs-literal">NULL</span>;  <br>&#125;<br><br><span class="hljs-comment">// print the element in the list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_print_element</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;age);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//SEQUENTIAL_LIST_H</span></span><br>    <span class="hljs-type">int</span> length;  <br>    <span class="hljs-type">int</span> max_length;  <br>&#125; sequential_list;  <br>  <br><span class="hljs-comment">// initialize the list  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_init</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> size)</span> &#123;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data = (Data *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Data) * size);  <br>    <span class="hljs-built_in">list</span>-&gt;max_length = size;  <br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// return the length of the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_length</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// append a new element to the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_append</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, Data data)</span> &#123;  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;length &gt;= <span class="hljs-built_in">list</span>-&gt;max_length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data[<span class="hljs-built_in">list</span>-&gt;length++] = data;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// insert a new element to the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_insert</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index, Data data)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;max_length || index &gt; <span class="hljs-built_in">list</span>-&gt;length) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// shift the elements to the right  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">list</span>-&gt;length; i &gt; index; i--) &#123;  <br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i - <span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-comment">// insert the new element  </span><br>    <span class="hljs-built_in">list</span>-&gt;list_data[index] = data;  <br>    <span class="hljs-built_in">list</span>-&gt;length++;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// delete an element from the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_delete</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;  <br>    <span class="hljs-keyword">if</span>(index &lt;<span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// shift the elements to the left  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index; i&lt;<span class="hljs-built_in">list</span>-&gt;length; i--)&#123;  <br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i+<span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> --<span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_get_index</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, Data data)</span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;length; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(data.age == <span class="hljs-built_in">list</span>-&gt;list_data[i].age &amp;&amp; <span class="hljs-built_in">strcmp</span>(data.name, <span class="hljs-built_in">list</span>-&gt;list_data[i].name) == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">return</span> i;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>  <br>Data* <span class="hljs-title function_">set_get_element</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-built_in">list</span>-&gt;list_data[index];  <br>&#125;  <br>  <br><span class="hljs-comment">// print the element in the list  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_print_element</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;name);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;age);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;length - <span class="hljs-number">1</span>);  <br>&#125;  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//SEQUENTIAL_LIST_H</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C-example</tag>
      
      <tag>Data-Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java小实验-多态的应用</title>
    <link href="/2023/11/14/Java/java-example-1/"/>
    <url>/2023/11/14/Java/java-example-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Java小实验-多态的应用"><a href="#Java小实验-多态的应用" class="headerlink" title="Java小实验-多态的应用"></a>Java小实验-多态的应用</h1><h2 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h2><p>通过包的创建，类的继承在程序中的具体应用，进一步掌握多态的特点、技巧及使用等。同时熟练使用Java异常处理机制，处理程序中可能出现的异常。</p><h2 id="二、实验环境及要求"><a href="#二、实验环境及要求" class="headerlink" title="二、实验环境及要求"></a>二、实验环境及要求</h2><p>Jdk1.8以上的开发环境，可使用任何编辑器。</p><h2 id="三、实验内容及相应程序"><a href="#三、实验内容及相应程序" class="headerlink" title="三、实验内容及相应程序"></a>三、实验内容及相应程序</h2><ol><li>设计一个圆类Circle，该类存在于mycircle包中，它具有以下的属性和方法：<br>私有属性：圆半径r，圆心坐标x和y，<br>方法：设置和获取所有私有属性r,x,y的方法，方法名自定；计算圆周长的方法perimeter()；计算圆面积的方法area(),<br>要求直接使用Math类中的PI；</li><li>设计一个圆柱体类Cylinder，该类存在于mycylinder包中，Cylinder继承Circle，它增加了以下属性和方法：<br> 私有属性：高度h，<br> 方法：设置和获取私有属性h的方法，方法名自定；计算表面积的方法area()；计算体积的方法volume()；</li><li>编写一个Java Application程序Compute.java，用来显示某一个圆柱体中心坐标位置(如图1中的k的位置)，高度h，以及它的表面积（不包括两个底的面积）、体积和底面积。要求圆半径r，圆心坐标x和y，以及高度h的值均从命令行输入。<br> <strong>提示及注意：</strong><br> 圆柱体的体积&#x3D;底面积<em>高；<br> 圆柱体的表面积&#x3D;底面周长</em>高；<br> 每一个圆柱体的生成，都是在原有的圆的基础上，添加高度生成的。</li><li>编写测试类Computer.java程序，该类能够处理程序中可能出现的所有的异常 ，并有相应的提示信息。如命令行没有输入，则程序会向控制台输出“命令行没有输入，请输入正确的数值”这样的提示信息；</li></ol><h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>MyCircle.Circle.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> MyCircle;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> r;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">this</span>.y = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">this</span>.r = <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = x;  <br>        <span class="hljs-built_in">this</span>.y = y;  <br>        <span class="hljs-built_in">this</span>.r = CheckRadiusFormat(r);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = x;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.y = y;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetR</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.r = CheckRadiusFormat(r);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetX</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> x;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetY</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> y;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetR</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> r;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Perimeter</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> Math.PI * <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">this</span>.r;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Area</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> Math.PI * Math.pow(r, <span class="hljs-number">2</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">CheckRadiusFormat</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;半径不能小于0&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> r;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyCylinder.Cylinder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> MyCylinder;  <br>  <br><span class="hljs-keyword">import</span> MyCircle.Circle;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Circle</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> h;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cylinder</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cylinder</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> r, <span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(x, y, r);  <br>        <span class="hljs-built_in">this</span>.h = CheckHeightFormat(h);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Double <span class="hljs-title function_">GetH</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Cylinder <span class="hljs-title function_">SetHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.h = CheckHeightFormat(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Area</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area() * <span class="hljs-number">2</span> + <span class="hljs-built_in">super</span>.GetR() * <span class="hljs-number">2</span> * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">SurfaceArea</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.GetR() * <span class="hljs-number">2</span> * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Volume</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area() * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">BottomArea</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> Double <span class="hljs-title function_">CheckHeightFormat</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;高度不能为0&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> h;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Compute.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> MyCylinder.Cylinder;  <br>  <br><span class="hljs-comment">///程序入口类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compute</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">vecArgs</span> <span class="hljs-operator">=</span> Computer.CheckArgs(args);  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">cylinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cylinder</span>(vecArgs.get(<span class="hljs-number">0</span>),vecArgs.get(<span class="hljs-number">1</span>),vecArgs.get(<span class="hljs-number">2</span>),vecArgs.get(<span class="hljs-number">3</span>));  <br>        System.out.printf(<span class="hljs-string">&quot;%s,高度为%f\n&quot;</span>, FormatCoordinate(cylinder), cylinder.GetH());  <br>        System.out.println(<span class="hljs-string">&quot;表面积是：&quot;</span> + cylinder.SurfaceArea());  <br>        System.out.println(<span class="hljs-string">&quot;体积是：&quot;</span> + cylinder.Volume());  <br>        System.out.println(<span class="hljs-string">&quot;底面积是：&quot;</span> + cylinder.BottomArea());  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">FormatCoordinate</span><span class="hljs-params">(Cylinder cylinder)</span>&#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cylinder.GetX();  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cylinder.GetY();  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cylinder.GetR();  <br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;(%f,%f,%f)&quot;</span>, x,y,r);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Computer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Vector;  <br>  <br><span class="hljs-comment">///测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; <span class="hljs-title function_">CheckArgs</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        <span class="hljs-keyword">if</span>(args.length == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;命令行没有输入，请输入正确的数值&quot;</span>);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">4</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;太少的参数，需要至少四个&quot;</span>);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">4</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;太多的参数，需要至多四个&quot;</span>);  <br>        &#125;  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">vec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Integer&gt;();  <br>  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">for</span>(String element : args)&#123;  <br>                vec.add(Integer.parseInt(element));  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">return</span> vec;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><strong>输入参数 5 6 3 7</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">(5.000000,6.000000,3.000000),高度为7.000000<br>表面积是：42.0<br>体积是：197.92033717615698<br>底面积是：28.274333882308138<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell类型类</title>
    <link href="/2023/11/14/Haskell/haskell-typeclas/"/>
    <url>/2023/11/14/Haskell/haskell-typeclas/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell的类型类"><a href="#Haskell的类型类" class="headerlink" title="Haskell的类型类"></a>Haskell的类型类</h1><p>类型类(<code>typeclass</code>)是定义行为的接口。类似于其他语言中的<code>interface</code>，比如C++的抽象接口类。如果一个类型是某类型类的实例(instance)，那么他必须实现该类型定义的行为。<strong>千万不要将Haskell的类型类与面向对象语言中的类Class搞混淆</strong></p><p>假设定义类一个类型类（接口）名字叫做吃饭，然后又定义了鸟、人、鱼作为吃饭类型类的实例，那么鸟、人、鱼类就需要实现怎么吃饭这个行为。如果用C++的语言表达，可能是需要创建一个类，在里面声明了一个抽象函数(<code>virtual void eat() = 0</code>), 其他的类继承了这个类，那么必须要实现它。<br><em><strong>不过个人觉得，这个思想的方法，Rust中的trait似乎更贴切一点。</strong></em></p><p>使用<code>:t (==)</code> 查看 &#x3D;&#x3D; 在Haskell中的函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t (==)<br>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool<br><br>ghci&gt; :t (+)<br>(+) :: Num a =&gt; a -&gt; a -&gt; a<br></code></pre></td></tr></table></figure><p>这里出现了一个新的符号 &#x3D;&gt; (实际在上篇文章中使用到了)，它的左侧叫做类型约束，这里的 &#x3D;&#x3D; 和 + 分别约束了使用 Eq和Num两个类。</p><h2 id="Eq-类型类"><a href="#Eq-类型类" class="headerlink" title="Eq 类型类"></a>Eq 类型类</h2><p>用于判断相等性的类型，Eq类定义了等式(&#x3D;&#x3D;)和不等式(&#x2F;&#x3D;)。由Prelude导出的所有基本数据类型都是Eq的实例，并且Eq可以为其成分也是Eq实例的任何数据类型派生。 Haskell官方没有定义Eq一定要实现什么。 然而，&#x3D;&#x3D;通常期望实现等价关系，其中两个比较相等的值通过“公共”函数无法区分，“公共”函数是不允许查看实现细节的函数。 例如，对于表示非规范化自然数模100的类型，“公共”函数不会在1和201之间产生差异。</p><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell">(==) | (/=)<br></code></pre></td></tr></table></figure><h2 id="Ord-类型类"><a href="#Ord-类型类" class="headerlink" title="Ord 类型类"></a>Ord 类型类</h2><p>Ord 类用于可比较大小的类型。 Ord的实例可以为任何组成类型为Ord的用户定义数据类型派生。数据声明中构造函数的声明顺序决定派生Ord实例的顺序。Ordering数据类型允许一次比较来确定两个对象的精确排序。<br>和Eq类似，取两个参数，返回一个Bool类型的值，用来表示是否满足对应的比较关系</p><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">compare</span> | (&lt;=)<br></code></pre></td></tr></table></figure><h2 id="Show-类型类"><a href="#Show-类型类" class="headerlink" title="Show 类型类"></a>Show 类型类</h2><p>将值转换为可读字符串。</p><p>Show的派生实例具有以下属性，它们与Read的派生实例兼容:</p><ul><li>show的结果是一个语法正确的Haskell表达式，只包含常量，只要在声明类型时有效地声明了固定性。它只包含在数据类型、括号和空格中定义的构造函数名称。当使用带标签的构造函数字段时，还会使用大括号、逗号、字段名和等号。</li><li>如果构造函数被定义为中缀操作符，那么showsPrec将生成构造函数的中缀应用。</li><li>如果x中的顶级构造函数的优先级小于d(忽略结合性)，则表示将被括在括号中。因此，如果d为0，则结果永远不会被括号包围;如果d是11，则它总是用圆括号括起来，除非它是原子表达式。</li><li>如果构造函数是使用记录语法定义的，那么show将生成记录语法表单，其中字段的顺序与原始声明的顺序相同。</li></ul><p>除函数以外的所有类型都是SHow的实例，可以使用show函数将值转换为字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; <span class="hljs-built_in">read</span> 3<br><span class="hljs-string">&quot;3&quot;</span><br><br>ghci&gt; <span class="hljs-built_in">read</span> 5.334<br><span class="hljs-string">&quot;5.334&quot;</span><br><br>ghci&gt; <span class="hljs-built_in">read</span> True<br><span class="hljs-string">&quot;True&quot;</span><br></code></pre></td></tr></table></figure><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">showsPrec</span> | show<br></code></pre></td></tr></table></figure><h2 id="Read-类型类"><a href="#Read-类型类" class="headerlink" title="Read 类型类"></a>Read 类型类</h2><p>解析字符串，生成值。</p><p>Read的派生实例做出以下假设，这些假设派生了Show obey的实例:</p><ul><li>如果构造函数被定义为中缀操作符，那么派生的Read实例将只解析构造函数的中缀应用程序(而不是前缀形式)。</li><li>结合性不用于减少括号的出现，尽管可以使用优先级。</li><li>如果构造函数是使用记录语法定义的，则派生的Read将只解析记录语法形式，而且，字段必须按照与原始声明相同的顺序给出。</li><li>派生的Read实例允许在输入字符串的令牌之间使用任意的Haskell空白。还允许使用额外的括号。</li></ul><p>Read可以看做Show相反的类型类，之前提到的所有类都是Read类型，read函数可以去一个字符串作为参数并转为Read的某个实例的类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci &gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;True&quot;</span> || False<br>True<br><br>ghci &gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;8.2&quot;</span> + 3.8<br>12.0<br></code></pre></td></tr></table></figure><p>如果尝试使用<code>read &quot;4&quot;</code>来得到生成一个数字4的效果，那么这是不可能的，会得到一个大大的报错。因为GHCI并不能准确知道到底要个什么玩意来满足屏幕面前的你<br>所以如果在没有一个表达式的情况下，或者说最好给read转换增加一个显示的类型注解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; <span class="hljs-string">&quot;5&quot;</span> :: Int<br>5<br><br>ghci&gt; <span class="hljs-string">&quot;5&quot;</span> :: Float<br>5.0<br></code></pre></td></tr></table></figure><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">readsPrec</span> | readPrec<br></code></pre></td></tr></table></figure><h2 id="Enum-类型类"><a href="#Enum-类型类" class="headerlink" title="Enum 类型类"></a>Enum 类型类</h2><p>Enum的实例对象都是可连续的（枚举），每一个值都有相应的后继和前驱，分别可以通过<code>succ</code>和<code>pred</code>得到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;e&#x27;</span>]<br><span class="hljs-string">&quot;abcde&quot;</span><br><br>ghci&gt; succ <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-string">&#x27;C&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Bounded-类型类"><a href="#Bounded-类型类" class="headerlink" title="Bounded 类型类"></a>Bounded 类型类</h2><p>类型存在一个上限和下限，分别可以通过maxBound和minBound两个函数获得</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; minBound ::Int<br>-9223372036854775808<br><br>ghci&gt; maxBound ::Char<br><span class="hljs-string">&#x27;\1114111&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Num-类型类"><a href="#Num-类型类" class="headerlink" title="Num 类型类"></a>Num 类型类</h2><p>表示一个数值的类型类，它的实例都具有数的特征。<br>只有具有Show和Eq的实例类型，才可以成为Num类型类的实例</p><h2 id="Floating-类型类"><a href="#Floating-类型类" class="headerlink" title="Floating 类型类"></a>Floating 类型类</h2><p>包含Float和Double两种浮点类型，用于存储浮点数。<br>使用Floating类型类的实例类型作为参数或者返回类型的函数，一般需要用到浮点数进行某种计算</p><h2 id="Integral-类型类"><a href="#Integral-类型类" class="headerlink" title="Integral 类型类"></a>Integral 类型类</h2><p>另一种表示数值的类型类。Num类型类包含了实数和整数相关的所有类型，Integral只包含了整数。</p><p>详细的对于类型类的介绍可以参考以下官方文档链接：<br><a href="https://hackage.haskell.org/package/ghc-prim-0.7.0/docs/GHC-Classes.html">https://hackage.haskell.org/package/ghc-prim-0.7.0/docs/GHC-Classes.html</a><br><a href="https://hackage.haskell.org/package/base-4.15.1.0/docs/GHC-Show.html#t:Show">https://hackage.haskell.org/package/base-4.15.1.0/docs/GHC-Show.html#t:Show</a><br><a href="https://hackage.haskell.org/package/base-4.15.1.0/docs/Text-Read.html#v:Read">https://hackage.haskell.org/package/base-4.15.1.0/docs/Text-Read.html#v:Read</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell中的类型</title>
    <link href="/2023/11/13/Haskell/haskell-type/"/>
    <url>/2023/11/13/Haskell/haskell-type/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell中的类型"><a href="#Haskell中的类型" class="headerlink" title="Haskell中的类型"></a>Haskell中的类型</h1><p>在Haskell中，每个表达式都会在编译时得到明确的类型，从而提高代码的安全性。当然这样就会导致在输入不同的类型进行某些操作时候得到编译捕获错误<br>这自然好过在运行时出现崩溃，然后自己去逐个排查是什么问题。<strong>Haskell中一切皆有类型，因此编译器在编译期间可以得到更多的消息来检查错误</strong></p><p>在<code>ghci</code>中可以使用<code>:t</code>命令，后接任何合法表达式查阅其类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-string">&#x27;a&#x27;</span> :: Char<br><br>ghci&gt; :t <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-string">&quot;a&quot;</span> :: String<br><br>ghci&gt; :t True<br>True :: Bool<br><br>ghci&gt; :t <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-string">&quot;Hello&quot;</span> :: String<br><br>ghci&gt; :t (True,<span class="hljs-string">&#x27;a&#x27;</span>)<br>(True,<span class="hljs-string">&#x27;a&#x27;</span>) :: (Bool, Char)<br><br>ghci&gt; :t 123<br>123 :: Num p =&gt; p<br><br>ghci&gt; :t 5 == 3<br>5 == 3 :: Bool<br></code></pre></td></tr></table></figure><hr><p><strong>有一个好习惯是在编写函数时，显示写出函数的类型</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">removeNonUpperCase</span> :: [<span class="hljs-type">Char</span>] -&gt; [<span class="hljs-type">Char</span>]<br><span class="hljs-title">removeNonUpperCase</span> st = [ c | c &lt;- st, c `elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]]<br><br><span class="hljs-title">addThree</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">addThree</span> x y z = x + y + z<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Trust type&quot;</span><br>    print (removeNonUpperCase <span class="hljs-string">&quot;abcDEF&quot;</span>)<br>    print (addThree <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>在这里 :: 读作“它的类型为”，凡是确定的类型，首字母一定是大写的。在这里<code>removeNonUpperCase</code>的类型是<code>[Char] -&gt; [Char]</code>。<br>也就是说接受一个<code>[char]</code>类型作为输入参数，返回一个<code>[char]</code>类型作为输出。在《Haskell趣学指南》中，可能是因为年代原因还有版本原因，字符串输出的<br>结果是<code>[char]</code>而在本人目前这个版本(GHCI 9.0.2) 字符串的类型已经是 <code>String</code>了</p><blockquote><p>String :: *</p><p>Defined in ‘GHC.Base’ (base-4.15.1.0)</p><p>A String is a list of characters. String constants in Haskell are values of type String .</p><p>See Data.List for operations on lists.*</p></blockquote><h2 id="Haskell中常见的类型"><a href="#Haskell中常见的类型" class="headerlink" title="Haskell中常见的类型"></a>Haskell中常见的类型</h2><p>常见的基本类型用于表示数，字符，布尔值的类型</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul><li>Int: 整数类型， Int是有界的也可以称作是有符号类型，它的上下限取决于CPU。假设是64位的CPU，它的范围就是 -2^(64-1) ~ 2^(64-1)-1</li><li>Integer: 无符号整数类型， 可以存非常非常大的一个正整数，但是效率不如Int (详见计算机编码的内容)</li><li>Float: 单精度浮点类型</li><li>Double: 双精度浮点类型。精度是Float的两倍，这也意味着占用更大的空间。</li></ul><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ul><li>Char: 表示一个Unicode字符，一个字符由单引号括起</li><li>[Char]: 字符列表，可以当作字符串使用</li><li>String: 字符串类型</li></ul><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型:"></a>布尔类型:</h3><ul><li>Bool: 布尔类型，True和False</li></ul><hr><h2 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h2><p>有一些函数可能需要处理多个类型，或者说多个类型都需要用这个函数进行处理。如果用函数式编程的思想考虑，那么说一个函数的功能可以处理多个类型的参数，这<br>更为贴切一点。比如 head, tail, min, max他们都可以处理多种类型。好奇心一下子就上来了，那么这些函数的类型是什么呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t <span class="hljs-built_in">head</span><br><span class="hljs-built_in">head</span> :: [a] -&gt; a<br><br>ghci&gt; :t min<br>min :: Ord a =&gt; a -&gt; a -&gt; a<br><br>ghci&gt; :t <span class="hljs-built_in">tail</span><br><span class="hljs-built_in">tail</span> :: [a] -&gt; [a]<br></code></pre></td></tr></table></figure><p>我们知道大写开头的才是一个类型，那么这个必不是一个类型，这其实是个类型变量(type variable)，也就会a可以是任何一个类型。作为一个C++老玩家，<br>这一刻觉得这个东西是真得强大，在类型安全的情况下可以简单实现处理多种类型的函数，容易写出通用的函数。</p><p><em>使用了类型变量的函数被称作多态函数(polymorphic function)</em> 我们可以写一个简单的针对于数字的加法函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">plusTwoNumber</span> :: <span class="hljs-type">Num</span> a =&gt; a -&gt; a -&gt; a<br><span class="hljs-title">plusTwoNumber</span> x y = x + y<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (plusTwoNumber <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>这里和C++的template模板以及auto比较一下（我个人还是非常喜欢C++的，现在新版的类型推导也是很好用，模板就有点小麻烦了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//类型推导方式</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//模板方式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Number = std::is_integral_v&lt;T&gt; || std::is_abstract_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;Number T&gt;<br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 元组</title>
    <link href="/2023/11/12/Haskell/haskell-tuple/"/>
    <url>/2023/11/12/Haskell/haskell-tuple/</url>
    
    <content type="html"><![CDATA[<h1 id="简单玩一下元组"><a href="#简单玩一下元组" class="headerlink" title="简单玩一下元组"></a>简单玩一下元组</h1><p>有意思的是Haskell中的元组，不仅如同Python中一样可以随便放东西，而且可以当作结构体用<br>如果元组有里面只有两个元素，就可以当作键值对用，真不错啊真不错~</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">numberAndNumber</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br><span class="hljs-title">triples</span> = [(a,b,c) | a &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], b &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br><span class="hljs-title">rightTriangles</span> = [(a,b,c) | c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], a &lt;- [<span class="hljs-number">1</span>..c], b &lt;- [<span class="hljs-number">1</span>..a], a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> == c^<span class="hljs-number">2</span>]<br><span class="hljs-title">someItem</span> = (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;HelloWorld&quot;</span>, <span class="hljs-type">True</span>)<br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Hello, tuple!&quot;</span><br>    print numberAndNumber<br>    print someItem<br>    <span class="hljs-comment">--对于序队可使用</span><br>    print (fst numberAndNumber)<br>    print (snd numberAndNumber)<br><br>    <span class="hljs-comment">--创建序对</span><br>    print (zip [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], odd x] [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>])<br>    print (zip [<span class="hljs-number">1</span>..] [<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;Java&quot;</span>])<br><br>    <span class="hljs-comment">-- 打印0~10之类边长的三角形</span><br>    print rightTriangles<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅学一下Haskell中的列表</title>
    <link href="/2023/11/11/Haskell/haskell-list/"/>
    <url>/2023/11/11/Haskell/haskell-list/</url>
    
    <content type="html"><![CDATA[<h1 id="浅学一下Haskell中的列表"><a href="#浅学一下Haskell中的列表" class="headerlink" title="浅学一下Haskell中的列表"></a>浅学一下Haskell中的列表</h1><blockquote><p>在 Haskell 中，List 就像现实世界中的购物单一样重要。它是最常用的资料结构，并且十分强大，灵活地使用它可以解决很多问题。<br>Haskell中的列表是一种用来存储相同类型的元素的数据结构。列表可以用方括号和逗号来构造，例如[1, 2, 3]是一个包含三个整数的列表。<br>列表也可以用冒号操作符来构造，冒号操作符可以将一个元素添加到一个已有的列表的开头，例如1:[2, 3]等价于[1, 2, 3]。<br>列表还可以用范围来构造，<br>例如[1…10]是一个包含1到10的自然数的列表。列表的长度可以用length函数来计算，列表的元素可以用索引来访问，<br>例如[1, 2, 3] !! 0返回1，[1, 2, 3] !! 1返回2，以此类推。列表还有很多其他的操作，例如拼接，反转，排序，过滤，映射，折叠等。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">odd_numbers</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]<br><span class="hljs-title">even_numbers</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><span class="hljs-title">number_list</span> = [odd_numbers, even_numbers]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (odd_numbers ++ even_numbers) <span class="hljs-comment">--拼接两个列表</span><br>    print (<span class="hljs-string">&quot;Hello&quot;</span> ++ <span class="hljs-string">&quot; &quot;</span> ++ <span class="hljs-string">&quot;world!&quot;</span>) <span class="hljs-comment">--拼接两个字符串</span><br>    print ([<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>] ++ [<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>])<br>    print (number_list)<br>    <br>    <span class="hljs-comment">-- 不可以这样拼接，这是一个列表和一个数字</span><br>    <span class="hljs-comment">-- [1,2,3,4,5] ++ [5]    </span><br><br>    print ( <span class="hljs-number">0</span> : odd_numbers)<br>    print (even_numbers !! <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment">-- 比较列表（会从第一个元素开始比较， 如果相等则比较第二个，直到不同为止）</span><br>    putStrLn <span class="hljs-string">&quot;比较列表&quot;</span><br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &lt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] == [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br><br>    <span class="hljs-comment">-- 更多的列表操作</span><br>    putStrLn <span class="hljs-string">&quot;更多的列表操作&quot;</span><br>    print (head odd_numbers)<br>    print (init odd_numbers)<br>    print (last odd_numbers)<br>    print (tail even_numbers)<br>    <span class="hljs-comment">-- head [] 无法提取空列表</span><br>    print (length odd_numbers)<br>    print (null odd_numbers)<br>    print (reverse odd_numbers)<br>    print (take <span class="hljs-number">3</span> odd_numbers)<br>    print (drop <span class="hljs-number">0</span> odd_numbers)<br>    print (maximum odd_numbers)<br>    print (minimum even_numbers)<br>    print (sum odd_numbers)<br>    print (product odd_numbers)<br>    print (elem <span class="hljs-number">3</span> odd_numbers)<br>    print (elem <span class="hljs-number">3</span> even_numbers)<br><br>    <span class="hljs-comment">-- 列表区间</span><br>    putStrLn <span class="hljs-string">&quot;列表区间&quot;</span><br>    print [<span class="hljs-number">1</span>..<span class="hljs-number">20</span>]<br>    print [<span class="hljs-string">&#x27;a&#x27;</span> .. <span class="hljs-string">&#x27;z&#x27;</span>]<br>    print [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..<span class="hljs-number">20</span>]<br>    print (take <span class="hljs-number">10</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..])<br>    print (take <span class="hljs-number">10</span> (cycle [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br>    print (take <span class="hljs-number">10</span> (repeat <span class="hljs-number">2</span>))<br>    print (replicate <span class="hljs-number">3</span> <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">-- 列表推导式</span><br>    putStrLn <span class="hljs-string">&quot;列表推导式&quot;</span><br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], x*<span class="hljs-number">10</span> &lt;= <span class="hljs-number">50</span>, even x]<br>    <span class="hljs-comment">-- 取1～100中可以被3整出的数</span><br>    print [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>], x `mod` <span class="hljs-number">3</span> == <span class="hljs-number">0</span>]<br>    <span class="hljs-comment">-- 根据number_list中的数，返回是odd还是even</span><br>    print ([ <span class="hljs-keyword">if</span> ((x `mod` <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> ) <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;even&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;odd&quot;</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]])<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs bash">[2,4,6,8,10,1,3,5,7,9]<br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br>[[2,4,6,8,10],[1,3,5,7,9]]<br><br>[0,2,4,6,8,10]<br><br>7<br><br>比较列表<br><br>True<br><br>True<br><br>True<br><br>True<br><br>True<br><br>更多的列表操作<br><br>2<br><br>[2,4,6,8]<br><br>10<br><br>[3,5,7,9]<br><br>5<br><br>False<br><br>[10,8,6,4,2]<br><br>[2,4,6]<br><br>[2,4,6,8,10]<br><br>10<br><br>1<br><br>30<br><br>3840<br><br>False<br><br>True<br><br>列表区间<br><br>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]<br><br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[1,2,3,1,2,3,1,2,3,1]<br><br>[2,2,2,2,2,2,2,2,2,2]<br><br>[10,10,10]<br><br>列表推导式<br><br>[10,20,30,40,50,60,70,80,90,100]<br><br>[20,40]<br><br>[3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99]<br><br>[<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好呀 Haskell</title>
    <link href="/2023/11/10/Haskell/hello-haskell/"/>
    <url>/2023/11/10/Haskell/hello-haskell/</url>
    
    <content type="html"><![CDATA[<h1 id="你好呀Haskell"><a href="#你好呀Haskell" class="headerlink" title="你好呀Haskell"></a>你好呀Haskell</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>开始玩耍一个新的编程语言:Haskell, 其实很早就准备学习这个语言，而且也在官网上看了一小段教程，但是有一种云里雾里的感觉，不是没有学懂他的语法，而是还没有理解他的思想，所以一直拖到现在。</p><p>直到在上了大学物理这门课程。感谢岳老师的物理课，虽然我的物理学的并不好，但是对于看待事务本身多了一个新的角度。</p><p>对于之前学习C++,C#, Java…还有别的语言，在解决问题方面更像是在解释这个问题应该怎么做。即使是说使用了面向对象、多态、继承、封装、抽象、接口、泛型、多线程、异常等等，但依然更像是描述这个问题应该怎么做，所以这类语言也成为命令式语言。在命令式语言中执行操作需要给电脑安排一组指令, 随着命令的执行，状态会随之发生改变。</p><p>然而在纯函数式编程语言中，不再是像命令式语言那样描述要做什么，而是通过函数描述问题“是什么”。</p><p>有一个简单的例子说， 在函数式编程语言中，变量一旦赋值，就不能改了，比如  <code>x = 5</code> 这里已规定好了，x的值是5，那么在函数式编程语言中，变量x的值就是5，不能被改变。</p><h2 id="简单的运算"><a href="#简单的运算" class="headerlink" title="简单的运算"></a>简单的运算</h2><blockquote><p><strong>simple-calc.hs</strong></p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">plus</span> x y = x + y<br><span class="hljs-title">substract</span> x y = x - y<br><span class="hljs-title">multiply</span> x y = x * y<br><span class="hljs-title">divide</span> x y = x / y<br><br><span class="hljs-title">and_gate</span> x y = x &amp;&amp; y<br><span class="hljs-title">or_gate</span> x y = x || y<br><span class="hljs-title">not_gate</span> x = not x<br><br><span class="hljs-title">is_equal</span> x y = x == y<br><span class="hljs-title">is_bigger</span> x y = x &gt; y<br><span class="hljs-title">is_smaller</span> x y = x &lt; y<br><span class="hljs-title">is_odd</span> x = mod x <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-title">double_value</span> x = x * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>测试运行</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ghci simple-calc.hs<br><span class="hljs-comment">#GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help</span><br><span class="hljs-comment">#[1 of 1] Compiling Main             ( simple-calc.hs, interpreted )</span><br><span class="hljs-comment">#Ok, one module loaded.</span><br><br>ghci&gt; plus 2 4<br>6<br>ghci&gt; or_gate True False<br>True<br>ghci&gt; double_value 5<br>10<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>小小解释</strong></p></blockquote><p>定义函数: functionName args &#x3D; expression</p><p>执行函数: functionName args </p><p>如果一个函数有两个参数，也可以用这样的方法调用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-number">4</span> `mod` <span class="hljs-number">2</span><br><span class="hljs-title">mod</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> #两者相当<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视C++为一个语言联邦</title>
    <link href="/2023/11/09/Cpp/view-cpp-as-a-federation/"/>
    <url>/2023/11/09/Cpp/view-cpp-as-a-federation/</url>
    
    <content type="html"><![CDATA[<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><p><small>View C++ as a federation of languages</small></p><blockquote><p>一开始，C++只是C加上一些面向对象特性。 C++ 最初的名称 C with Classes 也反应来这个血缘关系 (Effective C++)</p></blockquote><hr><p>随着C++的不断发展，C++的特性越来越多，甚至有些特性是C++独有的。 学了有一段时间的C++， 向他人请教过C++的技巧，也教过人怎么学习C++。 语法以及技巧不是很难去教授的，但是有一段时间令我头疼的是，如何对新手做一个C++的介绍。 因为C++的特性太多， 而且C++的特性之间又存在一定的联系， 导致很难对一个新手进行一个系统的学习。</p><p>直到有一天我再次翻开《Effective C++ 改善程序的55个做法》， 而条款01就是”视C++为一个语言联邦“<br>可以说，C++其实是一个联邦， 联邦由若干个语言组成， 每个语言都具有自己的特性， 这些特性又相互关联。今天的C++是个多重范式的编程语言， 它同时具有面向过程、面向对象、泛型编程、模板、异常处理、标准库、标准模板库等特性。</p><h2 id="语言联邦"><a href="#语言联邦" class="headerlink" title="语言联邦"></a>语言联邦</h2><blockquote><ol><li>Base C language</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ol></blockquote><h3 id="Base-C-language"><a href="#Base-C-language" class="headerlink" title="Base C language"></a>Base C language</h3><p>说到底，C++可以理解是一个C语言的超集， 它包含了C语言的所有特性， 并且还增加了面向对象、泛型编程、异常处理、标准库、标准。许多时候一个问题的C++解法， 往往可以由C语言的解法推导而来，也可以说是较为高级、较为抽象的C语言的解法。</p><h3 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h3><p>C++语言是面向对象的， 它包含了一些面向对象的特性， 例如： 类、对象、继承、多态、虚函数。<br>这部分也就是C with classes所诉求的， 它也被称为OO C++： classes, inheritance, and polymorphism.</p><h3 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h3><p>C++的模板特性， 使得C++可以进行泛型编程， 它使得C++可以进行泛型编程。不严谨的说，模板能够批量生成大量功能相似，但是有些许不同的代码。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL是C++标准模板库， 它提供了一组通用的、可复用的算法和数据结构， 例如： 容器、迭代器、算法、函数对象、适配器、分配器、流、字符串、数值等。然而STL有自己独特的办事方式，当你同STL一同工作，你必须遵守他的约定。</p><p>在编程时候， 这些语言联邦中的特性相互之间是相互独立的， 它们之间可以相互组合， 也可以相互分离。 例如，你可以只使用C语言特性完成某些事情，或者在一个类中自己封装一个STL容器， 或者使用STL容器完成一些C++特性。</p><blockquote><p>当你从某个次语言切换到另一个时，导致高效编程守则编程守则要求你改变策略时，不要感到惊讶。因此说C++并不是一个一组带有一组守则一体的语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。<br><strong>C++高效编程守则视状况而变化，取决于你使用C++的哪一个部分</strong></p></blockquote><h2 id="学习C-的流程"><a href="#学习C-的流程" class="headerlink" title="学习C++的流程"></a>学习C++的流程</h2><p>所以说，学习C++本体或许并不一定要掌握C语言，“不必是一个火箭科学家”， 只需要掌握C++的特性， 就可以写出一些有趣的代码。<br>之后在针对C++的特性进行学习， 例如： 模板、STL、异常处理等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>来做一个猜数游戏吧</title>
    <link href="/2023/11/09/Cpp/guessing-number/"/>
    <url>/2023/11/09/Cpp/guessing-number/</url>
    
    <content type="html"><![CDATA[<h1 id="一个猜数小游戏"><a href="#一个猜数小游戏" class="headerlink" title="一个猜数小游戏"></a>一个猜数小游戏</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>首先尝试接受用户的一个输入数字</li><li>生成一个随机数</li><li>进入游戏循环主体中<ol><li>输入数字大于随机数：输出大了，循环继续</li><li>输入数字小于随机数：输入小了，循环继续</li><li>输入数字等于随机数：猜对了，退出循环</li></ol></li><li>结束程序</li></ol><h2 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// Create random number generator</span><br>    std::random_device random_device;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">generator</span><span class="hljs-params">(random_device())</span></span>;<br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distribution</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> random_number = <span class="hljs-built_in">distribution</span>(generator);<br>    std::cout &lt;&lt; random_number &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// Create variable to store user&#x27;s guess</span><br>    <span class="hljs-type">int</span> guessing_number&#123;&#125;;<br><br>    <span class="hljs-comment">// Create loop to allow user to guess the random number</span><br>    <span class="hljs-keyword">while</span>(guessing_number != random_number)&#123;<br>        std::cin &gt;&gt; guessing_number;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Guessing number: &quot;</span> &lt;&lt; guessing_number &lt;&lt; std::endl;<br>        <span class="hljs-keyword">if</span>(guessing_number &gt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too high&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guessing_number &lt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too low&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;You got it!&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="随机数引擎"><a href="#随机数引擎" class="headerlink" title="随机数引擎"></a>随机数引擎</h3><p><strong>要在C++中使用<random>库生成一个随机数，请按照以下步骤操作：</strong></p><ol><li><p>首先，确保已经包含了<code>&lt;random&gt;</code>头文件。在文件的开头添加以下代码：<code>#include &lt;random&gt;</code></p></li><li><p>接下来，创建一个<code>std::random_device</code>对象，用于生成随机种子。这可以确保每次运行程序时生成的随机数不同。<br><code>std::random_device rd;</code></p></li><li><p>使用<code>std::seed</code>函数，将random_device对象生成的随机种子用于初始化std::mt19937随机数生成器。<br><code>std::mt19937 gen(rd());</code></p></li><li><p>使用<code>std::uniform_int_distribution</code>对象，指定随机数的范围。例如，要生成0到100之间的随机数，可以使用以下代码：<br><code>std::uniform_int_distribution&lt;&gt; distrib(0, 100);</code></p></li><li><p>使用distrib对象生成随机数，并将其存储在变量中。<br><code>const auto random_number = distrib(gen);</code></p></li></ol><p><code>std::mt19937</code>是一个Mersenne Twister伪随机数生成器，它是C++标准库中的一个均匀分布随机数生成器。Mersenne Twister是一种广泛使用的随机数生成器，其性能和分布非常广泛，因此在许多应用中都被广泛使用。</p><p><code>std::mt19937</code>的构造函数接受一个random_device对象作为参数，该对象用于生成随机种子。通过使用random_device，可以确保每次运行程序时生成的随机数不同。</p><p><code>std::mt19937</code>生成的随机数服从均匀分布，即在指定的区间内等概率地取值。</p><h3 id="const-和-auto"><a href="#const-和-auto" class="headerlink" title="const 和 auto"></a>const 和 auto</h3><p>const 关键字用于声明常量，即在程序运行期间其值不能被修改的量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>a = <span class="hljs-number">6</span> <span class="hljs-comment">// 错误，不能修改常量的值</span><br></code></pre></td></tr></table></figure><p>auto 关键字用于声明自动类型变量，即编译器会根据初始值自动推断出变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-comment">//声明一个int类型的a,并且定义值为5</span><br><span class="hljs-keyword">auto</span> b = a; <span class="hljs-comment">// b的类型和a一样，都是int类型</span><br>b = <span class="hljs-number">7</span>;  <span class="hljs-comment">//正确，可以修改b的值</span><br></code></pre></td></tr></table></figure><h3 id="主体判断框架"><a href="#主体判断框架" class="headerlink" title="主体判断框架"></a>主体判断框架</h3><p>使用while循环，在循环体中判断条件是否成立，如果条件成立，则执行循环体，否则退出循环。<br>用户如果输入错误数值，那么就一直循环，直到输入正确为止。<br>用户输入正确，那么就会通过break跳出循环。</p><h3 id="整体解释"><a href="#整体解释" class="headerlink" title="整体解释"></a>整体解释</h3><ol><li>引入所需的头文件，包括<random>（用于随机数生成器）和<iostream>（用于输入输出）。</li><li>在main函数中，定义一个random_device对象，用于生成随机种子。</li><li>定义一个std::mt19937对象，作为随机数生成器，并将random_device对象作为参数传递。</li><li>定义一个std::uniform_int_distribution对象，用于生成1到100之间的随机整数。</li><li>使用distribution对象生成一个随机整数，并将其存储在random_number变量中。</li><li>使用std::cout输出随机数。</li><li>定义一个guessing_number变量，用于存储用户输入的数字。</li><li>使用一个while循环，直到用户猜对数字为止。</li><li>在循环中，使用std::cin从用户输入一个数字，并将其存储在guessing_number变量中。</li><li>使用std::cout输出用户输入的数字。</li><li>如果guessing_number大于random_number，则输出“Too high”。</li><li>如果guessing_number小于random_number，则输出“Too low”。</li><li>如果guessing_number等于random_number，则输出“You got it!”并跳出循环。</li><li>最后，return 0表示程序正常退出。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows上mingw C/C++环境搭建</title>
    <link href="/2022/12/11/Cpp/Tips-mingw/"/>
    <url>/2022/12/11/Cpp/Tips-mingw/</url>
    
    <content type="html"><![CDATA[<h1 id="MSYS2和CMake搭建C-x2F-C-环境-参考指南"><a href="#MSYS2和CMake搭建C-x2F-C-环境-参考指南" class="headerlink" title="MSYS2和CMake搭建C&#x2F;C++环境 参考指南"></a>MSYS2和CMake搭建C&#x2F;C++环境 参考指南</h1><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a><strong>准备材料</strong></h2><ul><li>MSYS2 <a href="https://www.msys2.org/">msys2.org</a></li><li>CMake <a href="https://cmake.org/download/">cmake.org</a></li></ul><hr><h2 id="如何下载"><a href="#如何下载" class="headerlink" title="如何下载"></a>如何下载</h2><p><img src="/img/Tips-mingw/1.png" alt="1.png"></p><center><small>点击即可下载，之后莽点下一步即可安装</small></center><p><img src="/img/Tips-mingw/2.png" alt="2.png"></p><center><small>根据系统架构选择对应的版本下载，之后双击安装即可</small></center><hr><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ol><li>打开安装的MSYS2 MSYS， 更换软件源 (选择任意即可)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tuna mirror 清华软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br><span class="hljs-comment"># ustc mirror 中科大软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.ustc.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br></code></pre></td></tr></table></figure></li></ol><p><img src="/img/Tips-mingw/3.png" alt="3.png"></p><p><img src="/img/Tips-mingw/4.png" alt="4.png"></p><ol start="2"><li>更新一下软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Syyu<br></code></pre></td></tr></table></figure>遇到 :: Proceed with installation? [Y&#x2F;n] 的类似问题时输入y即可</li></ol><p><img src="/img/Tips-mingw/5.png" alt="5.png"></p><ol start="3"><li>安装mingw<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S base-devel <br>pacman -S mingw-w64-x86_64-toolchain<br><br></code></pre></td></tr></table></figure>Enter a selection (default&#x3D;all): 输入回车即可<br><img src="/img/Tips-mingw/6.png" alt="6.png"></li></ol><p><strong>4. 配置系统环境</strong></p><p>找到安装目录的mingw64路径<br><img src="/img/Tips-mingw/7.png" alt="7.png"></p><p>计算机右键属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; path -&gt; 你的路径<br><img src="/img/Tips-mingw/8.png" alt="8.png"><br><img src="/img/Tips-mingw/9.png" alt="9.png"><br><img src="/img/Tips-mingw/10.png" alt="10.png"><br><img src="/img/Tips-mingw/11.png" alt="11.png"></p><h2 id="最后验证"><a href="#最后验证" class="headerlink" title="最后验证"></a>最后验证</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">cmake --version<br>gcc -v<br></code></pre></td></tr></table></figure><p><img src="/img/Tips-mingw/12.png" alt="12.png"></p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>MSYS2 是什么？<br><strong>MSYS2</strong> is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.</p><p>It consists of a command line terminal called <a href="https://mintty.github.io/">mintty</a>, bash, version control systems like git and subversion, tools like tar and awk and even build systems like autotools, all based on a modified version of <a href="https://cygwin.com/">Cygwin</a>. Despite some of these central parts being based on Cygwin, the main focus of MSYS2 is to provide a build environment for native Windows software and the Cygwin-using parts are kept at a minimum. MSYS2 provides up-to-date native builds for GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby, just to name a few.</p><p>To provide easy installation of packages and a way to keep them updated it features a package management system called <a href="https://wiki.archlinux.org/index.php/pacman">Pacman</a>, which should be familiar to Arch Linux users. It brings many powerful features such as dependency resolution and simple complete system upgrades, as well as straight-forward and reproducible package building. Our package repository contains <a href="https://packages.msys2.org/base">more than 2600 pre-built packages</a> ready to install.</p><p>For more details see <a href="https://www.msys2.org/docs/what-is-msys2/">‘What is MSYS2?’</a> which also compares MSYS2 to other software distributions and development environments like <a href="https://cygwin.com/">Cygwin</a>, <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>, <a href="https://chocolatey.org/">Chocolatey</a>, <a href="https://scoop.sh/">Scoop</a>, … and <a href="https://www.msys2.org/docs/who-is-using-msys2/">‘Who Is Using MSYS2?’</a> to see which projects are using MSYS2 and what for.</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">MSYSY2 MSYS</td><td align="left">用来管理和安装包的</td></tr><tr><td align="left">MSYSY2 MinGW 32-bit</td><td align="left">编译32位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MinGW 64-bit</td><td align="left">编译64位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MSYS UCRT 64-bit</td><td align="left">编译64位程序，库链接到ucrt上</td></tr></tbody></table><p>CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/标记和字符集</title>
    <link href="/2022/08/10/Cpp/Tokens%20and%20character%20sets/"/>
    <url>/2022/08/10/Cpp/Tokens%20and%20character%20sets/</url>
    
    <content type="html"><![CDATA[<h1 id="标记和字符集"><a href="#标记和字符集" class="headerlink" title="标记和字符集"></a>标记和字符集</h1><p><small>Tokens and character sets</small></p><p>C++程序文本由Tokens(标记)和空格组成。标记是对编译器有用的 C++ 程序的最小元素。 C++ 分析器可识别以下类型的Token：</p><ul><li>Keywords （关键字）</li><li>Identifiers（标识符）</li><li>Numeric, Boolean and Pointer Literals（数字，布尔值，指针文本）</li><li>String and Character Literals（字符串和字符文本）</li><li>User-Defined Literals（用户定义的文本）</li><li>Operators（运算符&#x2F;操作符）</li><li>Punctuators（标点符号）<blockquote><p><strong>译注：</strong><br>词法分析是编译过程的第一步工作，将字符流转换为单词序列，输出到中间文件中，这个中间文件将会作为语法分析程序的输入，进行下一步工作。<br>token可翻译为标记，是构成源代码的最小单位，从输入字符流中生成标记的过程叫作标记化（ tokenization ），在这个过程中，词法分析器还会对标记进行分类。编译器会从左到右扫描我们的源代码，将其中的字符流分割成一个一个的 token。</p></blockquote></li></ul><h2 id="Token通常用空格进行切分，可以是一个或多个：-空白-水平或垂直制表符-新行-表单源-注释"><a href="#Token通常用空格进行切分，可以是一个或多个：-空白-水平或垂直制表符-新行-表单源-注释" class="headerlink" title="Token通常用空格进行切分，可以是一个或多个：-   空白-   水平或垂直制表符-   新行-   表单源-   注释"></a>Token通常用空格进行切分，可以是一个或多个：<br>-   空白<br>-   水平或垂直制表符<br>-   新行<br>-   表单源<br>-   注释</h2><h2 id="基本源字符集"><a href="#基本源字符集" class="headerlink" title="基本源字符集"></a>基本源字符集</h2><p>C++标准指定了基本源字符集用于源文件中，要表示此集合之外的字符，可以使用通用字符名称指定其他字符。MSVC编译器允许实现其他字符。要表示此集合之外的字符，可以使用通用字符名称指定其他字符。<br><code>a b c d e f g h i j k l m n o p q r s t u v w x y z</code><br><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code><br><code>0 1 2 3 4 5 6 7 8 9</code><br><code>_ &#123; &#125; [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ &quot; &#39;</code></p><p><strong>特用于Microsoft的内容</strong><br>MSVC 包含 $ 字符作为基本源字符集的成员。MSVC 还允许根据文件编码在源文件中使用一组额外的字符。在默认情况下，Visual Studio使用默认代码页存储资源文件。当资源文件使用特定区域或Unicode代码页保存时，MSVC允许你在源代码中使用该代码页的任何字符，但基本源字符集中不允许的控制代码除外。举个例子，您可以通过日文代码页在注释，标识符或字符串中使用日文。MSVC不允许无法转换成为多字节字符和Unicode位码的字符序列。根据编译器选项，并非所有允许的字符都可能出现在标识符中。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a>。</p><blockquote><p><strong>译注</strong><br>在使用visual studio时如果使用WinAPI例如&lt;Windows.h&gt;便可以遇到LPWSTR等字符类型，这是一种宽字符类型也可称作多字节字符。在MSVC中使用L”xxx”即表示用宽字符输出此字符串，也可在项目设置中设置相关配置，设置默认使用宽字符。</p></blockquote><hr><h2 id="通用字符名称"><a href="#通用字符名称" class="headerlink" title="通用字符名称"></a>通用字符名称</h2><p>由于C++程序可以使用比基础字符集更多的字符，您可以使用通用字符名称以可移植的方式指定这些字符。通用字符名称由表示 Unicode 码位的字符序列组成。可以使用两种类型进行表述，使用<code>UNNNNNNNN</code>来代表为 U+NNNNNNNN的unicode位码字符，NNNNNNNN 是八位的十六进制码位数字。使用四位的 <code>\uNNNN</code> 表示形式为 U+0000NNNN 的 Unicode 码位。<br>通用字符名称可用于标识符以及字符串和字符文字。通用字符名称不能被用于表示0xD800-0xDFFF之间之内的代理项码位，编译器会自动生成任何所需的代理项。其他限制适用于可在标识符中使用的通用字符名称。详细信息请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">Identifiers</a> 和 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">String and Character Literals</a>。</p><p><strong>特用于Microsoft的内容</strong><br>Microsoft C++ 编译器可互换地处理通用字符名称形式和文字形式的字符。例如，您可以使用通用字符名称形式声明标识符，并以文字形式使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> \u30AD = <span class="hljs-number">42</span>; <span class="hljs-comment">// \u30AD is &#x27;キ&#x27;</span><br><span class="hljs-keyword">if</span> (キ == <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// \u30AD and キ are the same to the compiler</span><br></code></pre></td></tr></table></figure><p>Windows 剪贴板上的扩展字符的格式特用于应用程序区域设置。 从另一个应用程序剪切这些字符并将其粘贴到你的代码中可能会引入意外的字符编码。 这可能会导致您的代码中出现不知原因的代码错误。我们建议在粘贴扩展的字符之前将源文件编码设置为 Unicode 代码页，以及使用 IME 或字符映射应用生成扩展的字符。</p><hr><h2 id="执行字符集"><a href="#执行字符集" class="headerlink" title="执行字符集"></a>执行字符集</h2><p><em>执行字符集</em> 表示可在编译的程序中显示的字符和字符串。 这些字符集包括源文件中允许的所有字符，以及表示警报、后空、回车符和 null 字符的控制字符。 执行字符集具有特定于区域设置的表示形式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/词法约定</title>
    <link href="/2022/08/10/Cpp/Lexical-conventions/"/>
    <url>/2022/08/10/Cpp/Lexical-conventions/</url>
    
    <content type="html"><![CDATA[<h1 id="词法约定"><a href="#词法约定" class="headerlink" title="词法约定"></a>词法约定</h1><p><small>Lexical conventions</small></p><p>本篇章介绍了C++程序中的基本元素。您会使用到称作“词法元素”或者说“标记”的元素构造完整程序的语句、定义和声明等。 本节将讨论以下词法元素：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/character-sets?view=msvc-170">标记和字符集</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/comments-cpp?view=msvc-170">注释</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/keywords-cpp?view=msvc-170">关键字</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/punctuators-cpp?view=msvc-170">标点符号</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/numeric-boolean-and-pointer-literals-cpp?view=msvc-170">数值、布尔和指针文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">字符串和字符文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/user-defined-literals-cpp?view=msvc-170">用户定义的文本</a></li></ul><p>有关如何分析 C++ 源文件的详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/preprocessor/phases-of-translation?view=msvc-170">转换阶段</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/欢迎回到C++ 现代C++</title>
    <link href="/2022/08/08/Cpp/Welcome%20back%20to%20C++/"/>
    <url>/2022/08/08/Cpp/Welcome%20back%20to%20C++/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎回到C-现代C"><a href="#欢迎回到C-现代C" class="headerlink" title="欢迎回到C++ -现代C++"></a>欢迎回到C++ -现代C++</h1><p><small>Welcome back to C++ - Modern C++</small></p><p>自从它被创建，C++逐渐成为世界上使用最广泛的语言之一。正确编写的 C++ 程序快速、高效。 相对于其他语言，该语言更加灵活：它可以在最高抽象级别上工作，也可以在芯片级（硅级别）上工作。C++ 提供高度优化的标准库。它允许访问低级硬件功能，以最大限度地提高速度并最大限度地减少内存需求。C++可以创建继续所有种类的应用：游戏、设备驱动、HPC、云、桌面、嵌入式和移动应用程序等等。甚至其他编程语言的库和编译器也是用 C++ 编写的。<br>C++的一个原始需求是向下兼容C语言。因此，C++总是允许以C风格编程，使用原始指针、数组、以空字符结尾的数组字符串<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class&#x3D;”hint–top hint–rounded” aria-label&#x3D;”及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code>“&gt;[1]</span></a></sup>以及其他功能。这或许能够拥有高效的表现，但也可以出现报错并让程序出现复杂性。C++的发展强调了一些特性，这些特性大大减少了对使用C风格语法的需要。当您需要他们时，旧式C编程工具仍然存在。但是，在现代 C++ 代码中，您应该越来越少地需要它们。现代 C++ 代码更简单、更安全、更优雅，并且仍然和以往一样快。<br>以下部分概述了现代 C++ 的主要特性。除非另有说明，此处列出的功能在 C++11 及更高版本中可用。在 Microsoft C++ 编译器中，您可以设置 &#x2F;std 编译器选项来指定要用于您的项目的标准版本。</p><h2 id="资源和智能指针"><a href="#资源和智能指针" class="headerlink" title="资源和智能指针"></a>资源和智能指针</h2><p><small>Resource and smart pointers</small><br>C风格编程中的一类主要bug是内存泄漏（确实如此，三天写代码，两天找bug）。泄漏通常是由于对使用 new 分配的内存调用 delete 失败引起的。现代 C++ 强调“资源获取即初始化”(RAII) <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="RAII，Resouce Acquisition Is Initialization:资源获取即初始化">[2]</span></a></sup>原则。 其理念很简单。 资源（堆内存、文件句柄、套接字等）应由对象“拥有”。 该对象在其构造函数中创建或接收新分配的资源，并在其析构函数中将此资源删除。 RAII 原则可确保当所属对象超出范围时，所有资源都能正确返回到操作系统。<br>为了支持对简单采用RAII的原则，C++基本库（STL）提供了三个智能指针类型: <code>std::unique_ptr</code>、<code>std::shared_ptr</code>以及<code>std::weak_ptr</code>。智能指针拥有申请和删除内存的控制句柄（智能指针处理它所拥有的内存的分配和删除）<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。">[3]</span></a></sup>。下面的示例演示了一个类，其中包含一个数组成员，该成员是在调用 <code>make_unique()</code> 时在堆上分配的。 对和的 <strong><code>new</code></strong> 调用 <strong><code>delete</code></strong> 由 <code>unique_ptr</code> 类封装。 当 <code>widget</code> 对象超出范围时，将调用 unique_ptr 析构函数，此函数将释放为数组分配的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">widget</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">widget</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> size) &#123; data = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(size); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionUsingWidget</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">widget <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;   <span class="hljs-comment">// lifetime automatically tied to enclosing scope</span><br>                <span class="hljs-comment">// constructs w, including the w.data gadget member</span><br>    <span class="hljs-comment">// ...</span><br>    w.<span class="hljs-built_in">do_something</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-comment">// automatic destruction and deallocation for w and w.data</span><br></code></pre></td></tr></table></figure><p>请尽可能使用智能指针管理堆内存（确实如此，如果没有追求极致效率的需求，使用智能指针是最方便且安全的）。 如果必须 <strong><code>new</code></strong> 显式使用和 <strong><code>delete</code></strong> 运算符，请遵循 RAII 原则。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170">对象生存期和资源管理 (RAII)</a>。</p><h2 id="std-string-和-std-string-view"><a href="#std-string-和-std-string-view" class="headerlink" title="std::string 和 std::string_view"></a>std::string 和 std::string_view</h2><p><small>std::string and std::string_view</small><br>C风格字符串是错误产生的另一个重要来源。通过使用<code>std::string</code> 和 <code>std::wstring</code>，您可以排除几乎所有和C风格字符串有联系的错误。此外，你还可以通过其成员方法获得更多字符串操作上的便利，例如搜索，追加，前缀等。两者都针对速度进行了高度优化<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》">[4]</span></a></sup>。将字符串传递给只需要只读访问权限的函数时，在 C++17 中，您可以使用 std::string_view 以获得更大的性能优势。</p><h2 id="std-vector向量和其他标准库容器"><a href="#std-vector向量和其他标准库容器" class="headerlink" title="std::vector向量和其他标准库容器"></a>std::vector向量和其他标准库容器</h2><p><small>std::string and other Standard Library containers</small><br>标准库容器都遵循 RAII 原则。 它们为安全遍历元素提供迭代器。 此外，它们对性能进行了高度优化，并且已充分测试正确性。 通过使用这些容器，可以消除自定义数据结构中可能引入的 bug 或低效问题。 使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-170"><code>vector</code></a> 替代原始数组，来作为 C++ 中的序列容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; apples;<br>apples.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Granny Smith&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 map（而不是 unordered_map），作为默认关联容器。 对于退化和多案例，使用 set、multimap 和 multiset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string, string&gt; apple_color;<br><span class="hljs-comment">// ...</span><br>apple_color[<span class="hljs-string">&quot;Granny Smith&quot;</span>] = <span class="hljs-string">&quot;Green&quot;</span>;<br></code></pre></td></tr></table></figure><p>需要进行性能优化时，请考虑以下用法：</p><ul><li>例如当重要的数据被嵌入时，将std::array类型作为类成员。</li><li>使用无序的关联容器，例如 unordered_map。 它们的每个元素的开销较低，并且具有固定时间查找功能，但正确高效地使用它们的难度更高。</li><li>使用std::vector时需要排序。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/algorithms?view=msvc-170">算法</a>。<br>不要使用 C 风格的数组。对于需要直接访问数据的旧 API，请使用访问器方法，例如 <code>f(vec.data(), vec.size());</code> 有关容器的更多信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/stl-containers?view=msvc-170">C++ 标准库容器</a>。</li></ul><h2 id="标准库算法"><a href="#标准库算法" class="headerlink" title="标准库算法"></a>标准库算法</h2><p>在假设需要为程序编写自定义算法之前，请首先查阅C++ 标准库中的算法。 标准库包含许多常见操作（如搜索、排序、筛选和随机化）的算法分类，且这些分类的算法库还在不断增加。 譬如&lt;math&gt;中的内容涵盖的很广泛。 自 C++17 起，变提供了许多算法的并行版本。<br>这里列举以下内容，比较重要。</p><ul><li><code>for_each</code>：默认遍历算法（基于范围的 for 循环）。</li><li><code>transform</code>：用于容器元素的非就地修改<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="`std::stransform` 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。">[5]</span></a></sup>。</li><li><code>find_if</code>：默认搜索算法。</li><li><code>sort</code>,<code>lower_bound</code>：排序、在一个范围内找到搜索元素的下标。以及其他排序和搜索算法。</li></ul><p>如果要写一个比较函数，可以使用lambda表达式以及’&lt;’符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> comp = [](<span class="hljs-type">const</span> widget&amp; w1, <span class="hljs-type">const</span> widget&amp; w2)<br>     &#123; <span class="hljs-keyword">return</span> w1.<span class="hljs-built_in">weight</span>() &lt; w2.<span class="hljs-built_in">weight</span>(); &#125;<br><br><span class="hljs-built_in">sort</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), comp );<br><br><span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">lower_bound</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), widget&#123;<span class="hljs-number">0</span>&#125;, comp );<br></code></pre></td></tr></table></figure><h2 id="使用auto关键字代替显示类型名称"><a href="#使用auto关键字代替显示类型名称" class="headerlink" title="使用auto关键字代替显示类型名称"></a>使用auto关键字代替显示类型名称</h2><p><small>auto instread of explicit type names</small><br>C++11引入了auto关键字，以便在变量、函数和模板的声明。auto关键字会指示编译器推导对象的类型，这样您即可无需显示键入。当对象是嵌套模板时，使用auto进行声明尤其有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;<span class="hljs-type">int</span>,list&lt;string&gt;&gt;::iterator i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// C-style</span><br><span class="hljs-keyword">auto</span> i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// modern C++</span><br></code></pre></td></tr></table></figure><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p><small>Range-based for loops</small><br>对数组和容器的C风格迭代容易出现索引错误，且重复的键入过程单调乏味。要消除这些错误并使您的代码更具可读性，请使用基于范围的 for 循环以及标准库容器和原始数组。有关详细信息，请参阅请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170">基于范围的</a> (<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)%E8%AF%AD%E5%8F%A5%E3%80%82">https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)语句。</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// C-style</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>        std::cout &lt;&lt; v[i];<br>    &#125;<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : v)&#123;<br>        std::cout &lt;&lt; num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>译注：<br>使用for_each虽然可以极大的提高for效率，但是如果在处理极大数据时或极长文本时请谨慎使用。因为其会将内容复制一份进行遍历。</p><h2 id="用-constexpr-表达式替代宏"><a href="#用-constexpr-表达式替代宏" class="headerlink" title="用 constexpr 表达式替代宏"></a>用 <code>constexpr</code> 表达式替代宏</h2><p>C 和 C++ 中的宏是在编译前由预处理器处理的一种标记。在编译代码之前，编译器会将使用宏定义的地方替换成宏所定义的值。C 样式编程通常使用宏来定义编译时常量值。 但宏容易出错且难以调试。 在现代 C++ 中，应优先使用 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/constexpr-cpp?view=msvc-170"><code>constexpr</code></a> 变量定义编译时常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 10 <span class="hljs-comment">// C-style</span></span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>; <span class="hljs-comment">// modern C++</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number = <span class="hljs-number">114514</span>;<br><br></code></pre></td></tr></table></figure><h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>在现代 C++ 中，可以使用任何类型的括号初始化。 在初始化数组、矢量或其他容器时，这种初始化形式会非常方便。在下面的这个例子中声明了一个类S，三个均为std::vetor(向量)类型的变量v1,v1,v3并用不同方式进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br>    std::string name;<br>    <span class="hljs-type">float</span> num;<br>    <span class="hljs-built_in">S</span>(std::string s, <span class="hljs-type">float</span> f) : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">num</span>(f) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// C-style initialization</span><br>    std::vector&lt;S&gt; v;<br>    <span class="hljs-function">S <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>)</span></span>;<br><br>    v.<span class="hljs-built_in">push_back</span>(s1);<br>    v.<span class="hljs-built_in">push_back</span>(s2);<br>    v.<span class="hljs-built_in">push_back</span>(s3);<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    std::vector&lt;S&gt; v2 &#123;s1, s2, s3&#125;;<br><br>    <span class="hljs-comment">// or...</span><br>    std::vector&lt;S&gt; v3&#123; &#123;<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>&#125;, &#123;<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>&#125;, &#123;<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>&#125; &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>若要了解详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/initializing-classes-and-structs-without-constructors-cpp?view=msvc-170">括号初始化</a>。</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>现代 C++ 提供了移动语义，此功能可以避免进行不必要的内存复制。 在此语言的早期版本中，在某些情况下无法避免复制。 移动操作会将资源的所有权从一个对象转移到下一个对象，而不必再进行复制。 一些类拥有堆内存、文件句柄等资源。 实现资源所属的类时，可以定义此类的移动构造函数和移动赋值运算符。 在解析重载期间，如果不需要进行复制，编译器会选择这些特殊成员。 如果定义了移动构造函数，则标准库容器类型会在对象中调用此函数。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符 (C++)</a>。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>在使用C语法编程中，一个函数可以通过返回函数指针的方式传递给另一个函数，这不方便位于和理解。它们引用的函数可能在源代码的其他地方定义，而不是从调用它的位置定义的。而且他们不是类型安全的。现代C++提供了对函数对象、类的运算符重写，从而使它们可以像函数一样进行调用。创建函数对象的最简便方法是使用内联 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">lambda 表达式</a>。 下面的示例演示如何使用 lambda 表达式传递函数对象，然后由 <code>for_each</code> 函数在vector的每个元素中调用此函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">find_if</span>(<span class="hljs-built_in">begin</span>(v), <span class="hljs-built_in">end</span>(v), [=](<span class="hljs-type">int</span> i) &#123; <br>    <span class="hljs-keyword">return</span> i &gt; x &amp;&amp; i &lt; y; <br>    &#125;<br>    );<br></code></pre></td></tr></table></figure><p>Lambda表达式的形式为<code>[]()&#123;&#125;</code>，这里的是<code>[=](int i) &#123; return i &gt; x &amp;&amp; i &lt; y; &#125;</code>。此函数有一个int类型的形参，并返回一个bool类型的值，指示该参数是否大于 <code>x</code> 且小于 <code>y</code>。这里使用的x,y是lambda之前声明的两个变量。行为上看似是[&#x3D;]接受了上文的变量，实际上是lambda接受了值的副本。有关更详细的内容请看相关专题。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><small>Exceptions</small><br>现代 c + + 强调异常，而不是错误代码，作为报告和处理错误条件的最佳方式。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-170">现代 C++ 处理异常和错误的最佳做法</a>。</p><h2 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h2><p>对线程间通信机制使用 C++ 标准库 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/atomic-structure?view=msvc-170"><code>std::atomic</code></a> 结构和相关类型。</p><h2 id="std-variant-C-17"><a href="#std-variant-C-17" class="headerlink" title="std::variant(C++17)"></a>std::variant(C++17)</h2><p>在以C风格编程程序时通过使用联合体（共用体）使不同类型的成员占据同一个内存位置而达到节约内存的目的。但这并不是安全的，并容易导致编译错误。 C++17 引入了更加安全可靠的 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-class?view=msvc-170"><code>std::variant</code></a> 类，来作为联合体（共用体）的替代项。可以使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-functions?view=msvc-170#visit"><code>std::visit</code></a> 函数以类型安全的方式访问 <code>variant</code> 类型的成员。</p><hr><p><strong>译者有话说</strong><br>本页的上述的示例代码为微软参考手册的简单案例，本人会在下方附上个人理解的完整代码。此部分代码也可以移步至<a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp: Code example of Microsoft modern C + + vs2022 translation (github.com)</a>进行阅览，请原谅本人代码水平不精，谢谢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;id)<br>        : <span class="hljs-built_in">stu_name</span>(name), <span class="hljs-built_in">stu_id</span>(id)&#123;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_name;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_id;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetCollege</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_college;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetCollage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string college)</span> </span>&#123;<br>        stu_college = college;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> std::string stu_name;<br>    <span class="hljs-type">const</span> std::string stu_id;<br>    std::string stu_college&#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> student = std::<span class="hljs-built_in">make_unique</span>&lt;Student&gt;(<span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>);<br>    std::cout &lt;&lt; student-&gt;<span class="hljs-built_in">GetId</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; (*student).<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">auto</span> ptr_stu = student.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// if smart pointer is released, this raw pointer will be null</span><br>    ptr_stu-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;computr network&quot;</span>);<br>    std::cout &lt;&lt; ptr_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">auto</span> share_stu = std::<span class="hljs-built_in">make_shared</span>&lt;Student&gt;(<span class="hljs-string">&quot;114&quot;</span>, <span class="hljs-string">&quot;1919810&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">share_stu_1</span><span class="hljs-params">(share_stu)</span></span>;<br>    share_stu_1-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;communication engineering&quot;</span>);<br>    std::cout &lt;&lt; share_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br>&#125;<br><br>  <br><br><span class="hljs-comment">// make_unique (C++14) creates a unique poniter that manages a new object</span><br><span class="hljs-comment">// make_unique_for_overwrite (C++20)</span><br></code></pre></td></tr></table></figure><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>RAII，Resouce Acquisition Is Initialization:资源获取即初始化<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><code>std::stransform</code> 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/C++语言参考</title>
    <link href="/2022/08/07/Cpp/C++%20Language%20Reference/"/>
    <url>/2022/08/07/Cpp/C++%20Language%20Reference/</url>
    
    <content type="html"><![CDATA[<p><strong>前言赘叙</strong><br>本系列文档是对于微软文档《Modern C++ vs2022》进行学习的些许笔记以及简单翻译。个人之力翻译可能并不标准，还望海涵，也请多多指点。敝人也尝试通过这次机会向大家分享，也希望个人也能在代码造诣上得到提高。为了能够帮助理解，本人也创建了一个仓库，会在接下来使用代码的地方进行插入，当然也欢迎直接阅读示例demo</p><p>点击此处可浏览仓库 <a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp</a><br>点击此处可浏览原文 <a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=msvc-170">C++ Language Reference | Microsoft Docs</a></p><hr><h1 id="C-语言参考"><a href="#C-语言参考" class="headerlink" title="C++语言参考"></a>C++语言参考</h1><p><em>C++ Language Reference</em></p><p>本参考说明了在 Microsoft C++ 编译器中实现的 C++ 编程语言。该组织基于 Margaret Ellis 和 Bjarne Stroustrup 的 The Annotated C++ Reference Manual 以及 ANSI&#x2F;ISO C++ 国际标准 (ISO&#x2F;IEC FDIS 14882)。包括 Microsoft 特定的 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果">[1]</span></a></sup>C++ 语言功能实现。<br>有关现代 C++ 编程实践的概述，请参阅《<a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>》<br>请参阅下表以快速找到关键字或运算符：</p><ul><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170">C++ Keywords</a> （C++关键字）</li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">C++ Operators</a>（C++操作符）</li></ul><h1 id="在这个部分"><a href="#在这个部分" class="headerlink" title="在这个部分"></a>在这个部分</h1><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lexical-conventions?view=msvc-170">Lexical Conventions</a>  词汇约定<br>C++程序的基本词法元素：预定义字符（标记）、注释、操作符、关键字、标点符号、字符串。此外还有：文件转译（文件操作）、运算符优先级&#x2F;关联性。</p><blockquote><p>Fundamental lexical elements of a C++ program: tokens, comments, operators, keywords, punctuators, literals. Also, file translation, operator precedence&#x2F;associativity.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/basic-concepts-cpp?view=msvc-170">Basic Concepts</a>  基本概念<br>范围、链接、程序的启动和终止、存储类和类型。</p><blockquote><p>Scope, linkage, program startup and termination, storage classes, and types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-170">Built-in types</a> 内置类型<br>C++编译器中内置的基本类型及其取值范围。</p><blockquote><p>The fundamental types that are built into the C++ compiler and their value ranges.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-170">Standard Conversions</a>  标准转换<br>内置类型之间的类型转换。此外，指针、引用和指向成员的类型之间的算术转换和转换。</p><blockquote><p>Type conversions between built-in types. Also, arithmetic conversions and conversions among pointer, reference, and pointer-to-member types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/declarations-and-definitions-cpp?view=msvc-170">Declarations and definitions</a> 声明和定义<br>声明和定义变量、类型和函数。</p><blockquote><p>Declaring and defining variables, types and functions.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">Operators, Precedence and Associativity</a><br>运算符、优先级和关联性<br>C++中的运算符。</p><blockquote><p>The operators in C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/expressions-cpp?view=msvc-170">Expressions</a>  表达式<br>表达式的类型、表达式的语义、运算符的参考主题、强制转换和强制转换运算符、运行时类型信息。</p><blockquote><p>Types of expressions, semantics of expressions, reference topics on operators, casting and casting operators, run-time type information.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">Lambda Expressions</a>  Lambda表达式<br>一种隐式定义函数对象类并构造该类类型的函数对象的编程技术。</p><blockquote><p>A programming technique that implicitly defines a function object class and constructs a function object of that class type.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/statements-cpp?view=msvc-170">Statements</a>  语句<br>表达式、null空值、复合语句、选择、迭代、跳转和声明语句。</p><blockquote><p>Expression, null, compound, selection, iteration, jump, and declaration statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/classes-and-structs-cpp?view=msvc-170">Classes and structs</a>  类和结构体<br>对于类、结构体和共用体的介绍。此外也有，成员函数、特殊成员函数、数据成员、位字段、this指针，嵌套类。</p><blockquote><p>Introduction to classes, structures, and unions. Also, member functions, special member functions, data members, bit fields, <strong><code>this</code></strong> pointer, nested classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/unions?view=msvc-170">Unions</a>  联合体<br>用户定义类型，其中所有成员共享同一内存位置。</p><blockquote><p>User-defined types in which all members share the same memory location.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/inheritance-cpp?view=msvc-170">Derived Classes</a>  派生类<br>单个和多个继承、虚函数、多继承、抽象类、范围规则。 此外，还有__super和__interface关键字。</p><blockquote><p>Single and multiple inheritance, <strong><code>virtual</code></strong> functions, multiple base classes, <strong>abstract</strong> classes, scope rules. Also, the <strong><code>__super</code></strong> and <strong><code>__interface</code></strong> keywords.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/member-access-control-cpp?view=msvc-170">Member-Access Control</a>  成员访问控制<br>控制对类成员的访问： public、 private关键字和 protected 关键字。 友元函数和友元类。</p><blockquote><p>Controlling access to class members: <strong><code>public</code></strong>, <strong><code>private</code></strong>, and <strong><code>protected</code></strong> keywords. Friend functions and classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/operator-overloading?view=msvc-170">Overloading</a>  重载<br>重载运算符，对运算符重载的规则。</p><blockquote><p>Overloaded operators, rules for operator overloading.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/exception-handling-in-visual-cpp?view=msvc-170">Exception Handling</a>  异常处理<br>C++ 异常处理、结构化异常处理 (SEH)、用于编写异常处理语句的关键字。</p><blockquote><p>C++ exception handling, structured exception handling (SEH), keywords used in writing exception handling statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/assertion-and-user-supplied-messages-cpp?view=msvc-170">Assertion and User-Supplied Messages</a>  断言和User-Supplied消息<br>#error 指令， static_assert 关键字， assert 宏。</p><blockquote><p><code>#error</code> directive, the <strong><code>static_assert</code></strong> keyword, the <code>assert</code> macro.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/templates-cpp?view=msvc-170">Templates</a>  模板<br>模板规范、函数模板、类模板、typename 关键字、模板对比于宏定义、模板和智能指针。</p><blockquote><p>Template specifications, function templates, class templates, <strong><code>typename</code></strong> keyword, templates vs. macros, templates and smart pointers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/event-handling?view=msvc-170">Event Handling</a>  事件处理<br>定义事件和事件处理程序</p><blockquote><p>Declaring events and event handlers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-specific-modifiers?view=msvc-170">Microsoft-Specific Modifiers</a>  独属于微软(msvc)的修饰符<br>Microsoft C++ 专用修饰符。 内存寻址、调用约定、naked函数、扩展存储类属性 (__declspec) 。 __w64</p><blockquote><p>Modifiers specific to Microsoft C++. Memory addressing, calling conventions, <strong><code>naked</code></strong> functions, extended storage-class attributes (<strong><code>__declspec</code></strong>), <strong><code>__w64</code></strong>.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/inline-assembler?view=msvc-170">Inline Assembler</a>  内联汇编程序<br>在__asm块中使用汇编语言和C++。</p><blockquote><p>Using assembly language and C++ in <strong><code>__asm</code></strong> blocks.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/compiler-com-support?view=msvc-170">Compiler COM Support</a>  编译器对COM的支持<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。">[2]</span></a></sup><br>有关用于支持 COM 类型的 Microsoft 专用类和全局函数的参考。</p><blockquote><p>A reference to Microsoft-specific classes and global functions used to support COM types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-extensions?view=msvc-170">Microsoft Extensions</a>  Microsoft的拓展<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等">[3]</span></a></sup><br>Microsoft微软对C++进行的扩展</p><blockquote><p>Microsoft extensions to C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/nonstandard-behavior?view=msvc-170">Nonstandard Behavior</a>  非标准行为<br>有关Microsoft C++编译器的非标准行为的信息。<br>Information about nonstandard behavior of the Microsoft C++ compiler.</p><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>  欢迎回到C++<br>一篇现代C + +编程实践概述，指引编写安全、正确、高效的程序。</p><blockquote><p>An overview of modern C++ programming practices for writing safe, correct and efficient programs.</p></blockquote><hr> <section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一篇闲言碎语</title>
    <link href="/2022/08/07/another-gossip/"/>
    <url>/2022/08/07/another-gossip/</url>
    
    <content type="html"><![CDATA[<h1 id="另一篇闲言碎语"><a href="#另一篇闲言碎语" class="headerlink" title="另一篇闲言碎语"></a>另一篇闲言碎语</h1><p>对于hexo我的技术力实在是太低了，于是乎就在hexo的主题库中找了一个–“anatole”非常的不错。其中一个巨大的原因是因为我发现我忘记怎么设计网页了，回忆以前还知道玩玩什么jqury,boostrapl，如果回到18年甚至可以手撸css,js。奈何现在是一位大专两年级的学生，除了每顿猛造两碗饭，其他的都忘记了。<br>所以坦白一下我是如何做了这个稀烂的主页的。</p><hr><p>首先用日常是开了一个科学上网，用winget把nodejs给整上，迅速的安装一波hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>npm install hexo<br>hexo init &lt;blog-name&gt;<br>cd &lt;blog-name&gt;<br>npm install<br></code></pre></td></tr></table></figure><h2 id="对了，如果不能直接用hexo指令的话可以配置一下1-npx-hexo-lt-command-gt-2-将-Hexo-所在的目录下的-node-modules-添加到环境变量之中即可直接使用-96-hexo"><a href="#对了，如果不能直接用hexo指令的话可以配置一下1-npx-hexo-lt-command-gt-2-将-Hexo-所在的目录下的-node-modules-添加到环境变量之中即可直接使用-96-hexo" class="headerlink" title="对了，如果不能直接用hexo指令的话可以配置一下1.  npx hexo &lt;command&gt;2.  将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 &#96;hexo "></a>对了，如果不能直接用hexo指令的话可以配置一下<br>1.  <code>npx hexo &lt;command&gt;</code><br>2.  将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 &#96;hexo <command><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></h2><p>上述步骤完成后，就是抄一个主题下来。感谢hexo设计的很简单，让我一下子就上手了。<br>把主题文件放到themes下就可以了，比如我的是<strong>E:\blog\themes\anatole</strong><br><small><em>什么？如何安装主题，当然是点一个然后 <code>git clone</code>下来哦</em></small></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole<br>cd anatole<br>git pull<br>npm install --save hexo-render-pug hexo-generator-archive hexo-generator-tag hexo-generator-index hexo-generator-category<br></code></pre></td></tr></table></figure><p>然后在_config.yml里填写一个特殊的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">archive_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>每一个主题的安装都不尽相同，所以得按照自己挑选的主题来进行配置。</strong></p><hr><p>按照主题的官网wiki配置一通以后，发现下面那个小蓝鸟，小粪坑不知道怎么关闭2333。在尝试去ejs中修改的我也放弃了。对了，这里要坦白我学会怎么修改favicon以及logo，于是就去主题中修改了源图标[手动狗头]。好了，今日吹水到此结束，明日（或许）开始认真更新一些东西。<br>顺便在下面贴上使用的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br>  <br><br><span class="hljs-comment"># Site</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">CvRaindays</span><br><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">std::shared_ptr&lt;Blog&gt;</span> <span class="hljs-string">CvRain(this);</span><br><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">C,C++,Linux</span><br><br><span class="hljs-attr">author:</span> <span class="hljs-string">CvRaindays,cvraindays@outlook.com</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-cn</span><br><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># URL</span><br><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://example.com</span><br><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><br><span class="hljs-attr">permalink_defaults:</span><br><br><span class="hljs-attr">pretty_urls:</span><br><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br>  <br><br><span class="hljs-comment"># Directory</span><br><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><br><span class="hljs-attr">skip_render:</span> <span class="hljs-string">README.md</span><br><br>  <br><br><span class="hljs-comment"># Writing</span><br><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><br><span class="hljs-attr">external_link:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">highlight:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">prismjs:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Home page setting</span><br><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><br><span class="hljs-attr">index_generator:</span><br><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br>  <br><br><span class="hljs-comment"># Category &amp; Tag</span><br><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><br><span class="hljs-attr">category_map:</span><br><br><span class="hljs-attr">tag_map:</span><br><br>  <br><br><span class="hljs-comment"># Metadata elements</span><br><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br>  <br><br><span class="hljs-comment"># Date / Time format</span><br><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Pagination</span><br><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br>  <br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><br><span class="hljs-attr">include:</span><br><br><span class="hljs-attr">exclude:</span><br><br><span class="hljs-attr">ignore:</span><br><br>  <br><br><span class="hljs-comment"># Extensions</span><br><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><br><span class="hljs-attr">theme:</span> <span class="hljs-string">anatole</span><br><br>  <br><br><span class="hljs-comment"># Deployment</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><br>  <br><br><span class="hljs-attr">deploy:</span><br><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/CvRain/cvrain.github.io.git</span><br><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br><br>  <br><br><span class="hljs-attr">archive_generator:</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br><br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好世界！</title>
    <link href="/2022/08/07/hello-world/"/>
    <url>/2022/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>经过了三个小时的辛苦劳作，鱼师傅成功摸出来一个HelloWorld!<br>第一篇blog，准备先写个小记作为一个段子乐呵乐呵。 </p><hr><h2 id="一盘饺子"><a href="#一盘饺子" class="headerlink" title="一盘饺子"></a>一盘饺子</h2><p>属实是有了一壶好醋，也是可怜了我的Surface Go2，跟着我并没有享受到作为“高端”电子设备的万千宠爱，反而是被不断刷机。不是因为购买的是丐版，而且其配置加上Windows11略有拉跨。不得不研究如何在上面刷一套Linux操作系统用来满足个人需求，提高工作效率。具体的相关情况请看后文内容，本篇小作文仅作为一个引子。<br>说回来，Go系列的刷系统确实难受，翻烂了各种帖子，总算是总结出一套目前看最完善的装系统经验。回味过来笔者果然是无聊透顶，可能坚持捣鼓刷系统的也没有多少了吧，当然也可以和个人性格以及家庭有些许关系。<br>准备录制一个视频和大家分享分析，经过一晚上的辗转反侧来看，还是需要写个什么东西使得叙述更完整一点。那就不如自己搞个博客吧！或许也只会发少量的东西，不过说不好也不好说。</p><h2 id="做些什么"><a href="#做些什么" class="headerlink" title="做些什么"></a>做些什么</h2><p>就目前看来，或许会更新一些个人在编程上的小经验，不过和其他奆佬比起来就是腐草荧光了。未来可能尝试自己做一个Hexo的主题（不过感觉60%要泡汤了），然后写一点关于模组教程的小作文。嗯，似乎没了。</p><h2 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h2><p>感觉自己越来越不会说话了，文采也不太行了。还没到老年却也喜欢絮絮叨叨一番。身心格外的疲倦，也不知道为什么，还是按时吃药吧，或许问题不大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
