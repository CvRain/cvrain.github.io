<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>haskell-case</title>
    <link href="/2023/11/21/haskell-case/"/>
    <url>/2023/11/21/haskell-case/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-case"><a href="#Haskell-case" class="headerlink" title="Haskell - case"></a>Haskell - case</h1><p>函数中模板匹配的本质实际上就是case语句的语法糖。case语句在函数式编程中用途往往比命令式要大很多，因为这样可以很流畅的定义出一个没有指令流程的函数，使得函数的定义更加流畅。<br>举一个简单的例子</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetterV1</span> :: [a] -&gt; a<br><span class="hljs-title">firstLetterV1</span> [] = error <span class="hljs-string">&quot;Null list&quot;</span><br><span class="hljs-title">firstLetterV1</span> [x:_] = x<br></code></pre></td></tr></table></figure><p>完全等价于这段代码</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetterV2</span> :: [a] -&gt; a<br><span class="hljs-title">firstLetterV2</span> str = <span class="hljs-keyword">case</span> str <span class="hljs-keyword">of</span> [] -&gt; error <span class="hljs-string">&quot;Null list&quot;</span><br>                                (x:_) -&gt; x<br></code></pre></td></tr></table></figure><p>从中我们可以看到case表达式语法长这个样子<br> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">case</span> expression <span class="hljs-keyword">of</span> pattern -&gt; result<br> pattern -&gt; result<br> pattern -&gt; result<br> <span class="hljs-comment">-- ....</span><br></code></pre></td></tr></table></figure></p><p>于是乎就可以写出这样的代码</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">scoreValue</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Char</span><br><span class="hljs-title">scoreValue</span> value =<br>    <span class="hljs-keyword">let</span> range = div value <span class="hljs-number">10</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span> range <span class="hljs-keyword">of</span> <span class="hljs-number">6</span> -&gt; <span class="hljs-string">&#x27;D&#x27;</span><br>                     <span class="hljs-number">7</span> -&gt; <span class="hljs-string">&#x27;C&#x27;</span><br>                     <span class="hljs-number">8</span> -&gt; <span class="hljs-string">&#x27;B&#x27;</span><br>                     <span class="hljs-number">9</span> -&gt; <span class="hljs-string">&#x27;A&#x27;</span><br>                     <span class="hljs-number">10</span> -&gt; <span class="hljs-string">&#x27;S&#x27;</span><br>                     _ -&gt; <span class="hljs-string">&#x27;F&#x27;</span><br><br><span class="hljs-title">describeList</span> :: [a] -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">describeList</span> ls = <span class="hljs-string">&quot;The list is &quot;</span> ++ str ls<br>    <span class="hljs-keyword">where</span> str [] = <span class="hljs-string">&quot;empty&quot;</span><br>          str [x] = <span class="hljs-string">&quot;a singleton list&quot;</span><br>          str ls = <span class="hljs-string">&quot;a longer list&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - let</title>
    <link href="/2023/11/21/Haskell-let/"/>
    <url>/2023/11/21/Haskell-let/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-let"><a href="#Haskell-let" class="headerlink" title="Haskell - let"></a>Haskell - let</h1><p>我们可以在函数中使用<code>where</code>比较轻松的在函数底部绑定变量，他对包括所有<code>guard</code>在内的整个函数可见。可我们还想要更多的功能，比如函数处理过程中可能需要一些局部变量，或者做一些临时运算，那么<code>let</code>可以完成这个功能。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">cylinder</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span><br><span class="hljs-title">cylinder</span> r h = <br>    <span class="hljs-keyword">let</span> sideArea = h * r * <span class="hljs-number">2</span><br>        topArea = pi * r * r<br>    <span class="hljs-keyword">in</span> sideArea + topArea<br>    <br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print $ cylinder <span class="hljs-number">3</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><em>let &lt; bindings &gt; in &lt; expressions &gt;</em> let中绑定的名字只能在in中使用<br>let 和 where最大的区别就是 let是一个表达式，表达式一定是有一个返回值的，而where不是。所以let可以在几乎任何地方使用。</p><p>从一个元组中取值</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell">(<span class="hljs-keyword">let</span> (a, b, c) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> a + b + c) * <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这里让a,b,c分别匹配到了数字1, 2, 3， 之后再相加乘以100，最后结果是600</p><h2 id="列表推导式中的let"><a href="#列表推导式中的let" class="headerlink" title="列表推导式中的let"></a>列表推导式中的let</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="hljs-keyword">let</span> bmi = w / h ^ <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="hljs-keyword">let</span> bmi = w / h ^ <span class="hljs-number">2</span>, bmi &gt; <span class="hljs-number">25.0</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java小实验-初步使用类</title>
    <link href="/2023/11/18/java-example-2/"/>
    <url>/2023/11/18/java-example-2/</url>
    
    <content type="html"><![CDATA[<h1 id="java小实验-初步使用类"><a href="#java小实验-初步使用类" class="headerlink" title="java小实验-初步使用类"></a>java小实验-初步使用类</h1><p>定义一个学生类，包含的成员有：姓名，学号，绩优成绩，总人数，平均绩优成绩等数据成员，和数据的getter 和setter方法，以及toString 方法，合理使用 public, private, static,final等限定词。主函数中创建５个学生对象，输出每个学生的个性信息，以及全部学生对象的全局信息。</p><p><strong>Student.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> String id;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> score;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> total;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> average;  <br>  <br>    Student(String name, String id, <span class="hljs-type">double</span> score) &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>        <span class="hljs-built_in">this</span>.score = score;  <br>        average = (average * total++ + score) / total;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetName</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetId</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetScore</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetName</span><span class="hljs-params">(String name)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetId</span><span class="hljs-params">(String id)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetScore</span><span class="hljs-params">(<span class="hljs-type">double</span> score)</span>&#123;  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">lastScore</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.score;  <br>        average =  (average * total - lastScore + score) / total;  <br>        <span class="hljs-built_in">this</span>.score = score;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetCount</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> total;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetAverage</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> average;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;学号%s 姓名%s 成绩%f&quot;</span>, GetId(), GetName(), GetScore());  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student1.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test2&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        student2.SetId(<span class="hljs-string">&quot;1919810&quot;</span>);  <br>        System.out.println(student2.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test3&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student3.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test4&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student4.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test5&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student5.toString());  <br>  <br>        System.out.println(<span class="hljs-string">&quot;平均成绩 &quot;</span> + student1.GetAverage());  <br>        student3.SetScore(<span class="hljs-number">80.5</span>);  <br>        System.out.println(<span class="hljs-string">&quot;平均成绩 &quot;</span> + student1.GetAverage());  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java-example</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - where</title>
    <link href="/2023/11/16/haskell-where/"/>
    <url>/2023/11/16/haskell-where/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-where"><a href="#Haskell-where" class="headerlink" title="Haskell - where"></a>Haskell - where</h1><p> 引入一个小案例<br> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTest</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTest</span> weight height<br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">18.5</span> = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">25</span> = <span class="hljs-string">&quot;Normal&quot;</span><br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">30</span> = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br></code></pre></td></tr></table></figure><br>这是一个简单的bmi指数测试函数，使用了前一篇的guard完成，这样写挺好，但是还是不够完美。这里对bmi数值有三次重复的计算，如果输入的数据走到了otherwise就会算三次，血亏！<br>让我们稍加修改一下代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTestV2</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTestV2</span> weight height<br>    | bmi &lt;= underWeight = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | bmi &lt;= normal = <span class="hljs-string">&quot;Normal&quot;</span><br>    | bmi &lt;= overWeight = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span><br>          underWeight = <span class="hljs-number">18.5</span><br>          normal = <span class="hljs-number">25</span><br>          overWeight = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>看着代码应该就明白这个怎么回事了，但是有一点需要吐槽，就是这个缩进问题，他不是像python那样固定缩进到一个代码块就ok了，而是变量定义都必须对齐到同一列，如果不这样规范，Haskell就会搞不清楚他们各自位于哪个代码块中了。</p><h2 id="where的作用域"><a href="#where的作用域" class="headerlink" title="where的作用域"></a><code>where</code>的作用域</h2><p>函数where部分定义的名字只对本函数可见，所以不用担心存在大量的全局函数污染代码。当然如果想要一个全局变量，那么反而是要自己定义一下的。</p><h2 id="where中的模式模式匹配"><a href="#where中的模式模式匹配" class="headerlink" title="where中的模式模式匹配"></a><code>where</code>中的模式模式匹配</h2><p>在where中也可以使用到模式匹配，修改前面的BMI函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTestV2</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTestV2</span> weight height<br>    | bmi &lt;= underWeight = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | bmi &lt;= normal = <span class="hljs-string">&quot;Normal&quot;</span><br>    | bmi &lt;= overWeight = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span><br>          (underWright, normal, overHeight) = (<span class="hljs-number">18.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">30.0</span>)<br></code></pre></td></tr></table></figure><h2 id="where块中的函数"><a href="#where块中的函数" class="headerlink" title="where块中的函数"></a><code>where</code>块中的函数</h2><p>在where中也可以定义函数，美滋滋属于是了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>. <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs]<br><span class="hljs-keyword">where</span> bmi weight height = weight / height ^ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - guard</title>
    <link href="/2023/11/16/haskell-guard/"/>
    <url>/2023/11/16/haskell-guard/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-guard"><a href="#Haskell-guard" class="headerlink" title="Haskell - guard"></a>Haskell - guard</h1><p><strong>Haskell - guard</strong></p><p>在Haskell中，guard是一种编程技巧，用于在满足某个条件时执行一段代码，否则跳过该代码块。guard通常用于控制流语句（如if、elif和else）中，用于在满足某个条件时执行相应的代码。<br>除了使用其他语言基本都会存在的控制流语句之外，还可以使用**|** 来进行条件分支的处理，可读性更高而且与模式匹配契合的非常好</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">scoreLevel</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">scoreLevel</span> score<br>    | score &lt; <span class="hljs-number">60</span> = <span class="hljs-string">&quot;Failed!&quot;</span><br>    | score &lt; <span class="hljs-number">70</span> = <span class="hljs-string">&quot;Passed!&quot;</span><br>    | score &lt; <span class="hljs-number">80</span> = <span class="hljs-string">&quot;Good!&quot;</span><br>    | score &lt; <span class="hljs-number">90</span> = <span class="hljs-string">&quot;Excellent!&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Perfect!&quot;</span><br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (scoreLevel <span class="hljs-number">60</span>)<br>    print (scoreLevel <span class="hljs-number">70</span>)<br>    print (scoreLevel <span class="hljs-number">80</span>)<br>    print (scoreLevel <span class="hljs-number">90</span>)<br></code></pre></td></tr></table></figure><p>这段代码定义了一个名为<code>scoreLevel</code>的函数，接受一个<code>Double</code>类型的参数<code>score</code>，并返回一个字符串。该函数根据<code>score</code>的值，返回不同的字符串。otherwise会捕获剩下的所有条件。<br>一个竖线就是一个布尔表达式，如果计算是True就会选择对应的函数进入，如果是False就会走下面的表达式。一句题外话， |  不像 switch..case一样，进入一个case后就会执行下面的case所有语句。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">myCompare</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type">Ordering</span><br><span class="hljs-title">myCompare</span> x y<br>    | x &gt; y = <span class="hljs-type">GT</span><br>    | x == y = <span class="hljs-type">EQ</span><br>    | otherwise = <span class="hljs-type">LT</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 模式匹配</title>
    <link href="/2023/11/16/haskell-pattern-matching/"/>
    <url>/2023/11/16/haskell-pattern-matching/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-模式匹配"><a href="#Haskell-模式匹配" class="headerlink" title="Haskell - 模式匹配"></a>Haskell - 模式匹配</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>引子：假设我们要一个函数，这个函数可以处理一个数是不是7。按照之前的思路，我们可以这样写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">isSevenV1</span> x = <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;Is seven&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Is not seven&quot;</span><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ isSevenV1<br></code></pre></td></tr></table></figure><p>那么如果是判断一个数的是0-10中的哪一个，是否这样写会稍微麻烦一点，不过可能想到使用列表<code>[(1,&quot;one&quot;),(2,&quot;two&quot;)]</code>这样来处理。 </p><p>那么或许有一个不错的方法——模式匹配</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">isSevenV1</span> x = <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;Is seven&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Is not seven&quot;</span><br><br>  <br><br><span class="hljs-title">isSevenV2</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">isSevenV2</span> <span class="hljs-number">7</span> = <span class="hljs-string">&quot;Is seven&quot;</span><br><span class="hljs-title">isSevenV2</span> x = <span class="hljs-string">&quot;Is not seven&quot;</span><br><br>  <br><span class="hljs-title">sayNumber</span> ::<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">1</span> = <span class="hljs-string">&quot;One&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">2</span> = <span class="hljs-string">&quot;Two&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">3</span> = <span class="hljs-string">&quot;Three&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">4</span> = <span class="hljs-string">&quot;Four&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">5</span> = <span class="hljs-string">&quot;Five&quot;</span><br><span class="hljs-title">sayNumber</span> x = <span class="hljs-string">&quot;Not between 1 and 5&quot;</span><br><br>  <br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br><br><span class="hljs-title">print</span> $ isSevenV1 <span class="hljs-number">7</span><br><span class="hljs-title">print</span> $ isSevenV2 <span class="hljs-number">8</span><br><span class="hljs-title">print</span> $ isSevenV2 <span class="hljs-number">7</span><br><br>  <br><span class="hljs-title">print</span> $ sayNumber <span class="hljs-number">3</span><br><span class="hljs-title">print</span> $ sayNumber <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>在调用函数时，会将传入的参数从上往下顺序检查，一旦有匹配，对应的函数就会被调用。 如果给出一个x,y,z这样的参数，那么他就成为了一个万能模式，可以匹配到所有的参数， 一个好处就是可以处理最后情况之外的部分。<br>当然如果将万能模式丢到了函数最上面，那么很抱歉，万能模式函数之后的函数就永远都不会匹配到了。</p><p><em>使用模式匹配完成一个求阶乘</em></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">factorial</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">factorial</span> <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br><span class="hljs-title">factorial</span> n = n * factorial (n - <span class="hljs-number">1</span>)<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ factorial <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>不过有些函数看起来可以正常运行，但是实际上却会出发runtime error。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">charName</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;a&#x27;</span> = <span class="hljs-number">1</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;b&#x27;</span> = <span class="hljs-number">2</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;c&#x27;</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果我们在调用函数的时候，使用<code>charName &#39;h&#39;</code>。 可以得到<code>Non-exhaustive</code>因为这套模板没有不够全面，没有考虑到’a’ ‘b’ ‘c’三者之外的情况。那么程序也就会发生不可预料的问题，这里其实也有一定的防御式编程思想。</p><h2 id="元组的模式匹配"><a href="#元组的模式匹配" class="headerlink" title="元组的模式匹配"></a>元组的模式匹配</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">addVectorsV1</span> :: (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)<br><span class="hljs-title">addVectorsV1</span> a b = (fst a + fst b, snd a + snd b)<br><br><span class="hljs-title">addVectorsV2</span> :: (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)<br><span class="hljs-title">addVectorsV2</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)<br><br>  <br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ addVectorsV1 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>print $ addVectorsV2 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>虽然我们可以使用<code>addVectorV1</code>的方式去处理两个或者多个元组的之间的操作。针对于每一个元组用fst和snd取双元组的两个元素。可以运行,没有问题。但是有更加漂亮的做法<code>addVectorV2</code><br>参数直接上两个元组，还有了名字，用两个字来说：优雅。</p><p><strong>实现一个三元组</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">tupleFirst</span> :: (a,b,c) -&gt; a<br><span class="hljs-title">tupleFirst</span> (x,_,_) = x<br>  <br><span class="hljs-title">tupleSecond</span> :: (a,b,c) -&gt; b<br><span class="hljs-title">tupleSecond</span> (_,y,_) = y<br><br><span class="hljs-title">tuledThird</span> :: (a,b,c) -&gt; c<br><span class="hljs-title">tuledThird</span> (_,_,z) = z<br></code></pre></td></tr></table></figure><p>不用关心具体是什么类型，也不需要管具体的内容，给上一个泛变量就ok了。</p><h2 id="列表与列表推导式匹配"><a href="#列表与列表推导式匹配" class="headerlink" title="列表与列表推导式匹配"></a>列表与列表推导式匹配</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">xs</span> = [(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">5</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)]<br>[a + b | (a,b) &lt;- xs]<br></code></pre></td></tr></table></figure><p>可以得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ghci">[4,7,6,8,11] <br></code></pre></td></tr></table></figure><p><strong>做一个简单的head函数</strong><br><em>([1,2,3] 只是一个 1:2:3:[]的语法糖)</em></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">head</span>` :: [a] -&gt; a<br><span class="hljs-title">head</span>` [] = error &#x27;<span class="hljs-type">Can</span> not call head on a empty list&#x27;<br><span class="hljs-title">head</span>` (x:_) = x<br></code></pre></td></tr></table></figure><h2 id="As模式"><a href="#As模式" class="headerlink" title="As模式"></a>As模式</h2><p>允许按照模式将一个值分割成多个项，同时保留对其整体的引用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetter</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">firstLetter</span> <span class="hljs-string">&quot;&quot;</span> = <span class="hljs-string">&quot;Empty string&quot;</span><br><span class="hljs-title">firstLetter</span> all@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ firstLetter <span class="hljs-string">&quot;&quot;</span><br>    print $ firstLetter <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>这个函数接受一个字符串参数，并返回一个字符串。<br><code>firstLetter :: String -&gt; String</code></p><p>函数的实现分为两种情况：</p><ol><li>如果输入的字符串为空字符串（””），则返回字符串 “Empty string”。</li><li>如果输入的字符串非空，则返回字符串 “The first letter of [all] is [first letter]”。其中 <code>[all]</code> 和 <code>[first letter]</code> 分别表示输入的字符串 <code>all</code> 和第一个字母 <code>first letter</code>。</li></ol><p>函数的实现使用了一个As模式<code>all@(x:xs)</code>，它表示一个字符串 <code>all</code>，其中 <code>x</code> 是字符串 <code>xs</code> 的第一个字符。这里或许会因为变量名字觉得理解，xs是否是x+s这种情况，实际上也可以命名为(firstLetter : exceptFirstLetter)也是一样的。这也是上面说的列表的语法糖。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">all</span>@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x]<br></code></pre></td></tr></table></figure><p>这个匿名函数的目的是将字符串 <code>all</code> 的第一个字母替换为输入字符串 <code>all</code> 的第一个字母，并将结果与字符串 <code>[x]</code> 连接起来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 顺序表结构</title>
    <link href="/2023/11/15/c-seqlist/"/>
    <url>/2023/11/15/c-seqlist/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言顺序表结构"><a href="#C语言顺序表结构" class="headerlink" title="C语言顺序表结构"></a>C语言顺序表结构</h1><p>顺序表，也称作线性表，是数据结构的一种，由一系列数据元素组成，每个数据元素在内存中按顺序存放。顺序表中的数据元素可以是相同类型的数据，也可以是不同类型的数据。</p><p>在计算机科学中，顺序表通常用数组表示，数组是一个由相同类型的数据元素组成的集合。数组中的每个元素都存储在一个连续的内存地址中，并且可以通过它们的索引来访问。</p><p>例如，下面是一个用Python表示的顺序表，其中包含整数：<br><code>my_list = [1, 2, 3, 4, 5]</code></p><p>在这个例子中，<code>my_list</code>是一个包含五个整数的顺序表，它们的值分别为1、2、3、4、5。要访问其中某个元素的值，可以使用索引，例如：<br><code>first_element = my_list[0]  # first_element的值为1 second_element = my_list[1]  # second_element的值为2</code></p><p>顺序表可以用于存储各种类型的数据，如整数、浮点数、对象等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEQUENTIAL_LIST_H  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQUENTIAL_LIST_H  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];  <br>    <span class="hljs-type">int</span> age;  <br>&#125; Data;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>    Data *list_data;  <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEQUENTIAL_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQUENTIAL_LIST_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125; Data;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Data *list_data;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> max_length;<br>&#125; sequential_list;<br><br><span class="hljs-comment">// initialize the list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_init</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-built_in">list</span>-&gt;list_data = (Data *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Data) * size);<br>    <span class="hljs-built_in">list</span>-&gt;max_length = size;<br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// return the length of the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_length</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// append a new element to the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_append</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, Data data)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;length &gt;= <span class="hljs-built_in">list</span>-&gt;max_length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">list</span>-&gt;list_data[<span class="hljs-built_in">list</span>-&gt;length++] = data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// insert a new element to the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_insert</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index, Data data)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;max_length || index &gt; <span class="hljs-built_in">list</span>-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// shift the elements to the right</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">list</span>-&gt;length; i &gt; index; i--) &#123;<br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// insert the new element</span><br>    <span class="hljs-built_in">list</span>-&gt;list_data[index] = data;<br>    <span class="hljs-built_in">list</span>-&gt;length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// delete an element from the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_delete</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span>(index &lt;<span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// shift the elements to the left</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index; i&lt;<span class="hljs-built_in">list</span>-&gt;length; i--)&#123;<br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> --<span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_get_index</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, Data data)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(data.age == <span class="hljs-built_in">list</span>-&gt;list_data[i].age &amp;&amp; <span class="hljs-built_in">strcmp</span>(data.name, <span class="hljs-built_in">list</span>-&gt;list_data[i].name) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>Data* <span class="hljs-title function_">set_get_element</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-built_in">list</span>-&gt;list_data[index];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_clean</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span>&#123;  <br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">list</span>-&gt;list_data);  <br>    <span class="hljs-built_in">list</span>-&gt;max_length = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data = <span class="hljs-literal">NULL</span>;  <br>&#125;<br><br><span class="hljs-comment">// print the element in the list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_print_element</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;age);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//SEQUENTIAL_LIST_H</span></span><br>    <span class="hljs-type">int</span> length;  <br>    <span class="hljs-type">int</span> max_length;  <br>&#125; sequential_list;  <br>  <br><span class="hljs-comment">// initialize the list  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_init</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> size)</span> &#123;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data = (Data *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Data) * size);  <br>    <span class="hljs-built_in">list</span>-&gt;max_length = size;  <br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// return the length of the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_length</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// append a new element to the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_append</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, Data data)</span> &#123;  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;length &gt;= <span class="hljs-built_in">list</span>-&gt;max_length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data[<span class="hljs-built_in">list</span>-&gt;length++] = data;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// insert a new element to the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_insert</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index, Data data)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;max_length || index &gt; <span class="hljs-built_in">list</span>-&gt;length) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// shift the elements to the right  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">list</span>-&gt;length; i &gt; index; i--) &#123;  <br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i - <span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-comment">// insert the new element  </span><br>    <span class="hljs-built_in">list</span>-&gt;list_data[index] = data;  <br>    <span class="hljs-built_in">list</span>-&gt;length++;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// delete an element from the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_delete</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;  <br>    <span class="hljs-keyword">if</span>(index &lt;<span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// shift the elements to the left  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index; i&lt;<span class="hljs-built_in">list</span>-&gt;length; i--)&#123;  <br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i+<span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> --<span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_get_index</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, Data data)</span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;length; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(data.age == <span class="hljs-built_in">list</span>-&gt;list_data[i].age &amp;&amp; <span class="hljs-built_in">strcmp</span>(data.name, <span class="hljs-built_in">list</span>-&gt;list_data[i].name) == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">return</span> i;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>  <br>Data* <span class="hljs-title function_">set_get_element</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-built_in">list</span>-&gt;list_data[index];  <br>&#125;  <br>  <br><span class="hljs-comment">// print the element in the list  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_print_element</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;name);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;age);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;length - <span class="hljs-number">1</span>);  <br>&#125;  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//SEQUENTIAL_LIST_H</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C-example</tag>
      
      <tag>Data-Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java小实验-多态的应用</title>
    <link href="/2023/11/14/java-example-1/"/>
    <url>/2023/11/14/java-example-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Java小实验-多态的应用"><a href="#Java小实验-多态的应用" class="headerlink" title="Java小实验-多态的应用"></a>Java小实验-多态的应用</h1><h2 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h2><p>通过包的创建，类的继承在程序中的具体应用，进一步掌握多态的特点、技巧及使用等。同时熟练使用Java异常处理机制，处理程序中可能出现的异常。</p><h2 id="二、实验环境及要求"><a href="#二、实验环境及要求" class="headerlink" title="二、实验环境及要求"></a>二、实验环境及要求</h2><p>Jdk1.8以上的开发环境，可使用任何编辑器。</p><h2 id="三、实验内容及相应程序"><a href="#三、实验内容及相应程序" class="headerlink" title="三、实验内容及相应程序"></a>三、实验内容及相应程序</h2><ol><li>设计一个圆类Circle，该类存在于mycircle包中，它具有以下的属性和方法：<br>私有属性：圆半径r，圆心坐标x和y，<br>方法：设置和获取所有私有属性r,x,y的方法，方法名自定；计算圆周长的方法perimeter()；计算圆面积的方法area(),<br>要求直接使用Math类中的PI；</li><li>设计一个圆柱体类Cylinder，该类存在于mycylinder包中，Cylinder继承Circle，它增加了以下属性和方法：<br> 私有属性：高度h，<br> 方法：设置和获取私有属性h的方法，方法名自定；计算表面积的方法area()；计算体积的方法volume()；</li><li>编写一个Java Application程序Compute.java，用来显示某一个圆柱体中心坐标位置(如图1中的k的位置)，高度h，以及它的表面积（不包括两个底的面积）、体积和底面积。要求圆半径r，圆心坐标x和y，以及高度h的值均从命令行输入。<br> <strong>提示及注意：</strong><br> 圆柱体的体积&#x3D;底面积<em>高；<br> 圆柱体的表面积&#x3D;底面周长</em>高；<br> 每一个圆柱体的生成，都是在原有的圆的基础上，添加高度生成的。</li><li>编写测试类Computer.java程序，该类能够处理程序中可能出现的所有的异常 ，并有相应的提示信息。如命令行没有输入，则程序会向控制台输出“命令行没有输入，请输入正确的数值”这样的提示信息；</li></ol><h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>MyCircle.Circle.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> MyCircle;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> r;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">this</span>.y = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">this</span>.r = <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = x;  <br>        <span class="hljs-built_in">this</span>.y = y;  <br>        <span class="hljs-built_in">this</span>.r = CheckRadiusFormat(r);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = x;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.y = y;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetR</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.r = CheckRadiusFormat(r);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetX</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> x;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetY</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> y;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetR</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> r;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Perimeter</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> Math.PI * <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">this</span>.r;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Area</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> Math.PI * Math.pow(r, <span class="hljs-number">2</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">CheckRadiusFormat</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;半径不能小于0&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> r;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyCylinder.Cylinder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> MyCylinder;  <br>  <br><span class="hljs-keyword">import</span> MyCircle.Circle;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Circle</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> h;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cylinder</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cylinder</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> r, <span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(x, y, r);  <br>        <span class="hljs-built_in">this</span>.h = CheckHeightFormat(h);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Double <span class="hljs-title function_">GetH</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Cylinder <span class="hljs-title function_">SetHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.h = CheckHeightFormat(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Area</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area() * <span class="hljs-number">2</span> + <span class="hljs-built_in">super</span>.GetR() * <span class="hljs-number">2</span> * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">SurfaceArea</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.GetR() * <span class="hljs-number">2</span> * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Volume</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area() * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">BottomArea</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> Double <span class="hljs-title function_">CheckHeightFormat</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;高度不能为0&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> h;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Compute.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> MyCylinder.Cylinder;  <br>  <br><span class="hljs-comment">///程序入口类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compute</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">vecArgs</span> <span class="hljs-operator">=</span> Computer.CheckArgs(args);  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">cylinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cylinder</span>(vecArgs.get(<span class="hljs-number">0</span>),vecArgs.get(<span class="hljs-number">1</span>),vecArgs.get(<span class="hljs-number">2</span>),vecArgs.get(<span class="hljs-number">3</span>));  <br>        System.out.printf(<span class="hljs-string">&quot;%s,高度为%f\n&quot;</span>, FormatCoordinate(cylinder), cylinder.GetH());  <br>        System.out.println(<span class="hljs-string">&quot;表面积是：&quot;</span> + cylinder.SurfaceArea());  <br>        System.out.println(<span class="hljs-string">&quot;体积是：&quot;</span> + cylinder.Volume());  <br>        System.out.println(<span class="hljs-string">&quot;底面积是：&quot;</span> + cylinder.BottomArea());  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">FormatCoordinate</span><span class="hljs-params">(Cylinder cylinder)</span>&#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cylinder.GetX();  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cylinder.GetY();  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cylinder.GetR();  <br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;(%f,%f,%f)&quot;</span>, x,y,r);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Computer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Vector;  <br>  <br><span class="hljs-comment">///测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; <span class="hljs-title function_">CheckArgs</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        <span class="hljs-keyword">if</span>(args.length == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;命令行没有输入，请输入正确的数值&quot;</span>);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">4</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;太少的参数，需要至少四个&quot;</span>);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">4</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;太多的参数，需要至多四个&quot;</span>);  <br>        &#125;  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">vec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Integer&gt;();  <br>  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">for</span>(String element : args)&#123;  <br>                vec.add(Integer.parseInt(element));  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">return</span> vec;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><strong>输入参数 5 6 3 7</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">(5.000000,6.000000,3.000000),高度为7.000000<br>表面积是：42.0<br>体积是：197.92033717615698<br>底面积是：28.274333882308138<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java-example</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell类型类</title>
    <link href="/2023/11/14/haskell-typeclas/"/>
    <url>/2023/11/14/haskell-typeclas/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell的类型类"><a href="#Haskell的类型类" class="headerlink" title="Haskell的类型类"></a>Haskell的类型类</h1><p>类型类(<code>typeclass</code>)是定义行为的接口。类似于其他语言中的<code>interface</code>，比如C++的抽象接口类。如果一个类型是某类型类的实例(instance)，那么他必须实现该类型定义的行为。<strong>千万不要将Haskell的类型类与面向对象语言中的类Class搞混淆</strong></p><p>假设定义类一个类型类（接口）名字叫做吃饭，然后又定义了鸟、人、鱼作为吃饭类型类的实例，那么鸟、人、鱼类就需要实现怎么吃饭这个行为。如果用C++的语言表达，可能是需要创建一个类，在里面声明了一个抽象函数(<code>virtual void eat() = 0</code>), 其他的类继承了这个类，那么必须要实现它。<br><em><strong>不过个人觉得，这个思想的方法，Rust中的trait似乎更贴切一点。</strong></em></p><p>使用<code>:t (==)</code> 查看 &#x3D;&#x3D; 在Haskell中的函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t (==)<br>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool<br><br>ghci&gt; :t (+)<br>(+) :: Num a =&gt; a -&gt; a -&gt; a<br></code></pre></td></tr></table></figure><p>这里出现了一个新的符号 &#x3D;&gt; (实际在上篇文章中使用到了)，它的左侧叫做类型约束，这里的 &#x3D;&#x3D; 和 + 分别约束了使用 Eq和Num两个类。</p><h2 id="Eq-类型类"><a href="#Eq-类型类" class="headerlink" title="Eq 类型类"></a>Eq 类型类</h2><p>用于判断相等性的类型，Eq类定义了等式(&#x3D;&#x3D;)和不等式(&#x2F;&#x3D;)。由Prelude导出的所有基本数据类型都是Eq的实例，并且Eq可以为其成分也是Eq实例的任何数据类型派生。 Haskell官方没有定义Eq一定要实现什么。 然而，&#x3D;&#x3D;通常期望实现等价关系，其中两个比较相等的值通过“公共”函数无法区分，“公共”函数是不允许查看实现细节的函数。 例如，对于表示非规范化自然数模100的类型，“公共”函数不会在1和201之间产生差异。</p><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell">(==) | (/=)<br></code></pre></td></tr></table></figure><h2 id="Ord-类型类"><a href="#Ord-类型类" class="headerlink" title="Ord 类型类"></a>Ord 类型类</h2><p>Ord 类用于可比较大小的类型。 Ord的实例可以为任何组成类型为Ord的用户定义数据类型派生。数据声明中构造函数的声明顺序决定派生Ord实例的顺序。Ordering数据类型允许一次比较来确定两个对象的精确排序。<br>和Eq类似，取两个参数，返回一个Bool类型的值，用来表示是否满足对应的比较关系</p><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">compare</span> | (&lt;=)<br></code></pre></td></tr></table></figure><h2 id="Show-类型类"><a href="#Show-类型类" class="headerlink" title="Show 类型类"></a>Show 类型类</h2><p>将值转换为可读字符串。</p><p>Show的派生实例具有以下属性，它们与Read的派生实例兼容:</p><ul><li>show的结果是一个语法正确的Haskell表达式，只包含常量，只要在声明类型时有效地声明了固定性。它只包含在数据类型、括号和空格中定义的构造函数名称。当使用带标签的构造函数字段时，还会使用大括号、逗号、字段名和等号。</li><li>如果构造函数被定义为中缀操作符，那么showsPrec将生成构造函数的中缀应用。</li><li>如果x中的顶级构造函数的优先级小于d(忽略结合性)，则表示将被括在括号中。因此，如果d为0，则结果永远不会被括号包围;如果d是11，则它总是用圆括号括起来，除非它是原子表达式。</li><li>如果构造函数是使用记录语法定义的，那么show将生成记录语法表单，其中字段的顺序与原始声明的顺序相同。</li></ul><p>除函数以外的所有类型都是SHow的实例，可以使用show函数将值转换为字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; <span class="hljs-built_in">read</span> 3<br><span class="hljs-string">&quot;3&quot;</span><br><br>ghci&gt; <span class="hljs-built_in">read</span> 5.334<br><span class="hljs-string">&quot;5.334&quot;</span><br><br>ghci&gt; <span class="hljs-built_in">read</span> True<br><span class="hljs-string">&quot;True&quot;</span><br></code></pre></td></tr></table></figure><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">showsPrec</span> | show<br></code></pre></td></tr></table></figure><h2 id="Read-类型类"><a href="#Read-类型类" class="headerlink" title="Read 类型类"></a>Read 类型类</h2><p>解析字符串，生成值。</p><p>Read的派生实例做出以下假设，这些假设派生了Show obey的实例:</p><ul><li>如果构造函数被定义为中缀操作符，那么派生的Read实例将只解析构造函数的中缀应用程序(而不是前缀形式)。</li><li>结合性不用于减少括号的出现，尽管可以使用优先级。</li><li>如果构造函数是使用记录语法定义的，则派生的Read将只解析记录语法形式，而且，字段必须按照与原始声明相同的顺序给出。</li><li>派生的Read实例允许在输入字符串的令牌之间使用任意的Haskell空白。还允许使用额外的括号。</li></ul><p>Read可以看做Show相反的类型类，之前提到的所有类都是Read类型，read函数可以去一个字符串作为参数并转为Read的某个实例的类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci &gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;True&quot;</span> || False<br>True<br><br>ghci &gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;8.2&quot;</span> + 3.8<br>12.0<br></code></pre></td></tr></table></figure><p>如果尝试使用<code>read &quot;4&quot;</code>来得到生成一个数字4的效果，那么这是不可能的，会得到一个大大的报错。因为GHCI并不能准确知道到底要个什么玩意来满足屏幕面前的你<br>所以如果在没有一个表达式的情况下，或者说最好给read转换增加一个显示的类型注解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; <span class="hljs-string">&quot;5&quot;</span> :: Int<br>5<br><br>ghci&gt; <span class="hljs-string">&quot;5&quot;</span> :: Float<br>5.0<br></code></pre></td></tr></table></figure><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">readsPrec</span> | readPrec<br></code></pre></td></tr></table></figure><h2 id="Enum-类型类"><a href="#Enum-类型类" class="headerlink" title="Enum 类型类"></a>Enum 类型类</h2><p>Enum的实例对象都是可连续的（枚举），每一个值都有相应的后继和前驱，分别可以通过<code>succ</code>和<code>pred</code>得到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;e&#x27;</span>]<br><span class="hljs-string">&quot;abcde&quot;</span><br><br>ghci&gt; succ <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-string">&#x27;C&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Bounded-类型类"><a href="#Bounded-类型类" class="headerlink" title="Bounded 类型类"></a>Bounded 类型类</h2><p>类型存在一个上限和下限，分别可以通过maxBound和minBound两个函数获得</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; minBound ::Int<br>-9223372036854775808<br><br>ghci&gt; maxBound ::Char<br><span class="hljs-string">&#x27;\1114111&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Num-类型类"><a href="#Num-类型类" class="headerlink" title="Num 类型类"></a>Num 类型类</h2><p>表示一个数值的类型类，它的实例都具有数的特征。<br>只有具有Show和Eq的实例类型，才可以成为Num类型类的实例</p><h2 id="Floating-类型类"><a href="#Floating-类型类" class="headerlink" title="Floating 类型类"></a>Floating 类型类</h2><p>包含Float和Double两种浮点类型，用于存储浮点数。<br>使用Floating类型类的实例类型作为参数或者返回类型的函数，一般需要用到浮点数进行某种计算</p><h2 id="Integral-类型类"><a href="#Integral-类型类" class="headerlink" title="Integral 类型类"></a>Integral 类型类</h2><p>另一种表示数值的类型类。Num类型类包含了实数和整数相关的所有类型，Integral只包含了整数。</p><p>详细的对于类型类的介绍可以参考以下官方文档链接：<br><a href="https://hackage.haskell.org/package/ghc-prim-0.7.0/docs/GHC-Classes.html">https://hackage.haskell.org/package/ghc-prim-0.7.0/docs/GHC-Classes.html</a><br><a href="https://hackage.haskell.org/package/base-4.15.1.0/docs/GHC-Show.html#t:Show">https://hackage.haskell.org/package/base-4.15.1.0/docs/GHC-Show.html#t:Show</a><br><a href="https://hackage.haskell.org/package/base-4.15.1.0/docs/Text-Read.html#v:Read">https://hackage.haskell.org/package/base-4.15.1.0/docs/Text-Read.html#v:Read</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell中的类型</title>
    <link href="/2023/11/13/haskell-type/"/>
    <url>/2023/11/13/haskell-type/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell中的类型"><a href="#Haskell中的类型" class="headerlink" title="Haskell中的类型"></a>Haskell中的类型</h1><p>在Haskell中，每个表达式都会在编译时得到明确的类型，从而提高代码的安全性。当然这样就会导致在输入不同的类型进行某些操作时候得到编译捕获错误<br>这自然好过在运行时出现崩溃，然后自己去逐个排查是什么问题。<strong>Haskell中一切皆有类型，因此编译器在编译期间可以得到更多的消息来检查错误</strong></p><p>在<code>ghci</code>中可以使用<code>:t</code>命令，后接任何合法表达式查阅其类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-string">&#x27;a&#x27;</span> :: Char<br><br>ghci&gt; :t <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-string">&quot;a&quot;</span> :: String<br><br>ghci&gt; :t True<br>True :: Bool<br><br>ghci&gt; :t <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-string">&quot;Hello&quot;</span> :: String<br><br>ghci&gt; :t (True,<span class="hljs-string">&#x27;a&#x27;</span>)<br>(True,<span class="hljs-string">&#x27;a&#x27;</span>) :: (Bool, Char)<br><br>ghci&gt; :t 123<br>123 :: Num p =&gt; p<br><br>ghci&gt; :t 5 == 3<br>5 == 3 :: Bool<br></code></pre></td></tr></table></figure><hr><p><strong>有一个好习惯是在编写函数时，显示写出函数的类型</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">removeNonUpperCase</span> :: [<span class="hljs-type">Char</span>] -&gt; [<span class="hljs-type">Char</span>]<br><span class="hljs-title">removeNonUpperCase</span> st = [ c | c &lt;- st, c `elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]]<br><br><span class="hljs-title">addThree</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">addThree</span> x y z = x + y + z<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Trust type&quot;</span><br>    print (removeNonUpperCase <span class="hljs-string">&quot;abcDEF&quot;</span>)<br>    print (addThree <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>在这里 :: 读作“它的类型为”，凡是确定的类型，首字母一定是大写的。在这里<code>removeNonUpperCase</code>的类型是<code>[Char] -&gt; [Char]</code>。<br>也就是说接受一个<code>[char]</code>类型作为输入参数，返回一个<code>[char]</code>类型作为输出。在《Haskell趣学指南》中，可能是因为年代原因还有版本原因，字符串输出的<br>结果是<code>[char]</code>而在本人目前这个版本(GHCI 9.0.2) 字符串的类型已经是 <code>String</code>了</p><blockquote><p>String :: *</p><p>Defined in ‘GHC.Base’ (base-4.15.1.0)</p><p>A String is a list of characters. String constants in Haskell are values of type String .</p><p>See Data.List for operations on lists.*</p></blockquote><h2 id="Haskell中常见的类型"><a href="#Haskell中常见的类型" class="headerlink" title="Haskell中常见的类型"></a>Haskell中常见的类型</h2><p>常见的基本类型用于表示数，字符，布尔值的类型</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul><li>Int: 整数类型， Int是有界的也可以称作是有符号类型，它的上下限取决于CPU。假设是64位的CPU，它的范围就是 -2^(64-1) ~ 2^(64-1)-1</li><li>Integer: 无符号整数类型， 可以存非常非常大的一个正整数，但是效率不如Int (详见计算机编码的内容)</li><li>Float: 单精度浮点类型</li><li>Double: 双精度浮点类型。精度是Float的两倍，这也意味着占用更大的空间。</li></ul><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ul><li>Char: 表示一个Unicode字符，一个字符由单引号括起</li><li>[Char]: 字符列表，可以当作字符串使用</li><li>String: 字符串类型</li></ul><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型:"></a>布尔类型:</h3><ul><li>Bool: 布尔类型，True和False</li></ul><hr><h2 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h2><p>有一些函数可能需要处理多个类型，或者说多个类型都需要用这个函数进行处理。如果用函数式编程的思想考虑，那么说一个函数的功能可以处理多个类型的参数，这<br>更为贴切一点。比如 head, tail, min, max他们都可以处理多种类型。好奇心一下子就上来了，那么这些函数的类型是什么呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t <span class="hljs-built_in">head</span><br><span class="hljs-built_in">head</span> :: [a] -&gt; a<br><br>ghci&gt; :t min<br>min :: Ord a =&gt; a -&gt; a -&gt; a<br><br>ghci&gt; :t <span class="hljs-built_in">tail</span><br><span class="hljs-built_in">tail</span> :: [a] -&gt; [a]<br></code></pre></td></tr></table></figure><p>我们知道大写开头的才是一个类型，那么这个必不是一个类型，这其实是个类型变量(type variable)，也就会a可以是任何一个类型。作为一个C++老玩家，<br>这一刻觉得这个东西是真得强大，在类型安全的情况下可以简单实现处理多种类型的函数，容易写出通用的函数。</p><p><em>使用了类型变量的函数被称作多态函数(polymorphic function)</em> 我们可以写一个简单的针对于数字的加法函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">plusTwoNumber</span> :: <span class="hljs-type">Num</span> a =&gt; a -&gt; a -&gt; a<br><span class="hljs-title">plusTwoNumber</span> x y = x + y<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (plusTwoNumber <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>这里和C++的template模板以及auto比较一下（我个人还是非常喜欢C++的，现在新版的类型推导也是很好用，模板就有点小麻烦了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//类型推导方式</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//模板方式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Number = std::is_integral_v&lt;T&gt; || std::is_abstract_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;Number T&gt;<br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单玩一下元组</title>
    <link href="/2023/11/12/haskell-tuple/"/>
    <url>/2023/11/12/haskell-tuple/</url>
    
    <content type="html"><![CDATA[<h1 id="简单玩一下元组"><a href="#简单玩一下元组" class="headerlink" title="简单玩一下元组"></a>简单玩一下元组</h1><p>有意思的是Haskell中的元组，不仅如同Python中一样可以随便放东西，而且可以当作结构体用<br>如果元组有里面只有两个元素，就可以当作键值对用，真不错啊真不错~</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">numberAndNumber</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br><span class="hljs-title">triples</span> = [(a,b,c) | a &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], b &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br><span class="hljs-title">rightTriangles</span> = [(a,b,c) | c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], a &lt;- [<span class="hljs-number">1</span>..c], b &lt;- [<span class="hljs-number">1</span>..a], a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> == c^<span class="hljs-number">2</span>]<br><span class="hljs-title">someItem</span> = (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;HelloWorld&quot;</span>, <span class="hljs-type">True</span>)<br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Hello, tuple!&quot;</span><br>    print numberAndNumber<br>    print someItem<br>    <span class="hljs-comment">--对于序队可使用</span><br>    print (fst numberAndNumber)<br>    print (snd numberAndNumber)<br><br>    <span class="hljs-comment">--创建序对</span><br>    print (zip [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], odd x] [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>])<br>    print (zip [<span class="hljs-number">1</span>..] [<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;Java&quot;</span>])<br><br>    <span class="hljs-comment">-- 打印0~10之类边长的三角形</span><br>    print rightTriangles<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅学一下Haskell中的列表</title>
    <link href="/2023/11/11/haskell-list/"/>
    <url>/2023/11/11/haskell-list/</url>
    
    <content type="html"><![CDATA[<h1 id="浅学一下Haskell中的列表"><a href="#浅学一下Haskell中的列表" class="headerlink" title="浅学一下Haskell中的列表"></a>浅学一下Haskell中的列表</h1><blockquote><p>在 Haskell 中，List 就像现实世界中的购物单一样重要。它是最常用的资料结构，并且十分强大，灵活地使用它可以解决很多问题。<br>Haskell中的列表是一种用来存储相同类型的元素的数据结构。列表可以用方括号和逗号来构造，例如[1, 2, 3]是一个包含三个整数的列表。<br>列表也可以用冒号操作符来构造，冒号操作符可以将一个元素添加到一个已有的列表的开头，例如1:[2, 3]等价于[1, 2, 3]。<br>列表还可以用范围来构造，<br>例如[1…10]是一个包含1到10的自然数的列表。列表的长度可以用length函数来计算，列表的元素可以用索引来访问，<br>例如[1, 2, 3] !! 0返回1，[1, 2, 3] !! 1返回2，以此类推。列表还有很多其他的操作，例如拼接，反转，排序，过滤，映射，折叠等。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">odd_numbers</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]<br><span class="hljs-title">even_numbers</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><span class="hljs-title">number_list</span> = [odd_numbers, even_numbers]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (odd_numbers ++ even_numbers) <span class="hljs-comment">--拼接两个列表</span><br>    print (<span class="hljs-string">&quot;Hello&quot;</span> ++ <span class="hljs-string">&quot; &quot;</span> ++ <span class="hljs-string">&quot;world!&quot;</span>) <span class="hljs-comment">--拼接两个字符串</span><br>    print ([<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>] ++ [<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>])<br>    print (number_list)<br>    <br>    <span class="hljs-comment">-- 不可以这样拼接，这是一个列表和一个数字</span><br>    <span class="hljs-comment">-- [1,2,3,4,5] ++ [5]    </span><br><br>    print ( <span class="hljs-number">0</span> : odd_numbers)<br>    print (even_numbers !! <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment">-- 比较列表（会从第一个元素开始比较， 如果相等则比较第二个，直到不同为止）</span><br>    putStrLn <span class="hljs-string">&quot;比较列表&quot;</span><br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &lt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] == [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br><br>    <span class="hljs-comment">-- 更多的列表操作</span><br>    putStrLn <span class="hljs-string">&quot;更多的列表操作&quot;</span><br>    print (head odd_numbers)<br>    print (init odd_numbers)<br>    print (last odd_numbers)<br>    print (tail even_numbers)<br>    <span class="hljs-comment">-- head [] 无法提取空列表</span><br>    print (length odd_numbers)<br>    print (null odd_numbers)<br>    print (reverse odd_numbers)<br>    print (take <span class="hljs-number">3</span> odd_numbers)<br>    print (drop <span class="hljs-number">0</span> odd_numbers)<br>    print (maximum odd_numbers)<br>    print (minimum even_numbers)<br>    print (sum odd_numbers)<br>    print (product odd_numbers)<br>    print (elem <span class="hljs-number">3</span> odd_numbers)<br>    print (elem <span class="hljs-number">3</span> even_numbers)<br><br>    <span class="hljs-comment">-- 列表区间</span><br>    putStrLn <span class="hljs-string">&quot;列表区间&quot;</span><br>    print [<span class="hljs-number">1</span>..<span class="hljs-number">20</span>]<br>    print [<span class="hljs-string">&#x27;a&#x27;</span> .. <span class="hljs-string">&#x27;z&#x27;</span>]<br>    print [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..<span class="hljs-number">20</span>]<br>    print (take <span class="hljs-number">10</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..])<br>    print (take <span class="hljs-number">10</span> (cycle [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br>    print (take <span class="hljs-number">10</span> (repeat <span class="hljs-number">2</span>))<br>    print (replicate <span class="hljs-number">3</span> <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">-- 列表推导式</span><br>    putStrLn <span class="hljs-string">&quot;列表推导式&quot;</span><br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], x*<span class="hljs-number">10</span> &lt;= <span class="hljs-number">50</span>, even x]<br>    <span class="hljs-comment">-- 取1～100中可以被3整出的数</span><br>    print [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>], x `mod` <span class="hljs-number">3</span> == <span class="hljs-number">0</span>]<br>    <span class="hljs-comment">-- 根据number_list中的数，返回是odd还是even</span><br>    print ([ <span class="hljs-keyword">if</span> ((x `mod` <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> ) <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;even&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;odd&quot;</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]])<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs bash">[2,4,6,8,10,1,3,5,7,9]<br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br>[[2,4,6,8,10],[1,3,5,7,9]]<br><br>[0,2,4,6,8,10]<br><br>7<br><br>比较列表<br><br>True<br><br>True<br><br>True<br><br>True<br><br>True<br><br>更多的列表操作<br><br>2<br><br>[2,4,6,8]<br><br>10<br><br>[3,5,7,9]<br><br>5<br><br>False<br><br>[10,8,6,4,2]<br><br>[2,4,6]<br><br>[2,4,6,8,10]<br><br>10<br><br>1<br><br>30<br><br>3840<br><br>False<br><br>True<br><br>列表区间<br><br>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]<br><br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[1,2,3,1,2,3,1,2,3,1]<br><br>[2,2,2,2,2,2,2,2,2,2]<br><br>[10,10,10]<br><br>列表推导式<br><br>[10,20,30,40,50,60,70,80,90,100]<br><br>[20,40]<br><br>[3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99]<br><br>[<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好呀 Haskell</title>
    <link href="/2023/11/10/hello-haskell/"/>
    <url>/2023/11/10/hello-haskell/</url>
    
    <content type="html"><![CDATA[<h1 id="你好呀Haskell"><a href="#你好呀Haskell" class="headerlink" title="你好呀Haskell"></a>你好呀Haskell</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>开始玩耍一个新的编程语言:Haskell, 其实很早就准备学习这个语言，而且也在官网上看了一小段教程，但是有一种云里雾里的感觉，不是没有学懂他的语法，而是还没有理解他的思想，所以一直拖到现在。</p><p>直到在上了大学物理这门课程。感谢岳老师的物理课，虽然我的物理学的并不好，但是对于看待事务本身多了一个新的角度。</p><p>对于之前学习C++,C#, Java…还有别的语言，在解决问题方面更像是在解释这个问题应该怎么做。即使是说使用了面向对象、多态、继承、封装、抽象、接口、泛型、多线程、异常等等，但依然更像是描述这个问题应该怎么做，所以这类语言也成为命令式语言。在命令式语言中执行操作需要给电脑安排一组指令, 随着命令的执行，状态会随之发生改变。</p><p>然而在纯函数式编程语言中，不再是像命令式语言那样描述要做什么，而是通过函数描述问题“是什么”。</p><p>有一个简单的例子说， 在函数式编程语言中，变量一旦赋值，就不能改了，比如  <code>x = 5</code> 这里已规定好了，x的值是5，那么在函数式编程语言中，变量x的值就是5，不能被改变。</p><h2 id="简单的运算"><a href="#简单的运算" class="headerlink" title="简单的运算"></a>简单的运算</h2><blockquote><p><strong>simple-calc.hs</strong></p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">plus</span> x y = x + y<br><span class="hljs-title">substract</span> x y = x - y<br><span class="hljs-title">multiply</span> x y = x * y<br><span class="hljs-title">divide</span> x y = x / y<br><br><span class="hljs-title">and_gate</span> x y = x &amp;&amp; y<br><span class="hljs-title">or_gate</span> x y = x || y<br><span class="hljs-title">not_gate</span> x = not x<br><br><span class="hljs-title">is_equal</span> x y = x == y<br><span class="hljs-title">is_bigger</span> x y = x &gt; y<br><span class="hljs-title">is_smaller</span> x y = x &lt; y<br><span class="hljs-title">is_odd</span> x = mod x <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-title">double_value</span> x = x * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>测试运行</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ghci simple-calc.hs<br><span class="hljs-comment">#GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help</span><br><span class="hljs-comment">#[1 of 1] Compiling Main             ( simple-calc.hs, interpreted )</span><br><span class="hljs-comment">#Ok, one module loaded.</span><br><br>ghci&gt; plus 2 4<br>6<br>ghci&gt; or_gate True False<br>True<br>ghci&gt; double_value 5<br>10<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>小小解释</strong></p></blockquote><p>定义函数: functionName args &#x3D; expression</p><p>执行函数: functionName args </p><p>如果一个函数有两个参数，也可以用这样的方法调用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-number">4</span> `mod` <span class="hljs-number">2</span><br><span class="hljs-title">mod</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> #两者相当<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视C++为一个语言联邦</title>
    <link href="/2023/11/09/view-cpp-as-a-federation/"/>
    <url>/2023/11/09/view-cpp-as-a-federation/</url>
    
    <content type="html"><![CDATA[<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><p><small>View C++ as a federation of languages</small></p><blockquote><p>一开始，C++只是C加上一些面向对象特性。 C++ 最初的名称 C with Classes 也反应来这个血缘关系 (Effective C++)</p></blockquote><hr><p>随着C++的不断发展，C++的特性越来越多，甚至有些特性是C++独有的。 学了有一段时间的C++， 向他人请教过C++的技巧，也教过人怎么学习C++。 语法以及技巧不是很难去教授的，但是有一段时间令我头疼的是，如何对新手做一个C++的介绍。 因为C++的特性太多， 而且C++的特性之间又存在一定的联系， 导致很难对一个新手进行一个系统的学习。</p><p>直到有一天我再次翻开《Effective C++ 改善程序的55个做法》， 而条款01就是”视C++为一个语言联邦“<br>可以说，C++其实是一个联邦， 联邦由若干个语言组成， 每个语言都具有自己的特性， 这些特性又相互关联。今天的C++是个多重范式的编程语言， 它同时具有面向过程、面向对象、泛型编程、模板、异常处理、标准库、标准模板库等特性。</p><h2 id="语言联邦"><a href="#语言联邦" class="headerlink" title="语言联邦"></a>语言联邦</h2><blockquote><ol><li>Base C language</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ol></blockquote><h3 id="Base-C-language"><a href="#Base-C-language" class="headerlink" title="Base C language"></a>Base C language</h3><p>说到底，C++可以理解是一个C语言的超集， 它包含了C语言的所有特性， 并且还增加了面向对象、泛型编程、异常处理、标准库、标准。许多时候一个问题的C++解法， 往往可以由C语言的解法推导而来，也可以说是较为高级、较为抽象的C语言的解法。</p><h3 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h3><p>C++语言是面向对象的， 它包含了一些面向对象的特性， 例如： 类、对象、继承、多态、虚函数。<br>这部分也就是C with classes所诉求的， 它也被称为OO C++： classes, inheritance, and polymorphism.</p><h3 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h3><p>C++的模板特性， 使得C++可以进行泛型编程， 它使得C++可以进行泛型编程。不严谨的说，模板能够批量生成大量功能相似，但是有些许不同的代码。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL是C++标准模板库， 它提供了一组通用的、可复用的算法和数据结构， 例如： 容器、迭代器、算法、函数对象、适配器、分配器、流、字符串、数值等。然而STL有自己独特的办事方式，当你同STL一同工作，你必须遵守他的约定。</p><p>在编程时候， 这些语言联邦中的特性相互之间是相互独立的， 它们之间可以相互组合， 也可以相互分离。 例如，你可以只使用C语言特性完成某些事情，或者在一个类中自己封装一个STL容器， 或者使用STL容器完成一些C++特性。</p><blockquote><p>当你从某个次语言切换到另一个时，导致高效编程守则编程守则要求你改变策略时，不要感到惊讶。因此说C++并不是一个一组带有一组守则一体的语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。<br><strong>C++高效编程守则视状况而变化，取决于你使用C++的哪一个部分</strong></p></blockquote><h2 id="学习C-的流程"><a href="#学习C-的流程" class="headerlink" title="学习C++的流程"></a>学习C++的流程</h2><p>所以说，学习C++本体或许并不一定要掌握C语言，“不必是一个火箭科学家”， 只需要掌握C++的特性， 就可以写出一些有趣的代码。<br>之后在针对C++的特性进行学习， 例如： 模板、STL、异常处理等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Modern-cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>来做一个猜数游戏吧</title>
    <link href="/2023/11/09/guessing-number/"/>
    <url>/2023/11/09/guessing-number/</url>
    
    <content type="html"><![CDATA[<h1 id="一个猜数小游戏"><a href="#一个猜数小游戏" class="headerlink" title="一个猜数小游戏"></a>一个猜数小游戏</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>首先尝试接受用户的一个输入数字</li><li>生成一个随机数</li><li>进入游戏循环主体中<ol><li>输入数字大于随机数：输出大了，循环继续</li><li>输入数字小于随机数：输入小了，循环继续</li><li>输入数字等于随机数：猜对了，退出循环</li></ol></li><li>结束程序</li></ol><h2 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// Create random number generator</span><br>    std::random_device random_device;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">generator</span><span class="hljs-params">(random_device())</span></span>;<br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distribution</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> random_number = <span class="hljs-built_in">distribution</span>(generator);<br>    std::cout &lt;&lt; random_number &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// Create variable to store user&#x27;s guess</span><br>    <span class="hljs-type">int</span> guessing_number&#123;&#125;;<br><br>    <span class="hljs-comment">// Create loop to allow user to guess the random number</span><br>    <span class="hljs-keyword">while</span>(guessing_number != random_number)&#123;<br>        std::cin &gt;&gt; guessing_number;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Guessing number: &quot;</span> &lt;&lt; guessing_number &lt;&lt; std::endl;<br>        <span class="hljs-keyword">if</span>(guessing_number &gt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too high&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guessing_number &lt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too low&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;You got it!&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="随机数引擎"><a href="#随机数引擎" class="headerlink" title="随机数引擎"></a>随机数引擎</h3><p><strong>要在C++中使用<random>库生成一个随机数，请按照以下步骤操作：</strong></p><ol><li><p>首先，确保已经包含了<code>&lt;random&gt;</code>头文件。在文件的开头添加以下代码：<code>#include &lt;random&gt;</code></p></li><li><p>接下来，创建一个<code>std::random_device</code>对象，用于生成随机种子。这可以确保每次运行程序时生成的随机数不同。<br><code>std::random_device rd;</code></p></li><li><p>使用<code>std::seed</code>函数，将random_device对象生成的随机种子用于初始化std::mt19937随机数生成器。<br><code>std::mt19937 gen(rd());</code></p></li><li><p>使用<code>std::uniform_int_distribution</code>对象，指定随机数的范围。例如，要生成0到100之间的随机数，可以使用以下代码：<br><code>std::uniform_int_distribution&lt;&gt; distrib(0, 100);</code></p></li><li><p>使用distrib对象生成随机数，并将其存储在变量中。<br><code>const auto random_number = distrib(gen);</code></p></li></ol><p><code>std::mt19937</code>是一个Mersenne Twister伪随机数生成器，它是C++标准库中的一个均匀分布随机数生成器。Mersenne Twister是一种广泛使用的随机数生成器，其性能和分布非常广泛，因此在许多应用中都被广泛使用。</p><p><code>std::mt19937</code>的构造函数接受一个random_device对象作为参数，该对象用于生成随机种子。通过使用random_device，可以确保每次运行程序时生成的随机数不同。</p><p><code>std::mt19937</code>生成的随机数服从均匀分布，即在指定的区间内等概率地取值。</p><h3 id="const-和-auto"><a href="#const-和-auto" class="headerlink" title="const 和 auto"></a>const 和 auto</h3><p>const 关键字用于声明常量，即在程序运行期间其值不能被修改的量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>a = <span class="hljs-number">6</span> <span class="hljs-comment">// 错误，不能修改常量的值</span><br></code></pre></td></tr></table></figure><p>auto 关键字用于声明自动类型变量，即编译器会根据初始值自动推断出变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-comment">//声明一个int类型的a,并且定义值为5</span><br><span class="hljs-keyword">auto</span> b = a; <span class="hljs-comment">// b的类型和a一样，都是int类型</span><br>b = <span class="hljs-number">7</span>;  <span class="hljs-comment">//正确，可以修改b的值</span><br></code></pre></td></tr></table></figure><h3 id="主体判断框架"><a href="#主体判断框架" class="headerlink" title="主体判断框架"></a>主体判断框架</h3><p>使用while循环，在循环体中判断条件是否成立，如果条件成立，则执行循环体，否则退出循环。<br>用户如果输入错误数值，那么就一直循环，直到输入正确为止。<br>用户输入正确，那么就会通过break跳出循环。</p><h3 id="整体解释"><a href="#整体解释" class="headerlink" title="整体解释"></a>整体解释</h3><ol><li>引入所需的头文件，包括<random>（用于随机数生成器）和<iostream>（用于输入输出）。</li><li>在main函数中，定义一个random_device对象，用于生成随机种子。</li><li>定义一个std::mt19937对象，作为随机数生成器，并将random_device对象作为参数传递。</li><li>定义一个std::uniform_int_distribution对象，用于生成1到100之间的随机整数。</li><li>使用distribution对象生成一个随机整数，并将其存储在random_number变量中。</li><li>使用std::cout输出随机数。</li><li>定义一个guessing_number变量，用于存储用户输入的数字。</li><li>使用一个while循环，直到用户猜对数字为止。</li><li>在循环中，使用std::cin从用户输入一个数字，并将其存储在guessing_number变量中。</li><li>使用std::cout输出用户输入的数字。</li><li>如果guessing_number大于random_number，则输出“Too high”。</li><li>如果guessing_number小于random_number，则输出“Too low”。</li><li>如果guessing_number等于random_number，则输出“You got it!”并跳出循环。</li><li>最后，return 0表示程序正常退出。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows上mingw C/C++环境搭建</title>
    <link href="/2022/12/11/Tips-mingw/"/>
    <url>/2022/12/11/Tips-mingw/</url>
    
    <content type="html"><![CDATA[<h1 id="MSYS2和CMake搭建C-x2F-C-环境-参考指南"><a href="#MSYS2和CMake搭建C-x2F-C-环境-参考指南" class="headerlink" title="MSYS2和CMake搭建C&#x2F;C++环境 参考指南"></a>MSYS2和CMake搭建C&#x2F;C++环境 参考指南</h1><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a><strong>准备材料</strong></h2><ul><li>MSYS2 <a href="https://www.msys2.org/">msys2.org</a></li><li>CMake <a href="https://cmake.org/download/">cmake.org</a></li></ul><hr><h2 id="如何下载"><a href="#如何下载" class="headerlink" title="如何下载"></a>如何下载</h2><p><img src="/img/Tips-mingw/1.png" alt="1.png"></p><center><small>点击即可下载，之后莽点下一步即可安装</small></center><p><img src="/img/Tips-mingw/2.png" alt="2.png"></p><center><small>根据系统架构选择对应的版本下载，之后双击安装即可</small></center><hr><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ol><li>打开安装的MSYS2 MSYS， 更换软件源 (选择任意即可)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tuna mirror 清华软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br><span class="hljs-comment"># ustc mirror 中科大软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.ustc.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br></code></pre></td></tr></table></figure></li></ol><p><img src="/img/Tips-mingw/3.png" alt="3.png"></p><p><img src="/img/Tips-mingw/4.png" alt="4.png"></p><ol start="2"><li>更新一下软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Syyu<br></code></pre></td></tr></table></figure>遇到 :: Proceed with installation? [Y&#x2F;n] 的类似问题时输入y即可</li></ol><p><img src="/img/Tips-mingw/5.png" alt="5.png"></p><ol start="3"><li>安装mingw<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S base-devel <br>pacman -S mingw-w64-x86_64-toolchain<br><br></code></pre></td></tr></table></figure>Enter a selection (default&#x3D;all): 输入回车即可<br><img src="/img/Tips-mingw/6.png" alt="6.png"></li></ol><p><strong>4. 配置系统环境</strong></p><p>找到安装目录的mingw64路径<br><img src="/img/Tips-mingw/7.png" alt="7.png"></p><p>计算机右键属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; path -&gt; 你的路径<br><img src="/img/Tips-mingw/8.png" alt="8.png"><br><img src="/img/Tips-mingw/9.png" alt="9.png"><br><img src="/img/Tips-mingw/10.png" alt="10.png"><br><img src="/img/Tips-mingw/11.png" alt="11.png"></p><h2 id="最后验证"><a href="#最后验证" class="headerlink" title="最后验证"></a>最后验证</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">cmake --version<br>gcc -v<br></code></pre></td></tr></table></figure><p><img src="/img/Tips-mingw/12.png" alt="12.png"></p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>MSYS2 是什么？<br><strong>MSYS2</strong> is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.</p><p>It consists of a command line terminal called <a href="https://mintty.github.io/">mintty</a>, bash, version control systems like git and subversion, tools like tar and awk and even build systems like autotools, all based on a modified version of <a href="https://cygwin.com/">Cygwin</a>. Despite some of these central parts being based on Cygwin, the main focus of MSYS2 is to provide a build environment for native Windows software and the Cygwin-using parts are kept at a minimum. MSYS2 provides up-to-date native builds for GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby, just to name a few.</p><p>To provide easy installation of packages and a way to keep them updated it features a package management system called <a href="https://wiki.archlinux.org/index.php/pacman">Pacman</a>, which should be familiar to Arch Linux users. It brings many powerful features such as dependency resolution and simple complete system upgrades, as well as straight-forward and reproducible package building. Our package repository contains <a href="https://packages.msys2.org/base">more than 2600 pre-built packages</a> ready to install.</p><p>For more details see <a href="https://www.msys2.org/docs/what-is-msys2/">‘What is MSYS2?’</a> which also compares MSYS2 to other software distributions and development environments like <a href="https://cygwin.com/">Cygwin</a>, <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>, <a href="https://chocolatey.org/">Chocolatey</a>, <a href="https://scoop.sh/">Scoop</a>, … and <a href="https://www.msys2.org/docs/who-is-using-msys2/">‘Who Is Using MSYS2?’</a> to see which projects are using MSYS2 and what for.</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">MSYSY2 MSYS</td><td align="left">用来管理和安装包的</td></tr><tr><td align="left">MSYSY2 MinGW 32-bit</td><td align="left">编译32位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MinGW 64-bit</td><td align="left">编译64位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MSYS UCRT 64-bit</td><td align="left">编译64位程序，库链接到ucrt上</td></tr></tbody></table><p>CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tips</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/标记和字符集</title>
    <link href="/2022/08/10/Tokens%20and%20character%20sets/"/>
    <url>/2022/08/10/Tokens%20and%20character%20sets/</url>
    
    <content type="html"><![CDATA[<h1 id="标记和字符集"><a href="#标记和字符集" class="headerlink" title="标记和字符集"></a>标记和字符集</h1><p><small>Tokens and character sets</small></p><p>C++程序文本由Tokens(标记)和空格组成。标记是对编译器有用的 C++ 程序的最小元素。 C++ 分析器可识别以下类型的Token：</p><ul><li>Keywords （关键字）</li><li>Identifiers（标识符）</li><li>Numeric, Boolean and Pointer Literals（数字，布尔值，指针文本）</li><li>String and Character Literals（字符串和字符文本）</li><li>User-Defined Literals（用户定义的文本）</li><li>Operators（运算符&#x2F;操作符）</li><li>Punctuators（标点符号）<blockquote><p><strong>译注：</strong><br>词法分析是编译过程的第一步工作，将字符流转换为单词序列，输出到中间文件中，这个中间文件将会作为语法分析程序的输入，进行下一步工作。<br>token可翻译为标记，是构成源代码的最小单位，从输入字符流中生成标记的过程叫作标记化（ tokenization ），在这个过程中，词法分析器还会对标记进行分类。编译器会从左到右扫描我们的源代码，将其中的字符流分割成一个一个的 token。</p></blockquote></li></ul><h2 id="Token通常用空格进行切分，可以是一个或多个：-空白-水平或垂直制表符-新行-表单源-注释"><a href="#Token通常用空格进行切分，可以是一个或多个：-空白-水平或垂直制表符-新行-表单源-注释" class="headerlink" title="Token通常用空格进行切分，可以是一个或多个：-   空白-   水平或垂直制表符-   新行-   表单源-   注释"></a>Token通常用空格进行切分，可以是一个或多个：<br>-   空白<br>-   水平或垂直制表符<br>-   新行<br>-   表单源<br>-   注释</h2><h2 id="基本源字符集"><a href="#基本源字符集" class="headerlink" title="基本源字符集"></a>基本源字符集</h2><p>C++标准指定了基本源字符集用于源文件中，要表示此集合之外的字符，可以使用通用字符名称指定其他字符。MSVC编译器允许实现其他字符。要表示此集合之外的字符，可以使用通用字符名称指定其他字符。<br><code>a b c d e f g h i j k l m n o p q r s t u v w x y z</code><br><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code><br><code>0 1 2 3 4 5 6 7 8 9</code><br><code>_ &#123; &#125; [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ &quot; &#39;</code></p><p><strong>特用于Microsoft的内容</strong><br>MSVC 包含 $ 字符作为基本源字符集的成员。MSVC 还允许根据文件编码在源文件中使用一组额外的字符。在默认情况下，Visual Studio使用默认代码页存储资源文件。当资源文件使用特定区域或Unicode代码页保存时，MSVC允许你在源代码中使用该代码页的任何字符，但基本源字符集中不允许的控制代码除外。举个例子，您可以通过日文代码页在注释，标识符或字符串中使用日文。MSVC不允许无法转换成为多字节字符和Unicode位码的字符序列。根据编译器选项，并非所有允许的字符都可能出现在标识符中。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a>。</p><blockquote><p><strong>译注</strong><br>在使用visual studio时如果使用WinAPI例如&lt;Windows.h&gt;便可以遇到LPWSTR等字符类型，这是一种宽字符类型也可称作多字节字符。在MSVC中使用L”xxx”即表示用宽字符输出此字符串，也可在项目设置中设置相关配置，设置默认使用宽字符。</p></blockquote><hr><h2 id="通用字符名称"><a href="#通用字符名称" class="headerlink" title="通用字符名称"></a>通用字符名称</h2><p>由于C++程序可以使用比基础字符集更多的字符，您可以使用通用字符名称以可移植的方式指定这些字符。通用字符名称由表示 Unicode 码位的字符序列组成。可以使用两种类型进行表述，使用<code>UNNNNNNNN</code>来代表为 U+NNNNNNNN的unicode位码字符，NNNNNNNN 是八位的十六进制码位数字。使用四位的 <code>\uNNNN</code> 表示形式为 U+0000NNNN 的 Unicode 码位。<br>通用字符名称可用于标识符以及字符串和字符文字。通用字符名称不能被用于表示0xD800-0xDFFF之间之内的代理项码位，编译器会自动生成任何所需的代理项。其他限制适用于可在标识符中使用的通用字符名称。详细信息请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">Identifiers</a> 和 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">String and Character Literals</a>。</p><p><strong>特用于Microsoft的内容</strong><br>Microsoft C++ 编译器可互换地处理通用字符名称形式和文字形式的字符。例如，您可以使用通用字符名称形式声明标识符，并以文字形式使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> \u30AD = <span class="hljs-number">42</span>; <span class="hljs-comment">// \u30AD is &#x27;キ&#x27;</span><br><span class="hljs-keyword">if</span> (キ == <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// \u30AD and キ are the same to the compiler</span><br></code></pre></td></tr></table></figure><p>Windows 剪贴板上的扩展字符的格式特用于应用程序区域设置。 从另一个应用程序剪切这些字符并将其粘贴到你的代码中可能会引入意外的字符编码。 这可能会导致您的代码中出现不知原因的代码错误。我们建议在粘贴扩展的字符之前将源文件编码设置为 Unicode 代码页，以及使用 IME 或字符映射应用生成扩展的字符。</p><hr><h2 id="执行字符集"><a href="#执行字符集" class="headerlink" title="执行字符集"></a>执行字符集</h2><p><em>执行字符集</em> 表示可在编译的程序中显示的字符和字符串。 这些字符集包括源文件中允许的所有字符，以及表示警报、后空、回车符和 null 字符的控制字符。 执行字符集具有特定于区域设置的表示形式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Modern-cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/词法约定</title>
    <link href="/2022/08/10/Lexical-conventions/"/>
    <url>/2022/08/10/Lexical-conventions/</url>
    
    <content type="html"><![CDATA[<h1 id="词法约定"><a href="#词法约定" class="headerlink" title="词法约定"></a>词法约定</h1><p><small>Lexical conventions</small></p><p>本篇章介绍了C++程序中的基本元素。您会使用到称作“词法元素”或者说“标记”的元素构造完整程序的语句、定义和声明等。 本节将讨论以下词法元素：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/character-sets?view=msvc-170">标记和字符集</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/comments-cpp?view=msvc-170">注释</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/keywords-cpp?view=msvc-170">关键字</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/punctuators-cpp?view=msvc-170">标点符号</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/numeric-boolean-and-pointer-literals-cpp?view=msvc-170">数值、布尔和指针文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">字符串和字符文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/user-defined-literals-cpp?view=msvc-170">用户定义的文本</a></li></ul><p>有关如何分析 C++ 源文件的详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/preprocessor/phases-of-translation?view=msvc-170">转换阶段</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern_C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/欢迎回到C++ 现代C++</title>
    <link href="/2022/08/08/Welcome%20back%20to%20C++/"/>
    <url>/2022/08/08/Welcome%20back%20to%20C++/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎回到C-现代C"><a href="#欢迎回到C-现代C" class="headerlink" title="欢迎回到C++ -现代C++"></a>欢迎回到C++ -现代C++</h1><p><small>Welcome back to C++ - Modern C++</small></p><p>自从它被创建，C++逐渐成为世界上使用最广泛的语言之一。正确编写的 C++ 程序快速、高效。 相对于其他语言，该语言更加灵活：它可以在最高抽象级别上工作，也可以在芯片级（硅级别）上工作。C++ 提供高度优化的标准库。它允许访问低级硬件功能，以最大限度地提高速度并最大限度地减少内存需求。C++可以创建继续所有种类的应用：游戏、设备驱动、HPC、云、桌面、嵌入式和移动应用程序等等。甚至其他编程语言的库和编译器也是用 C++ 编写的。<br>C++的一个原始需求是向下兼容C语言。因此，C++总是允许以C风格编程，使用原始指针、数组、以空字符结尾的数组字符串<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class&#x3D;”hint–top hint–rounded” aria-label&#x3D;”及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code>“&gt;[1]</span></a></sup>以及其他功能。这或许能够拥有高效的表现，但也可以出现报错并让程序出现复杂性。C++的发展强调了一些特性，这些特性大大减少了对使用C风格语法的需要。当您需要他们时，旧式C编程工具仍然存在。但是，在现代 C++ 代码中，您应该越来越少地需要它们。现代 C++ 代码更简单、更安全、更优雅，并且仍然和以往一样快。<br>以下部分概述了现代 C++ 的主要特性。除非另有说明，此处列出的功能在 C++11 及更高版本中可用。在 Microsoft C++ 编译器中，您可以设置 &#x2F;std 编译器选项来指定要用于您的项目的标准版本。</p><h2 id="资源和智能指针"><a href="#资源和智能指针" class="headerlink" title="资源和智能指针"></a>资源和智能指针</h2><p><small>Resource and smart pointers</small><br>C风格编程中的一类主要bug是内存泄漏（确实如此，三天写代码，两天找bug）。泄漏通常是由于对使用 new 分配的内存调用 delete 失败引起的。现代 C++ 强调“资源获取即初始化”(RAII) <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="RAII，Resouce Acquisition Is Initialization:资源获取即初始化">[2]</span></a></sup>原则。 其理念很简单。 资源（堆内存、文件句柄、套接字等）应由对象“拥有”。 该对象在其构造函数中创建或接收新分配的资源，并在其析构函数中将此资源删除。 RAII 原则可确保当所属对象超出范围时，所有资源都能正确返回到操作系统。<br>为了支持对简单采用RAII的原则，C++基本库（STL）提供了三个智能指针类型: <code>std::unique_ptr</code>、<code>std::shared_ptr</code>以及<code>std::weak_ptr</code>。智能指针拥有申请和删除内存的控制句柄（智能指针处理它所拥有的内存的分配和删除）<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。">[3]</span></a></sup>。下面的示例演示了一个类，其中包含一个数组成员，该成员是在调用 <code>make_unique()</code> 时在堆上分配的。 对和的 <strong><code>new</code></strong> 调用 <strong><code>delete</code></strong> 由 <code>unique_ptr</code> 类封装。 当 <code>widget</code> 对象超出范围时，将调用 unique_ptr 析构函数，此函数将释放为数组分配的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">widget</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">widget</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> size) &#123; data = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(size); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionUsingWidget</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">widget <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;   <span class="hljs-comment">// lifetime automatically tied to enclosing scope</span><br>                <span class="hljs-comment">// constructs w, including the w.data gadget member</span><br>    <span class="hljs-comment">// ...</span><br>    w.<span class="hljs-built_in">do_something</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-comment">// automatic destruction and deallocation for w and w.data</span><br></code></pre></td></tr></table></figure><p>请尽可能使用智能指针管理堆内存（确实如此，如果没有追求极致效率的需求，使用智能指针是最方便且安全的）。 如果必须 <strong><code>new</code></strong> 显式使用和 <strong><code>delete</code></strong> 运算符，请遵循 RAII 原则。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170">对象生存期和资源管理 (RAII)</a>。</p><h2 id="std-string-和-std-string-view"><a href="#std-string-和-std-string-view" class="headerlink" title="std::string 和 std::string_view"></a>std::string 和 std::string_view</h2><p><small>std::string and std::string_view</small><br>C风格字符串是错误产生的另一个重要来源。通过使用<code>std::string</code> 和 <code>std::wstring</code>，您可以排除几乎所有和C风格字符串有联系的错误。此外，你还可以通过其成员方法获得更多字符串操作上的便利，例如搜索，追加，前缀等。两者都针对速度进行了高度优化<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》">[4]</span></a></sup>。将字符串传递给只需要只读访问权限的函数时，在 C++17 中，您可以使用 std::string_view 以获得更大的性能优势。</p><h2 id="std-vector向量和其他标准库容器"><a href="#std-vector向量和其他标准库容器" class="headerlink" title="std::vector向量和其他标准库容器"></a>std::vector向量和其他标准库容器</h2><p><small>std::string and other Standard Library containers</small><br>标准库容器都遵循 RAII 原则。 它们为安全遍历元素提供迭代器。 此外，它们对性能进行了高度优化，并且已充分测试正确性。 通过使用这些容器，可以消除自定义数据结构中可能引入的 bug 或低效问题。 使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-170"><code>vector</code></a> 替代原始数组，来作为 C++ 中的序列容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; apples;<br>apples.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Granny Smith&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 map（而不是 unordered_map），作为默认关联容器。 对于退化和多案例，使用 set、multimap 和 multiset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string, string&gt; apple_color;<br><span class="hljs-comment">// ...</span><br>apple_color[<span class="hljs-string">&quot;Granny Smith&quot;</span>] = <span class="hljs-string">&quot;Green&quot;</span>;<br></code></pre></td></tr></table></figure><p>需要进行性能优化时，请考虑以下用法：</p><ul><li>例如当重要的数据被嵌入时，将std::array类型作为类成员。</li><li>使用无序的关联容器，例如 unordered_map。 它们的每个元素的开销较低，并且具有固定时间查找功能，但正确高效地使用它们的难度更高。</li><li>使用std::vector时需要排序。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/algorithms?view=msvc-170">算法</a>。<br>不要使用 C 风格的数组。对于需要直接访问数据的旧 API，请使用访问器方法，例如 <code>f(vec.data(), vec.size());</code> 有关容器的更多信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/stl-containers?view=msvc-170">C++ 标准库容器</a>。</li></ul><h2 id="标准库算法"><a href="#标准库算法" class="headerlink" title="标准库算法"></a>标准库算法</h2><p>在假设需要为程序编写自定义算法之前，请首先查阅C++ 标准库中的算法。 标准库包含许多常见操作（如搜索、排序、筛选和随机化）的算法分类，且这些分类的算法库还在不断增加。 譬如&lt;math&gt;中的内容涵盖的很广泛。 自 C++17 起，变提供了许多算法的并行版本。<br>这里列举以下内容，比较重要。</p><ul><li><code>for_each</code>：默认遍历算法（基于范围的 for 循环）。</li><li><code>transform</code>：用于容器元素的非就地修改<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="`std::stransform` 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。">[5]</span></a></sup>。</li><li><code>find_if</code>：默认搜索算法。</li><li><code>sort</code>,<code>lower_bound</code>：排序、在一个范围内找到搜索元素的下标。以及其他排序和搜索算法。</li></ul><p>如果要写一个比较函数，可以使用lambda表达式以及’&lt;’符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> comp = [](<span class="hljs-type">const</span> widget&amp; w1, <span class="hljs-type">const</span> widget&amp; w2)<br>     &#123; <span class="hljs-keyword">return</span> w1.<span class="hljs-built_in">weight</span>() &lt; w2.<span class="hljs-built_in">weight</span>(); &#125;<br><br><span class="hljs-built_in">sort</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), comp );<br><br><span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">lower_bound</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), widget&#123;<span class="hljs-number">0</span>&#125;, comp );<br></code></pre></td></tr></table></figure><h2 id="使用auto关键字代替显示类型名称"><a href="#使用auto关键字代替显示类型名称" class="headerlink" title="使用auto关键字代替显示类型名称"></a>使用auto关键字代替显示类型名称</h2><p><small>auto instread of explicit type names</small><br>C++11引入了auto关键字，以便在变量、函数和模板的声明。auto关键字会指示编译器推导对象的类型，这样您即可无需显示键入。当对象是嵌套模板时，使用auto进行声明尤其有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;<span class="hljs-type">int</span>,list&lt;string&gt;&gt;::iterator i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// C-style</span><br><span class="hljs-keyword">auto</span> i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// modern C++</span><br></code></pre></td></tr></table></figure><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p><small>Range-based for loops</small><br>对数组和容器的C风格迭代容易出现索引错误，且重复的键入过程单调乏味。要消除这些错误并使您的代码更具可读性，请使用基于范围的 for 循环以及标准库容器和原始数组。有关详细信息，请参阅请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170">基于范围的</a> (<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)%E8%AF%AD%E5%8F%A5%E3%80%82">https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)语句。</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// C-style</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>        std::cout &lt;&lt; v[i];<br>    &#125;<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : v)&#123;<br>        std::cout &lt;&lt; num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>译注：<br>使用for_each虽然可以极大的提高for效率，但是如果在处理极大数据时或极长文本时请谨慎使用。因为其会将内容复制一份进行遍历。</p><h2 id="用-constexpr-表达式替代宏"><a href="#用-constexpr-表达式替代宏" class="headerlink" title="用 constexpr 表达式替代宏"></a>用 <code>constexpr</code> 表达式替代宏</h2><p>C 和 C++ 中的宏是在编译前由预处理器处理的一种标记。在编译代码之前，编译器会将使用宏定义的地方替换成宏所定义的值。C 样式编程通常使用宏来定义编译时常量值。 但宏容易出错且难以调试。 在现代 C++ 中，应优先使用 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/constexpr-cpp?view=msvc-170"><code>constexpr</code></a> 变量定义编译时常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 10 <span class="hljs-comment">// C-style</span></span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>; <span class="hljs-comment">// modern C++</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number = <span class="hljs-number">114514</span>;<br><br></code></pre></td></tr></table></figure><h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>在现代 C++ 中，可以使用任何类型的括号初始化。 在初始化数组、矢量或其他容器时，这种初始化形式会非常方便。在下面的这个例子中声明了一个类S，三个均为std::vetor(向量)类型的变量v1,v1,v3并用不同方式进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br>    std::string name;<br>    <span class="hljs-type">float</span> num;<br>    <span class="hljs-built_in">S</span>(std::string s, <span class="hljs-type">float</span> f) : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">num</span>(f) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// C-style initialization</span><br>    std::vector&lt;S&gt; v;<br>    <span class="hljs-function">S <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>)</span></span>;<br><br>    v.<span class="hljs-built_in">push_back</span>(s1);<br>    v.<span class="hljs-built_in">push_back</span>(s2);<br>    v.<span class="hljs-built_in">push_back</span>(s3);<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    std::vector&lt;S&gt; v2 &#123;s1, s2, s3&#125;;<br><br>    <span class="hljs-comment">// or...</span><br>    std::vector&lt;S&gt; v3&#123; &#123;<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>&#125;, &#123;<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>&#125;, &#123;<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>&#125; &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>若要了解详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/initializing-classes-and-structs-without-constructors-cpp?view=msvc-170">括号初始化</a>。</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>现代 C++ 提供了移动语义，此功能可以避免进行不必要的内存复制。 在此语言的早期版本中，在某些情况下无法避免复制。 移动操作会将资源的所有权从一个对象转移到下一个对象，而不必再进行复制。 一些类拥有堆内存、文件句柄等资源。 实现资源所属的类时，可以定义此类的移动构造函数和移动赋值运算符。 在解析重载期间，如果不需要进行复制，编译器会选择这些特殊成员。 如果定义了移动构造函数，则标准库容器类型会在对象中调用此函数。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符 (C++)</a>。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>在使用C语法编程中，一个函数可以通过返回函数指针的方式传递给另一个函数，这不方便位于和理解。它们引用的函数可能在源代码的其他地方定义，而不是从调用它的位置定义的。而且他们不是类型安全的。现代C++提供了对函数对象、类的运算符重写，从而使它们可以像函数一样进行调用。创建函数对象的最简便方法是使用内联 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">lambda 表达式</a>。 下面的示例演示如何使用 lambda 表达式传递函数对象，然后由 <code>for_each</code> 函数在vector的每个元素中调用此函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">find_if</span>(<span class="hljs-built_in">begin</span>(v), <span class="hljs-built_in">end</span>(v), [=](<span class="hljs-type">int</span> i) &#123; <br>    <span class="hljs-keyword">return</span> i &gt; x &amp;&amp; i &lt; y; <br>    &#125;<br>    );<br></code></pre></td></tr></table></figure><p>Lambda表达式的形式为<code>[]()&#123;&#125;</code>，这里的是<code>[=](int i) &#123; return i &gt; x &amp;&amp; i &lt; y; &#125;</code>。此函数有一个int类型的形参，并返回一个bool类型的值，指示该参数是否大于 <code>x</code> 且小于 <code>y</code>。这里使用的x,y是lambda之前声明的两个变量。行为上看似是[&#x3D;]接受了上文的变量，实际上是lambda接受了值的副本。有关更详细的内容请看相关专题。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><small>Exceptions</small><br>现代 c + + 强调异常，而不是错误代码，作为报告和处理错误条件的最佳方式。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-170">现代 C++ 处理异常和错误的最佳做法</a>。</p><h2 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h2><p>对线程间通信机制使用 C++ 标准库 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/atomic-structure?view=msvc-170"><code>std::atomic</code></a> 结构和相关类型。</p><h2 id="std-variant-C-17"><a href="#std-variant-C-17" class="headerlink" title="std::variant(C++17)"></a>std::variant(C++17)</h2><p>在以C风格编程程序时通过使用联合体（共用体）使不同类型的成员占据同一个内存位置而达到节约内存的目的。但这并不是安全的，并容易导致编译错误。 C++17 引入了更加安全可靠的 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-class?view=msvc-170"><code>std::variant</code></a> 类，来作为联合体（共用体）的替代项。可以使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-functions?view=msvc-170#visit"><code>std::visit</code></a> 函数以类型安全的方式访问 <code>variant</code> 类型的成员。</p><hr><p><strong>译者有话说</strong><br>本页的上述的示例代码为微软参考手册的简单案例，本人会在下方附上个人理解的完整代码。此部分代码也可以移步至<a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp: Code example of Microsoft modern C + + vs2022 translation (github.com)</a>进行阅览，请原谅本人代码水平不精，谢谢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;id)<br>        : <span class="hljs-built_in">stu_name</span>(name), <span class="hljs-built_in">stu_id</span>(id)&#123;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_name;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_id;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetCollege</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_college;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetCollage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string college)</span> </span>&#123;<br>        stu_college = college;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> std::string stu_name;<br>    <span class="hljs-type">const</span> std::string stu_id;<br>    std::string stu_college&#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> student = std::<span class="hljs-built_in">make_unique</span>&lt;Student&gt;(<span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>);<br>    std::cout &lt;&lt; student-&gt;<span class="hljs-built_in">GetId</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; (*student).<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">auto</span> ptr_stu = student.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// if smart pointer is released, this raw pointer will be null</span><br>    ptr_stu-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;computr network&quot;</span>);<br>    std::cout &lt;&lt; ptr_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">auto</span> share_stu = std::<span class="hljs-built_in">make_shared</span>&lt;Student&gt;(<span class="hljs-string">&quot;114&quot;</span>, <span class="hljs-string">&quot;1919810&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">share_stu_1</span><span class="hljs-params">(share_stu)</span></span>;<br>    share_stu_1-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;communication engineering&quot;</span>);<br>    std::cout &lt;&lt; share_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br>&#125;<br><br>  <br><br><span class="hljs-comment">// make_unique (C++14) creates a unique poniter that manages a new object</span><br><span class="hljs-comment">// make_unique_for_overwrite (C++20)</span><br></code></pre></td></tr></table></figure><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>RAII，Resouce Acquisition Is Initialization:资源获取即初始化<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><code>std::stransform</code> 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Modern-cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/C++语言参考</title>
    <link href="/2022/08/07/C++%20Language%20Reference/"/>
    <url>/2022/08/07/C++%20Language%20Reference/</url>
    
    <content type="html"><![CDATA[<p><strong>前言赘叙</strong><br>本系列文档是对于微软文档《Modern C++ vs2022》进行翻译并插入一定的个人见解。个人之力翻译可能并不标准，还望海涵，也请多多指点。敝人也尝试通过这次机会向大家分享，也希望个人也能在代码造诣上得到提高。为了能够帮助理解，本人也创建了一个仓库，会在接下来使用代码的地方进行插入，当然也欢迎直接阅读示例demo</p><p>点击此处可浏览仓库 <a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp</a><br>点击此处可浏览原文 <a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=msvc-170">C++ Language Reference | Microsoft Docs</a></p><hr><h1 id="C-语言参考"><a href="#C-语言参考" class="headerlink" title="C++语言参考"></a>C++语言参考</h1><p><em>C++ Language Reference</em></p><p>本参考说明了在 Microsoft C++ 编译器中实现的 C++ 编程语言。该组织基于 Margaret Ellis 和 Bjarne Stroustrup 的 The Annotated C++ Reference Manual 以及 ANSI&#x2F;ISO C++ 国际标准 (ISO&#x2F;IEC FDIS 14882)。包括 Microsoft 特定的 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果">[1]</span></a></sup>C++ 语言功能实现。<br>有关现代 C++ 编程实践的概述，请参阅《<a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>》<br>请参阅下表以快速找到关键字或运算符：</p><ul><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170">C++ Keywords</a> （C++关键字）</li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">C++ Operators</a>（C++操作符）</li></ul><h1 id="在这个部分"><a href="#在这个部分" class="headerlink" title="在这个部分"></a>在这个部分</h1><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lexical-conventions?view=msvc-170">Lexical Conventions</a>  词汇约定<br>C++程序的基本词法元素：预定义字符（标记）、注释、操作符、关键字、标点符号、字符串。此外还有：文件转译（文件操作）、运算符优先级&#x2F;关联性。</p><blockquote><p>Fundamental lexical elements of a C++ program: tokens, comments, operators, keywords, punctuators, literals. Also, file translation, operator precedence&#x2F;associativity.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/basic-concepts-cpp?view=msvc-170">Basic Concepts</a>  基本概念<br>范围、链接、程序的启动和终止、存储类和类型。</p><blockquote><p>Scope, linkage, program startup and termination, storage classes, and types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-170">Built-in types</a> 内置类型<br>C++编译器中内置的基本类型及其取值范围。</p><blockquote><p>The fundamental types that are built into the C++ compiler and their value ranges.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-170">Standard Conversions</a>  标准转换<br>内置类型之间的类型转换。此外，指针、引用和指向成员的类型之间的算术转换和转换。</p><blockquote><p>Type conversions between built-in types. Also, arithmetic conversions and conversions among pointer, reference, and pointer-to-member types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/declarations-and-definitions-cpp?view=msvc-170">Declarations and definitions</a> 声明和定义<br>声明和定义变量、类型和函数。</p><blockquote><p>Declaring and defining variables, types and functions.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">Operators, Precedence and Associativity</a><br>运算符、优先级和关联性<br>C++中的运算符。</p><blockquote><p>The operators in C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/expressions-cpp?view=msvc-170">Expressions</a>  表达式<br>表达式的类型、表达式的语义、运算符的参考主题、强制转换和强制转换运算符、运行时类型信息。</p><blockquote><p>Types of expressions, semantics of expressions, reference topics on operators, casting and casting operators, run-time type information.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">Lambda Expressions</a>  Lambda表达式<br>一种隐式定义函数对象类并构造该类类型的函数对象的编程技术。</p><blockquote><p>A programming technique that implicitly defines a function object class and constructs a function object of that class type.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/statements-cpp?view=msvc-170">Statements</a>  语句<br>表达式、null空值、复合语句、选择、迭代、跳转和声明语句。</p><blockquote><p>Expression, null, compound, selection, iteration, jump, and declaration statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/classes-and-structs-cpp?view=msvc-170">Classes and structs</a>  类和结构体<br>对于类、结构体和共用体的介绍。此外也有，成员函数、特殊成员函数、数据成员、位字段、this指针，嵌套类。</p><blockquote><p>Introduction to classes, structures, and unions. Also, member functions, special member functions, data members, bit fields, <strong><code>this</code></strong> pointer, nested classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/unions?view=msvc-170">Unions</a>  联合体<br>用户定义类型，其中所有成员共享同一内存位置。</p><blockquote><p>User-defined types in which all members share the same memory location.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/inheritance-cpp?view=msvc-170">Derived Classes</a>  派生类<br>单个和多个继承、虚函数、多继承、抽象类、范围规则。 此外，还有__super和__interface关键字。</p><blockquote><p>Single and multiple inheritance, <strong><code>virtual</code></strong> functions, multiple base classes, <strong>abstract</strong> classes, scope rules. Also, the <strong><code>__super</code></strong> and <strong><code>__interface</code></strong> keywords.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/member-access-control-cpp?view=msvc-170">Member-Access Control</a>  成员访问控制<br>控制对类成员的访问： public、 private关键字和 protected 关键字。 友元函数和友元类。</p><blockquote><p>Controlling access to class members: <strong><code>public</code></strong>, <strong><code>private</code></strong>, and <strong><code>protected</code></strong> keywords. Friend functions and classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/operator-overloading?view=msvc-170">Overloading</a>  重载<br>重载运算符，对运算符重载的规则。</p><blockquote><p>Overloaded operators, rules for operator overloading.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/exception-handling-in-visual-cpp?view=msvc-170">Exception Handling</a>  异常处理<br>C++ 异常处理、结构化异常处理 (SEH)、用于编写异常处理语句的关键字。</p><blockquote><p>C++ exception handling, structured exception handling (SEH), keywords used in writing exception handling statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/assertion-and-user-supplied-messages-cpp?view=msvc-170">Assertion and User-Supplied Messages</a>  断言和User-Supplied消息<br>#error 指令， static_assert 关键字， assert 宏。</p><blockquote><p><code>#error</code> directive, the <strong><code>static_assert</code></strong> keyword, the <code>assert</code> macro.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/templates-cpp?view=msvc-170">Templates</a>  模板<br>模板规范、函数模板、类模板、typename 关键字、模板对比于宏定义、模板和智能指针。</p><blockquote><p>Template specifications, function templates, class templates, <strong><code>typename</code></strong> keyword, templates vs. macros, templates and smart pointers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/event-handling?view=msvc-170">Event Handling</a>  事件处理<br>定义事件和事件处理程序</p><blockquote><p>Declaring events and event handlers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-specific-modifiers?view=msvc-170">Microsoft-Specific Modifiers</a>  独属于微软(msvc)的修饰符<br>Microsoft C++ 专用修饰符。 内存寻址、调用约定、naked函数、扩展存储类属性 (__declspec) 。 __w64</p><blockquote><p>Modifiers specific to Microsoft C++. Memory addressing, calling conventions, <strong><code>naked</code></strong> functions, extended storage-class attributes (<strong><code>__declspec</code></strong>), <strong><code>__w64</code></strong>.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/inline-assembler?view=msvc-170">Inline Assembler</a>  内联汇编程序<br>在__asm块中使用汇编语言和C++。</p><blockquote><p>Using assembly language and C++ in <strong><code>__asm</code></strong> blocks.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/compiler-com-support?view=msvc-170">Compiler COM Support</a>  编译器对COM的支持<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。">[2]</span></a></sup><br>有关用于支持 COM 类型的 Microsoft 专用类和全局函数的参考。</p><blockquote><p>A reference to Microsoft-specific classes and global functions used to support COM types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-extensions?view=msvc-170">Microsoft Extensions</a>  Microsoft的拓展<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等">[3]</span></a></sup><br>Microsoft微软对C++进行的扩展</p><blockquote><p>Microsoft extensions to C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/nonstandard-behavior?view=msvc-170">Nonstandard Behavior</a>  非标准行为<br>有关Microsoft C++编译器的非标准行为的信息。<br>Information about nonstandard behavior of the Microsoft C++ compiler.</p><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>  欢迎回到C++<br>一篇现代C + +编程实践概述，指引编写安全、正确、高效的程序。</p><blockquote><p>An overview of modern C++ programming practices for writing safe, correct and efficient programs.</p></blockquote><hr> <section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Modern-cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一篇闲言碎语</title>
    <link href="/2022/08/07/another-gossip/"/>
    <url>/2022/08/07/another-gossip/</url>
    
    <content type="html"><![CDATA[<h1 id="另一篇闲言碎语"><a href="#另一篇闲言碎语" class="headerlink" title="另一篇闲言碎语"></a>另一篇闲言碎语</h1><p>对于hexo我的技术力实在是太低了，于是乎就在hexo的主题库中找了一个–“anatole”非常的不错。其中一个巨大的原因是因为我发现我忘记怎么设计网页了，回忆以前还知道玩玩什么jqury,boostrapl，如果回到18年甚至可以手撸css,js。奈何现在是一位大专两年级的学生，除了每顿猛造两碗饭，其他的都忘记了。<br>所以坦白一下我是如何做了这个稀烂的主页的。</p><hr><p>首先用日常是开了一个科学上网，用winget把nodejs给整上，迅速的安装一波hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>npm install hexo<br>hexo init &lt;blog-name&gt;<br>cd &lt;blog-name&gt;<br>npm install<br></code></pre></td></tr></table></figure><h2 id="对了，如果不能直接用hexo指令的话可以配置一下1-npx-hexo-lt-command-gt-2-将-Hexo-所在的目录下的-node-modules-添加到环境变量之中即可直接使用-96-hexo"><a href="#对了，如果不能直接用hexo指令的话可以配置一下1-npx-hexo-lt-command-gt-2-将-Hexo-所在的目录下的-node-modules-添加到环境变量之中即可直接使用-96-hexo" class="headerlink" title="对了，如果不能直接用hexo指令的话可以配置一下1.  npx hexo &lt;command&gt;2.  将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 &#96;hexo "></a>对了，如果不能直接用hexo指令的话可以配置一下<br>1.  <code>npx hexo &lt;command&gt;</code><br>2.  将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 &#96;hexo <command><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></h2><p>上述步骤完成后，就是抄一个主题下来。感谢hexo设计的很简单，让我一下子就上手了。<br>把主题文件放到themes下就可以了，比如我的是<strong>E:\blog\themes\anatole</strong><br><small><em>什么？如何安装主题，当然是点一个然后 <code>git clone</code>下来哦</em></small></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole<br>cd anatole<br>git pull<br>npm install --save hexo-render-pug hexo-generator-archive hexo-generator-tag hexo-generator-index hexo-generator-category<br></code></pre></td></tr></table></figure><p>然后在_config.yml里填写一个特殊的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">archive_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>每一个主题的安装都不尽相同，所以得按照自己挑选的主题来进行配置。</strong></p><hr><p>按照主题的官网wiki配置一通以后，发现下面那个小蓝鸟，小粪坑不知道怎么关闭2333。在尝试去ejs中修改的我也放弃了。对了，这里要坦白我学会怎么修改favicon以及logo，于是就去主题中修改了源图标[手动狗头]。好了，今日吹水到此结束，明日（或许）开始认真更新一些东西。<br>顺便在下面贴上使用的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br>  <br><br><span class="hljs-comment"># Site</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">CvRaindays</span><br><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">std::shared_ptr&lt;Blog&gt;</span> <span class="hljs-string">CvRain(this);</span><br><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">C,C++,Linux</span><br><br><span class="hljs-attr">author:</span> <span class="hljs-string">CvRaindays,cvraindays@outlook.com</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-cn</span><br><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># URL</span><br><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://example.com</span><br><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><br><span class="hljs-attr">permalink_defaults:</span><br><br><span class="hljs-attr">pretty_urls:</span><br><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br>  <br><br><span class="hljs-comment"># Directory</span><br><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><br><span class="hljs-attr">skip_render:</span> <span class="hljs-string">README.md</span><br><br>  <br><br><span class="hljs-comment"># Writing</span><br><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><br><span class="hljs-attr">external_link:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">highlight:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">prismjs:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Home page setting</span><br><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><br><span class="hljs-attr">index_generator:</span><br><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br>  <br><br><span class="hljs-comment"># Category &amp; Tag</span><br><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><br><span class="hljs-attr">category_map:</span><br><br><span class="hljs-attr">tag_map:</span><br><br>  <br><br><span class="hljs-comment"># Metadata elements</span><br><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br>  <br><br><span class="hljs-comment"># Date / Time format</span><br><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Pagination</span><br><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br>  <br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><br><span class="hljs-attr">include:</span><br><br><span class="hljs-attr">exclude:</span><br><br><span class="hljs-attr">ignore:</span><br><br>  <br><br><span class="hljs-comment"># Extensions</span><br><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><br><span class="hljs-attr">theme:</span> <span class="hljs-string">anatole</span><br><br>  <br><br><span class="hljs-comment"># Deployment</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><br>  <br><br><span class="hljs-attr">deploy:</span><br><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/CvRain/cvrain.github.io.git</span><br><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br><br>  <br><br><span class="hljs-attr">archive_generator:</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br><br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好世界！</title>
    <link href="/2022/08/07/hello-world/"/>
    <url>/2022/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>经过了三个小时的辛苦劳作，鱼师傅成功摸出来一个HelloWorld!<br>第一篇blog，准备先写个小记作为一个段子乐呵乐呵。 </p><hr><h2 id="一盘饺子"><a href="#一盘饺子" class="headerlink" title="一盘饺子"></a>一盘饺子</h2><p>属实是有了一壶好醋，也是可怜了我的Surface Go2，跟着我并没有享受到作为“高端”电子设备的万千宠爱，反而是被不断刷机。不是因为购买的是丐版，而且其配置加上Windows11略有拉跨。不得不研究如何在上面刷一套Linux操作系统用来满足个人需求，提高工作效率。具体的相关情况请看后文内容，本篇小作文仅作为一个引子。<br>说回来，Go系列的刷系统确实难受，翻烂了各种帖子，总算是总结出一套目前看最完善的装系统经验。回味过来笔者果然是无聊透顶，可能坚持捣鼓刷系统的也没有多少了吧，当然也可以和个人性格以及家庭有些许关系。<br>准备录制一个视频和大家分享分析，经过一晚上的辗转反侧来看，还是需要写个什么东西使得叙述更完整一点。那就不如自己搞个博客吧！或许也只会发少量的东西，不过说不好也不好说。</p><h2 id="做些什么"><a href="#做些什么" class="headerlink" title="做些什么"></a>做些什么</h2><p>就目前看来，或许会更新一些个人在编程上的小经验，不过和其他奆佬比起来就是腐草荧光了。未来可能尝试自己做一个Hexo的主题（不过感觉60%要泡汤了），然后写一点关于模组教程的小作文。嗯，似乎没了。</p><h2 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h2><p>感觉自己越来越不会说话了，文采也不太行了。还没到老年却也喜欢絮絮叨叨一番。身心格外的疲倦，也不知道为什么，还是按时吃药吧，或许问题不大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
