<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>简单玩一下元组</title>
    <link href="/2023/11/12/haskell-tuple/"/>
    <url>/2023/11/12/haskell-tuple/</url>
    
    <content type="html"><![CDATA[<h1 id="简单玩一下元组"><a href="#简单玩一下元组" class="headerlink" title="简单玩一下元组"></a>简单玩一下元组</h1><p>有意思的是Haskell中的元组，不仅如同Python中一样可以随便放东西，而且可以当作结构体用<br>如果元组有里面只有两个元素，就可以当作键值对用，真不错啊真不错~</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">numberAndNumber</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br><span class="hljs-title">triples</span> = [(a,b,c) | a &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], b &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br><span class="hljs-title">rightTriangles</span> = [(a,b,c) | c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], a &lt;- [<span class="hljs-number">1</span>..c], b &lt;- [<span class="hljs-number">1</span>..a], a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> == c^<span class="hljs-number">2</span>]<br><span class="hljs-title">someItem</span> = (<span class="hljs-number">1</span>,&#x27;a&#x27;, <span class="hljs-string">&quot;HelloWorld&quot;</span>, <span class="hljs-type">True</span>)<br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Hello, tuple!&quot;</span><br>    print numberAndNumber<br>    print someItem<br>    <span class="hljs-comment">--对于序队可使用</span><br>    print (fst numberAndNumber)<br>    print (snd numberAndNumber)<br><br>    <span class="hljs-comment">--创建序对</span><br>    print (zip [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], odd x] [&#x27;a&#x27;..&#x27;z&#x27;])<br>    print (zip [<span class="hljs-number">1</span>..] [<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;Java&quot;</span>])<br><br>    <span class="hljs-comment">-- 打印0~10之类边长的三角形</span><br>    print rightTriangles<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅学一下Haskell中的列表</title>
    <link href="/2023/11/11/haskell-list/"/>
    <url>/2023/11/11/haskell-list/</url>
    
    <content type="html"><![CDATA[<h1 id="浅学一下Haskell中的列表"><a href="#浅学一下Haskell中的列表" class="headerlink" title="浅学一下Haskell中的列表"></a>浅学一下Haskell中的列表</h1><blockquote><p>在 Haskell 中，List 就像现实世界中的购物单一样重要。它是最常用的资料结构，并且十分强大，灵活地使用它可以解决很多问题。<br>Haskell中的列表是一种用来存储相同类型的元素的数据结构。列表可以用方括号和逗号来构造，例如[1, 2, 3]是一个包含三个整数的列表。<br>列表也可以用冒号操作符来构造，冒号操作符可以将一个元素添加到一个已有的列表的开头，例如1:[2, 3]等价于[1, 2, 3]。<br>列表还可以用范围来构造，<br>例如[1…10]是一个包含1到10的自然数的列表。列表的长度可以用length函数来计算，列表的元素可以用索引来访问，<br>例如[1, 2, 3] !! 0返回1，[1, 2, 3] !! 1返回2，以此类推。列表还有很多其他的操作，例如拼接，反转，排序，过滤，映射，折叠等。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">odd_numbers</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]<br><span class="hljs-title">even_numbers</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><span class="hljs-title">number_list</span> = [odd_numbers, even_numbers]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (odd_numbers ++ even_numbers) <span class="hljs-comment">--拼接两个列表</span><br>    print (<span class="hljs-string">&quot;Hello&quot;</span> ++ <span class="hljs-string">&quot; &quot;</span> ++ <span class="hljs-string">&quot;world!&quot;</span>) <span class="hljs-comment">--拼接两个字符串</span><br>    print ([&#x27;<span class="hljs-type">H&#x27;</span>,&#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;] ++ [&#x27; &#x27;,&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;,&#x27;!&#x27;])<br>    print (number_list)<br>    <br>    <span class="hljs-comment">-- 不可以这样拼接，这是一个列表和一个数字</span><br>    <span class="hljs-comment">-- [1,2,3,4,5] ++ [5]    </span><br><br>    print ( <span class="hljs-number">0</span> : odd_numbers)<br>    print (even_numbers !! <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment">-- 比较列表（会从第一个元素开始比较， 如果相等则比较第二个，直到不同为止）</span><br>    putStrLn <span class="hljs-string">&quot;比较列表&quot;</span><br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &lt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] == [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br><br>    <span class="hljs-comment">-- 更多的列表操作</span><br>    putStrLn <span class="hljs-string">&quot;更多的列表操作&quot;</span><br>    print (head odd_numbers)<br>    print (init odd_numbers)<br>    print (last odd_numbers)<br>    print (tail even_numbers)<br>    <span class="hljs-comment">-- head [] 无法提取空列表</span><br>    print (length odd_numbers)<br>    print (null odd_numbers)<br>    print (reverse odd_numbers)<br>    print (take <span class="hljs-number">3</span> odd_numbers)<br>    print (drop <span class="hljs-number">0</span> odd_numbers)<br>    print (maximum odd_numbers)<br>    print (minimum even_numbers)<br>    print (sum odd_numbers)<br>    print (product odd_numbers)<br>    print (elem <span class="hljs-number">3</span> odd_numbers)<br>    print (elem <span class="hljs-number">3</span> even_numbers)<br><br>    <span class="hljs-comment">-- 列表区间</span><br>    putStrLn <span class="hljs-string">&quot;列表区间&quot;</span><br>    print [<span class="hljs-number">1</span>..<span class="hljs-number">20</span>]<br>    print [&#x27;a&#x27; .. &#x27;z&#x27;]<br>    print [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..<span class="hljs-number">20</span>]<br>    print (take <span class="hljs-number">10</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..])<br>    print (take <span class="hljs-number">10</span> (cycle [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br>    print (take <span class="hljs-number">10</span> (repeat <span class="hljs-number">2</span>))<br>    print (replicate <span class="hljs-number">3</span> <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">-- 列表推导式</span><br>    putStrLn <span class="hljs-string">&quot;列表推导式&quot;</span><br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], x*<span class="hljs-number">10</span> &lt;= <span class="hljs-number">50</span>, even x]<br>    <span class="hljs-comment">-- 取1～100中可以被3整出的数</span><br>    print [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>], x `mod` <span class="hljs-number">3</span> == <span class="hljs-number">0</span>]<br>    <span class="hljs-comment">-- 根据number_list中的数，返回是odd还是even</span><br>    print ([ <span class="hljs-keyword">if</span> ((x `mod` <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> ) <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;even&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;odd&quot;</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]])<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs bash">[2,4,6,8,10,1,3,5,7,9]<br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br>[[2,4,6,8,10],[1,3,5,7,9]]<br><br>[0,2,4,6,8,10]<br><br>7<br><br>比较列表<br><br>True<br><br>True<br><br>True<br><br>True<br><br>True<br><br>更多的列表操作<br><br>2<br><br>[2,4,6,8]<br><br>10<br><br>[3,5,7,9]<br><br>5<br><br>False<br><br>[10,8,6,4,2]<br><br>[2,4,6]<br><br>[2,4,6,8,10]<br><br>10<br><br>1<br><br>30<br><br>3840<br><br>False<br><br>True<br><br>列表区间<br><br>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]<br><br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[1,2,3,1,2,3,1,2,3,1]<br><br>[2,2,2,2,2,2,2,2,2,2]<br><br>[10,10,10]<br><br>列表推导式<br><br>[10,20,30,40,50,60,70,80,90,100]<br><br>[20,40]<br><br>[3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99]<br><br>[<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好呀 Haskell</title>
    <link href="/2023/11/10/hello-haskell/"/>
    <url>/2023/11/10/hello-haskell/</url>
    
    <content type="html"><![CDATA[<h1 id="你好呀Haskell"><a href="#你好呀Haskell" class="headerlink" title="你好呀Haskell"></a>你好呀Haskell</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>开始玩耍一个新的编程语言:Haskell, 其实很早就准备学习这个语言，而且也在官网上看了一小段教程，但是有一种云里雾里的感觉，不是没有学懂他的语法，而是还没有理解他的思想，所以一直拖到现在。</p><p>直到在上了大学物理这门课程。感谢岳老师的物理课，虽然我的物理学的并不好，但是对于看待事务本身多了一个新的角度。</p><p>对于之前学习C++,C#, Java…还有别的语言，在解决问题方面更像是在解释这个问题应该怎么做。即使是说使用了面向对象、多态、继承、封装、抽象、接口、泛型、多线程、异常等等，但依然更像是描述这个问题应该怎么做，所以这类语言也成为命令式语言。在命令式语言中执行操作需要给电脑安排一组指令, 随着命令的执行，状态会随之发生改变。</p><p>然而在纯函数式编程语言中，不再是像命令式语言那样描述要做什么，而是通过函数描述问题“是什么”。</p><p>有一个简单的例子说， 在函数式编程语言中，变量一旦赋值，就不能改了，比如  <code>x = 5</code> 这里已规定好了，x的值是5，那么在函数式编程语言中，变量x的值就是5，不能被改变。</p><h2 id="简单的运算"><a href="#简单的运算" class="headerlink" title="简单的运算"></a>简单的运算</h2><blockquote><p><strong>simple-calc.hs</strong></p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">plus</span> x y = x + y<br><span class="hljs-title">substract</span> x y = x - y<br><span class="hljs-title">multiply</span> x y = x * y<br><span class="hljs-title">divide</span> x y = x / y<br><br><span class="hljs-title">and_gate</span> x y = x &amp;&amp; y<br><span class="hljs-title">or_gate</span> x y = x || y<br><span class="hljs-title">not_gate</span> x = not x<br><br><span class="hljs-title">is_equal</span> x y = x == y<br><span class="hljs-title">is_bigger</span> x y = x &gt; y<br><span class="hljs-title">is_smaller</span> x y = x &lt; y<br><span class="hljs-title">is_odd</span> x = mod x <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-title">double_value</span> x = x * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>测试运行</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ghci simple-calc.hs<br><span class="hljs-comment">#GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help</span><br><span class="hljs-comment">#[1 of 1] Compiling Main             ( simple-calc.hs, interpreted )</span><br><span class="hljs-comment">#Ok, one module loaded.</span><br><br>ghci&gt; plus 2 4<br>6<br>ghci&gt; or_gate True False<br>True<br>ghci&gt; double_value 5<br>10<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>小小解释</strong></p></blockquote><p>定义函数: functionName args &#x3D; expression</p><p>执行函数: functionName args </p><p>如果一个函数有两个参数，也可以用这样的方法调用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-number">4</span> `mod` <span class="hljs-number">2</span><br><span class="hljs-title">mod</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> #两者相当<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视C++为一个语言联邦</title>
    <link href="/2023/11/09/view-cpp-as-a-federation/"/>
    <url>/2023/11/09/view-cpp-as-a-federation/</url>
    
    <content type="html"><![CDATA[<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><p><small>View C++ as a federation of languages</small></p><blockquote><p>一开始，C++只是C加上一些面向对象特性。 C++ 最初的名称 C with Classes 也反应来这个血缘关系 (Effective C++)</p></blockquote><hr><p>随着C++的不断发展，C++的特性越来越多，甚至有些特性是C++独有的。 学了有一段时间的C++， 向他人请教过C++的技巧，也教过人怎么学习C++。 语法以及技巧不是很难去教授的，但是有一段时间令我头疼的是，如何对新手做一个C++的介绍。 因为C++的特性太多， 而且C++的特性之间又存在一定的联系， 导致很难对一个新手进行一个系统的学习。</p><p>直到有一天我再次翻开《Effective C++ 改善程序的55个做法》， 而条款01就是”视C++为一个语言联邦“<br>可以说，C++其实是一个联邦， 联邦由若干个语言组成， 每个语言都具有自己的特性， 这些特性又相互关联。今天的C++是个多重范式的编程语言， 它同时具有面向过程、面向对象、泛型编程、模板、异常处理、标准库、标准模板库等特性。</p><h2 id="语言联邦"><a href="#语言联邦" class="headerlink" title="语言联邦"></a>语言联邦</h2><blockquote><ol><li>Base C language</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ol></blockquote><h3 id="Base-C-language"><a href="#Base-C-language" class="headerlink" title="Base C language"></a>Base C language</h3><p>说到底，C++可以理解是一个C语言的超集， 它包含了C语言的所有特性， 并且还增加了面向对象、泛型编程、异常处理、标准库、标准。许多时候一个问题的C++解法， 往往可以由C语言的解法推导而来，也可以说是较为高级、较为抽象的C语言的解法。</p><h3 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h3><p>C++语言是面向对象的， 它包含了一些面向对象的特性， 例如： 类、对象、继承、多态、虚函数。<br>这部分也就是C with classes所诉求的， 它也被称为OO C++： classes, inheritance, and polymorphism.</p><h3 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h3><p>C++的模板特性， 使得C++可以进行泛型编程， 它使得C++可以进行泛型编程。不严谨的说，模板能够批量生成大量功能相似，但是有些许不同的代码。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL是C++标准模板库， 它提供了一组通用的、可复用的算法和数据结构， 例如： 容器、迭代器、算法、函数对象、适配器、分配器、流、字符串、数值等。然而STL有自己独特的办事方式，当你同STL一同工作，你必须遵守他的约定。</p><p>在编程时候， 这些语言联邦中的特性相互之间是相互独立的， 它们之间可以相互组合， 也可以相互分离。 例如，你可以只使用C语言特性完成某些事情，或者在一个类中自己封装一个STL容器， 或者使用STL容器完成一些C++特性。</p><blockquote><p>当你从某个次语言切换到另一个时，导致高效编程守则编程守则要求你改变策略时，不要感到惊讶。因此说C++并不是一个一组带有一组守则一体的语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。<br><strong>C++高效编程守则视状况而变化，取决于你使用C++的哪一个部分</strong></p></blockquote><h2 id="学习C-的流程"><a href="#学习C-的流程" class="headerlink" title="学习C++的流程"></a>学习C++的流程</h2><p>所以说，学习C++本体或许并不一定要掌握C语言，“不必是一个火箭科学家”， 只需要掌握C++的特性， 就可以写出一些有趣的代码。<br>之后在针对C++的特性进行学习， 例如： 模板、STL、异常处理等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern_C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>来做一个猜数游戏吧</title>
    <link href="/2023/11/09/guessing-number/"/>
    <url>/2023/11/09/guessing-number/</url>
    
    <content type="html"><![CDATA[<h1 id="一个猜数小游戏"><a href="#一个猜数小游戏" class="headerlink" title="一个猜数小游戏"></a>一个猜数小游戏</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>首先尝试接受用户的一个输入数字</li><li>生成一个随机数</li><li>进入游戏循环主体中<ol><li>输入数字大于随机数：输出大了，循环继续</li><li>输入数字小于随机数：输入小了，循环继续</li><li>输入数字等于随机数：猜对了，退出循环</li></ol></li><li>结束程序</li></ol><h2 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// Create random number generator</span><br>    std::random_device random_device;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">generator</span><span class="hljs-params">(random_device())</span></span>;<br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distribution</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> random_number = <span class="hljs-built_in">distribution</span>(generator);<br>    std::cout &lt;&lt; random_number &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// Create variable to store user&#x27;s guess</span><br>    <span class="hljs-type">int</span> guessing_number&#123;&#125;;<br><br>    <span class="hljs-comment">// Create loop to allow user to guess the random number</span><br>    <span class="hljs-keyword">while</span>(guessing_number != random_number)&#123;<br>        std::cin &gt;&gt; guessing_number;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Guessing number: &quot;</span> &lt;&lt; guessing_number &lt;&lt; std::endl;<br>        <span class="hljs-keyword">if</span>(guessing_number &gt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too high&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guessing_number &lt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too low&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;You got it!&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="随机数引擎"><a href="#随机数引擎" class="headerlink" title="随机数引擎"></a>随机数引擎</h3><p><strong>要在C++中使用<random>库生成一个随机数，请按照以下步骤操作：</strong></p><ol><li><p>首先，确保已经包含了<code>&lt;random&gt;</code>头文件。在文件的开头添加以下代码：<code>#include &lt;random&gt;</code></p></li><li><p>接下来，创建一个<code>std::random_device</code>对象，用于生成随机种子。这可以确保每次运行程序时生成的随机数不同。<br><code>std::random_device rd;</code></p></li><li><p>使用<code>std::seed</code>函数，将random_device对象生成的随机种子用于初始化std::mt19937随机数生成器。<br><code>std::mt19937 gen(rd());</code></p></li><li><p>使用<code>std::uniform_int_distribution</code>对象，指定随机数的范围。例如，要生成0到100之间的随机数，可以使用以下代码：<br><code>std::uniform_int_distribution&lt;&gt; distrib(0, 100);</code></p></li><li><p>使用distrib对象生成随机数，并将其存储在变量中。<br><code>const auto random_number = distrib(gen);</code></p></li></ol><p><code>std::mt19937</code>是一个Mersenne Twister伪随机数生成器，它是C++标准库中的一个均匀分布随机数生成器。Mersenne Twister是一种广泛使用的随机数生成器，其性能和分布非常广泛，因此在许多应用中都被广泛使用。</p><p><code>std::mt19937</code>的构造函数接受一个random_device对象作为参数，该对象用于生成随机种子。通过使用random_device，可以确保每次运行程序时生成的随机数不同。</p><p><code>std::mt19937</code>生成的随机数服从均匀分布，即在指定的区间内等概率地取值。</p><h3 id="const-和-auto"><a href="#const-和-auto" class="headerlink" title="const 和 auto"></a>const 和 auto</h3><p>const 关键字用于声明常量，即在程序运行期间其值不能被修改的量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>a = <span class="hljs-number">6</span> <span class="hljs-comment">// 错误，不能修改常量的值</span><br></code></pre></td></tr></table></figure><p>auto 关键字用于声明自动类型变量，即编译器会根据初始值自动推断出变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-comment">//声明一个int类型的a,并且定义值为5</span><br><span class="hljs-keyword">auto</span> b = a; <span class="hljs-comment">// b的类型和a一样，都是int类型</span><br>b = <span class="hljs-number">7</span>;  <span class="hljs-comment">//正确，可以修改b的值</span><br></code></pre></td></tr></table></figure><h3 id="主体判断框架"><a href="#主体判断框架" class="headerlink" title="主体判断框架"></a>主体判断框架</h3><p>使用while循环，在循环体中判断条件是否成立，如果条件成立，则执行循环体，否则退出循环。<br>用户如果输入错误数值，那么就一直循环，直到输入正确为止。<br>用户输入正确，那么就会通过break跳出循环。</p><h3 id="整体解释"><a href="#整体解释" class="headerlink" title="整体解释"></a>整体解释</h3><ol><li>引入所需的头文件，包括<random>（用于随机数生成器）和<iostream>（用于输入输出）。</li><li>在main函数中，定义一个random_device对象，用于生成随机种子。</li><li>定义一个std::mt19937对象，作为随机数生成器，并将random_device对象作为参数传递。</li><li>定义一个std::uniform_int_distribution对象，用于生成1到100之间的随机整数。</li><li>使用distribution对象生成一个随机整数，并将其存储在random_number变量中。</li><li>使用std::cout输出随机数。</li><li>定义一个guessing_number变量，用于存储用户输入的数字。</li><li>使用一个while循环，直到用户猜对数字为止。</li><li>在循环中，使用std::cin从用户输入一个数字，并将其存储在guessing_number变量中。</li><li>使用std::cout输出用户输入的数字。</li><li>如果guessing_number大于random_number，则输出“Too high”。</li><li>如果guessing_number小于random_number，则输出“Too low”。</li><li>如果guessing_number等于random_number，则输出“You got it!”并跳出循环。</li><li>最后，return 0表示程序正常退出。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows上mingw C/C++环境搭建</title>
    <link href="/2022/12/11/Tips-mingw/"/>
    <url>/2022/12/11/Tips-mingw/</url>
    
    <content type="html"><![CDATA[<h1 id="MSYS2和CMake搭建C-x2F-C-环境-参考指南"><a href="#MSYS2和CMake搭建C-x2F-C-环境-参考指南" class="headerlink" title="MSYS2和CMake搭建C&#x2F;C++环境 参考指南"></a>MSYS2和CMake搭建C&#x2F;C++环境 参考指南</h1><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a><strong>准备材料</strong></h2><ul><li>MSYS2 <a href="https://www.msys2.org/">msys2.org</a></li><li>CMake <a href="https://cmake.org/download/">cmake.org</a></li></ul><hr><h2 id="如何下载"><a href="#如何下载" class="headerlink" title="如何下载"></a>如何下载</h2><p><img src="/img/Tips-mingw/1.png" alt="1.png"></p><center><small>点击即可下载，之后莽点下一步即可安装</small></center><p><img src="/img/Tips-mingw/2.png" alt="2.png"></p><center><small>根据系统架构选择对应的版本下载，之后双击安装即可</small></center><hr><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ol><li>打开安装的MSYS2 MSYS， 更换软件源 (选择任意即可)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tuna mirror 清华软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br><span class="hljs-comment"># ustc mirror 中科大软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.ustc.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br></code></pre></td></tr></table></figure></li></ol><p><img src="/img/Tips-mingw/3.png" alt="3.png"></p><p><img src="/img/Tips-mingw/4.png" alt="4.png"></p><ol start="2"><li>更新一下软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Syyu<br></code></pre></td></tr></table></figure>遇到 :: Proceed with installation? [Y&#x2F;n] 的类似问题时输入y即可</li></ol><p><img src="/img/Tips-mingw/5.png" alt="5.png"></p><ol start="3"><li>安装mingw<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S base-devel <br>pacman -S mingw-w64-x86_64-toolchain<br><br></code></pre></td></tr></table></figure>Enter a selection (default&#x3D;all): 输入回车即可<br><img src="/img/Tips-mingw/6.png" alt="6.png"></li></ol><p><strong>4. 配置系统环境</strong></p><p>找到安装目录的mingw64路径<br><img src="/img/Tips-mingw/7.png" alt="7.png"></p><p>计算机右键属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; path -&gt; 你的路径<br><img src="/img/Tips-mingw/8.png" alt="8.png"><br><img src="/img/Tips-mingw/9.png" alt="9.png"><br><img src="/img/Tips-mingw/10.png" alt="10.png"><br><img src="/img/Tips-mingw/11.png" alt="11.png"></p><h2 id="最后验证"><a href="#最后验证" class="headerlink" title="最后验证"></a>最后验证</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">cmake --version<br>gcc -v<br></code></pre></td></tr></table></figure><p><img src="/img/Tips-mingw/12.png" alt="12.png"></p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>MSYS2 是什么？<br><strong>MSYS2</strong> is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.</p><p>It consists of a command line terminal called <a href="https://mintty.github.io/">mintty</a>, bash, version control systems like git and subversion, tools like tar and awk and even build systems like autotools, all based on a modified version of <a href="https://cygwin.com/">Cygwin</a>. Despite some of these central parts being based on Cygwin, the main focus of MSYS2 is to provide a build environment for native Windows software and the Cygwin-using parts are kept at a minimum. MSYS2 provides up-to-date native builds for GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby, just to name a few.</p><p>To provide easy installation of packages and a way to keep them updated it features a package management system called <a href="https://wiki.archlinux.org/index.php/pacman">Pacman</a>, which should be familiar to Arch Linux users. It brings many powerful features such as dependency resolution and simple complete system upgrades, as well as straight-forward and reproducible package building. Our package repository contains <a href="https://packages.msys2.org/base">more than 2600 pre-built packages</a> ready to install.</p><p>For more details see <a href="https://www.msys2.org/docs/what-is-msys2/">‘What is MSYS2?’</a> which also compares MSYS2 to other software distributions and development environments like <a href="https://cygwin.com/">Cygwin</a>, <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>, <a href="https://chocolatey.org/">Chocolatey</a>, <a href="https://scoop.sh/">Scoop</a>, … and <a href="https://www.msys2.org/docs/who-is-using-msys2/">‘Who Is Using MSYS2?’</a> to see which projects are using MSYS2 and what for.</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">MSYSY2 MSYS</td><td align="left">用来管理和安装包的</td></tr><tr><td align="left">MSYSY2 MinGW 32-bit</td><td align="left">编译32位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MinGW 64-bit</td><td align="left">编译64位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MSYS UCRT 64-bit</td><td align="left">编译64位程序，库链接到ucrt上</td></tr></tbody></table><p>CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++, tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/标记和字符集</title>
    <link href="/2022/08/10/Tokens%20and%20character%20sets/"/>
    <url>/2022/08/10/Tokens%20and%20character%20sets/</url>
    
    <content type="html"><![CDATA[<h1 id="标记和字符集"><a href="#标记和字符集" class="headerlink" title="标记和字符集"></a>标记和字符集</h1><p><small>Tokens and character sets</small></p><p>C++程序文本由Tokens(标记)和空格组成。标记是对编译器有用的 C++ 程序的最小元素。 C++ 分析器可识别以下类型的Token：</p><ul><li>Keywords （关键字）</li><li>Identifiers（标识符）</li><li>Numeric, Boolean and Pointer Literals（数字，布尔值，指针文本）</li><li>String and Character Literals（字符串和字符文本）</li><li>User-Defined Literals（用户定义的文本）</li><li>Operators（运算符&#x2F;操作符）</li><li>Punctuators（标点符号）<blockquote><p><strong>译注：</strong><br>词法分析是编译过程的第一步工作，将字符流转换为单词序列，输出到中间文件中，这个中间文件将会作为语法分析程序的输入，进行下一步工作。<br>token可翻译为标记，是构成源代码的最小单位，从输入字符流中生成标记的过程叫作标记化（ tokenization ），在这个过程中，词法分析器还会对标记进行分类。编译器会从左到右扫描我们的源代码，将其中的字符流分割成一个一个的 token。</p></blockquote></li></ul><p>Token通常用空格进行切分，可以是一个或多个：</p><ul><li>空白</li><li>水平或垂直制表符</li><li>新行</li><li>表单源</li><li>注释</li></ul><hr><h2 id="基本源字符集"><a href="#基本源字符集" class="headerlink" title="基本源字符集"></a>基本源字符集</h2><p>C++标准指定了基本源字符集用于源文件中，要表示此集合之外的字符，可以使用通用字符名称指定其他字符。MSVC编译器允许实现其他字符。要表示此集合之外的字符，可以使用通用字符名称指定其他字符。<br><code>a b c d e f g h i j k l m n o p q r s t u v w x y z</code><br><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code><br><code>0 1 2 3 4 5 6 7 8 9</code><br><code>_ &#123; &#125; [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ &quot; &#39;</code></p><p><strong>特用于Microsoft的内容</strong><br>MSVC 包含 $ 字符作为基本源字符集的成员。MSVC 还允许根据文件编码在源文件中使用一组额外的字符。在默认情况下，Visual Studio使用默认代码页存储资源文件。当资源文件使用特定区域或Unicode代码页保存时，MSVC允许你在源代码中使用该代码页的任何字符，但基本源字符集中不允许的控制代码除外。举个例子，您可以通过日文代码页在注释，标识符或字符串中使用日文。MSVC不允许无法转换成为多字节字符和Unicode位码的字符序列。根据编译器选项，并非所有允许的字符都可能出现在标识符中。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a>。</p><blockquote><p><strong>译注</strong><br>在使用visual studio时如果使用WinAPI例如&lt;Windows.h&gt;便可以遇到LPWSTR等字符类型，这是一种宽字符类型也可称作多字节字符。在MSVC中使用L”xxx”即表示用宽字符输出此字符串，也可在项目设置中设置相关配置，设置默认使用宽字符。</p></blockquote><hr><h2 id="通用字符名称"><a href="#通用字符名称" class="headerlink" title="通用字符名称"></a>通用字符名称</h2><p>由于C++程序可以使用比基础字符集更多的字符，您可以使用通用字符名称以可移植的方式指定这些字符。通用字符名称由表示 Unicode 码位的字符序列组成。可以使用两种类型进行表述，使用<code>UNNNNNNNN</code>来代表为 U+NNNNNNNN的unicode位码字符，NNNNNNNN 是八位的十六进制码位数字。使用四位的 <code>\uNNNN</code> 表示形式为 U+0000NNNN 的 Unicode 码位。<br>通用字符名称可用于标识符以及字符串和字符文字。通用字符名称不能被用于表示0xD800-0xDFFF之间之内的代理项码位，编译器会自动生成任何所需的代理项。其他限制适用于可在标识符中使用的通用字符名称。详细信息请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">Identifiers</a> 和 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">String and Character Literals</a>。</p><p><strong>特用于Microsoft的内容</strong><br>Microsoft C++ 编译器可互换地处理通用字符名称形式和文字形式的字符。例如，您可以使用通用字符名称形式声明标识符，并以文字形式使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> \u30AD = <span class="hljs-number">42</span>; <span class="hljs-comment">// \u30AD is &#x27;キ&#x27;</span><br><span class="hljs-keyword">if</span> (キ == <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// \u30AD and キ are the same to the compiler</span><br></code></pre></td></tr></table></figure><p>Windows 剪贴板上的扩展字符的格式特用于应用程序区域设置。 从另一个应用程序剪切这些字符并将其粘贴到你的代码中可能会引入意外的字符编码。 这可能会导致您的代码中出现不知原因的代码错误。我们建议在粘贴扩展的字符之前将源文件编码设置为 Unicode 代码页，以及使用 IME 或字符映射应用生成扩展的字符。</p><hr><h2 id="执行字符集"><a href="#执行字符集" class="headerlink" title="执行字符集"></a>执行字符集</h2><p><em>执行字符集</em> 表示可在编译的程序中显示的字符和字符串。 这些字符集包括源文件中允许的所有字符，以及表示警报、后空、回车符和 null 字符的控制字符。 执行字符集具有特定于区域设置的表示形式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern_C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/词法约定</title>
    <link href="/2022/08/10/Lexical-conventions/"/>
    <url>/2022/08/10/Lexical-conventions/</url>
    
    <content type="html"><![CDATA[<h1 id="词法约定"><a href="#词法约定" class="headerlink" title="词法约定"></a>词法约定</h1><p><small>Lexical conventions</small></p><p>本篇章介绍了C++程序中的基本元素。您会使用到称作“词法元素”或者说“标记”的元素构造完整程序的语句、定义和声明等。 本节将讨论以下词法元素：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/character-sets?view=msvc-170">标记和字符集</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/comments-cpp?view=msvc-170">注释</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/keywords-cpp?view=msvc-170">关键字</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/punctuators-cpp?view=msvc-170">标点符号</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/numeric-boolean-and-pointer-literals-cpp?view=msvc-170">数值、布尔和指针文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">字符串和字符文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/user-defined-literals-cpp?view=msvc-170">用户定义的文本</a></li></ul><p>有关如何分析 C++ 源文件的详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/preprocessor/phases-of-translation?view=msvc-170">转换阶段</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern_C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/欢迎回到C++ 现代C++</title>
    <link href="/2022/08/08/Welcome%20back%20to%20C++/"/>
    <url>/2022/08/08/Welcome%20back%20to%20C++/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎回到C-现代C"><a href="#欢迎回到C-现代C" class="headerlink" title="欢迎回到C++ -现代C++"></a>欢迎回到C++ -现代C++</h1><p><small>Welcome back to C++ - Modern C++</small></p><p>自从它被创建，C++逐渐成为世界上使用最广泛的语言之一。正确编写的 C++ 程序快速、高效。 相对于其他语言，该语言更加灵活：它可以在最高抽象级别上工作，也可以在芯片级（硅级别）上工作。C++ 提供高度优化的标准库。它允许访问低级硬件功能，以最大限度地提高速度并最大限度地减少内存需求。C++可以创建继续所有种类的应用：游戏、设备驱动、HPC、云、桌面、嵌入式和移动应用程序等等。甚至其他编程语言的库和编译器也是用 C++ 编写的。<br>C++的一个原始需求是向下兼容C语言。因此，C++总是允许以C风格编程，使用原始指针、数组、以空字符结尾的数组字符串<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class&#x3D;”hint–top hint–rounded” aria-label&#x3D;”及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code>“&gt;[1]</span></a></sup>以及其他功能。这或许能够拥有高效的表现，但也可以出现报错并让程序出现复杂性。C++的发展强调了一些特性，这些特性大大减少了对使用C风格语法的需要。当您需要他们时，旧式C编程工具仍然存在。但是，在现代 C++ 代码中，您应该越来越少地需要它们。现代 C++ 代码更简单、更安全、更优雅，并且仍然和以往一样快。<br>以下部分概述了现代 C++ 的主要特性。除非另有说明，此处列出的功能在 C++11 及更高版本中可用。在 Microsoft C++ 编译器中，您可以设置 &#x2F;std 编译器选项来指定要用于您的项目的标准版本。</p><h2 id="资源和智能指针"><a href="#资源和智能指针" class="headerlink" title="资源和智能指针"></a>资源和智能指针</h2><p><small>Resource and smart pointers</small><br>C风格编程中的一类主要bug是内存泄漏（确实如此，三天写代码，两天找bug）。泄漏通常是由于对使用 new 分配的内存调用 delete 失败引起的。现代 C++ 强调“资源获取即初始化”(RAII) <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="RAII，Resouce Acquisition Is Initialization:资源获取即初始化">[2]</span></a></sup>原则。 其理念很简单。 资源（堆内存、文件句柄、套接字等）应由对象“拥有”。 该对象在其构造函数中创建或接收新分配的资源，并在其析构函数中将此资源删除。 RAII 原则可确保当所属对象超出范围时，所有资源都能正确返回到操作系统。<br>为了支持对简单采用RAII的原则，C++基本库（STL）提供了三个智能指针类型: <code>std::unique_ptr</code>、<code>std::shared_ptr</code>以及<code>std::weak_ptr</code>。智能指针拥有申请和删除内存的控制句柄（智能指针处理它所拥有的内存的分配和删除）<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。">[3]</span></a></sup>。下面的示例演示了一个类，其中包含一个数组成员，该成员是在调用 <code>make_unique()</code> 时在堆上分配的。 对和的 <strong><code>new</code></strong> 调用 <strong><code>delete</code></strong> 由 <code>unique_ptr</code> 类封装。 当 <code>widget</code> 对象超出范围时，将调用 unique_ptr 析构函数，此函数将释放为数组分配的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">widget</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">widget</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> size) &#123; data = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(size); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionUsingWidget</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">widget <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;   <span class="hljs-comment">// lifetime automatically tied to enclosing scope</span><br>                <span class="hljs-comment">// constructs w, including the w.data gadget member</span><br>    <span class="hljs-comment">// ...</span><br>    w.<span class="hljs-built_in">do_something</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-comment">// automatic destruction and deallocation for w and w.data</span><br></code></pre></td></tr></table></figure><p>请尽可能使用智能指针管理堆内存（确实如此，如果没有追求极致效率的需求，使用智能指针是最方便且安全的）。 如果必须 <strong><code>new</code></strong> 显式使用和 <strong><code>delete</code></strong> 运算符，请遵循 RAII 原则。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170">对象生存期和资源管理 (RAII)</a>。</p><h2 id="std-string-和-std-string-view"><a href="#std-string-和-std-string-view" class="headerlink" title="std::string 和 std::string_view"></a>std::string 和 std::string_view</h2><p><small>std::string and std::string_view</small><br>C风格字符串是错误产生的另一个重要来源。通过使用<code>std::string</code> 和 <code>std::wstring</code>，您可以排除几乎所有和C风格字符串有联系的错误。此外，你还可以通过其成员方法获得更多字符串操作上的便利，例如搜索，追加，前缀等。两者都针对速度进行了高度优化<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》">[4]</span></a></sup>。将字符串传递给只需要只读访问权限的函数时，在 C++17 中，您可以使用 std::string_view 以获得更大的性能优势。</p><h2 id="std-vector向量和其他标准库容器"><a href="#std-vector向量和其他标准库容器" class="headerlink" title="std::vector向量和其他标准库容器"></a>std::vector向量和其他标准库容器</h2><p><small>std::string and other Standard Library containers</small><br>标准库容器都遵循 RAII 原则。 它们为安全遍历元素提供迭代器。 此外，它们对性能进行了高度优化，并且已充分测试正确性。 通过使用这些容器，可以消除自定义数据结构中可能引入的 bug 或低效问题。 使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-170"><code>vector</code></a> 替代原始数组，来作为 C++ 中的序列容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; apples;<br>apples.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Granny Smith&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 map（而不是 unordered_map），作为默认关联容器。 对于退化和多案例，使用 set、multimap 和 multiset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string, string&gt; apple_color;<br><span class="hljs-comment">// ...</span><br>apple_color[<span class="hljs-string">&quot;Granny Smith&quot;</span>] = <span class="hljs-string">&quot;Green&quot;</span>;<br></code></pre></td></tr></table></figure><p>需要进行性能优化时，请考虑以下用法：</p><ul><li>例如当重要的数据被嵌入时，将std::array类型作为类成员。</li><li>使用无序的关联容器，例如 unordered_map。 它们的每个元素的开销较低，并且具有固定时间查找功能，但正确高效地使用它们的难度更高。</li><li>使用std::vector时需要排序。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/algorithms?view=msvc-170">算法</a>。<br>不要使用 C 风格的数组。对于需要直接访问数据的旧 API，请使用访问器方法，例如 <code>f(vec.data(), vec.size());</code> 有关容器的更多信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/stl-containers?view=msvc-170">C++ 标准库容器</a>。</li></ul><h2 id="标准库算法"><a href="#标准库算法" class="headerlink" title="标准库算法"></a>标准库算法</h2><p>在假设需要为程序编写自定义算法之前，请首先查阅C++ 标准库中的算法。 标准库包含许多常见操作（如搜索、排序、筛选和随机化）的算法分类，且这些分类的算法库还在不断增加。 譬如&lt;math&gt;中的内容涵盖的很广泛。 自 C++17 起，变提供了许多算法的并行版本。<br>这里列举以下内容，比较重要。</p><ul><li><code>for_each</code>：默认遍历算法（基于范围的 for 循环）。</li><li><code>transform</code>：用于容器元素的非就地修改<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="`std::stransform` 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。">[5]</span></a></sup>。</li><li><code>find_if</code>：默认搜索算法。</li><li><code>sort</code>,<code>lower_bound</code>：排序、在一个范围内找到搜索元素的下标。以及其他排序和搜索算法。</li></ul><p>如果要写一个比较函数，可以使用lambda表达式以及’&lt;’符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> comp = [](<span class="hljs-type">const</span> widget&amp; w1, <span class="hljs-type">const</span> widget&amp; w2)<br>     &#123; <span class="hljs-keyword">return</span> w1.<span class="hljs-built_in">weight</span>() &lt; w2.<span class="hljs-built_in">weight</span>(); &#125;<br><br><span class="hljs-built_in">sort</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), comp );<br><br><span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">lower_bound</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), widget&#123;<span class="hljs-number">0</span>&#125;, comp );<br></code></pre></td></tr></table></figure><h2 id="使用auto关键字代替显示类型名称"><a href="#使用auto关键字代替显示类型名称" class="headerlink" title="使用auto关键字代替显示类型名称"></a>使用auto关键字代替显示类型名称</h2><p><small>auto instread of explicit type names</small><br>C++11引入了auto关键字，以便在变量、函数和模板的声明。auto关键字会指示编译器推导对象的类型，这样您即可无需显示键入。当对象是嵌套模板时，使用auto进行声明尤其有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;<span class="hljs-type">int</span>,list&lt;string&gt;&gt;::iterator i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// C-style</span><br><span class="hljs-keyword">auto</span> i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// modern C++</span><br></code></pre></td></tr></table></figure><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p><small>Range-based for loops</small><br>对数组和容器的C风格迭代容易出现索引错误，且重复的键入过程单调乏味。要消除这些错误并使您的代码更具可读性，请使用基于范围的 for 循环以及标准库容器和原始数组。有关详细信息，请参阅请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170">基于范围的</a> (<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)%E8%AF%AD%E5%8F%A5%E3%80%82">https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)语句。</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// C-style</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>        std::cout &lt;&lt; v[i];<br>    &#125;<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : v)&#123;<br>        std::cout &lt;&lt; num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>译注：<br>使用for_each虽然可以极大的提高for效率，但是如果在处理极大数据时或极长文本时请谨慎使用。因为其会将内容复制一份进行遍历。</p><h2 id="用-constexpr-表达式替代宏"><a href="#用-constexpr-表达式替代宏" class="headerlink" title="用 constexpr 表达式替代宏"></a>用 <code>constexpr</code> 表达式替代宏</h2><p>C 和 C++ 中的宏是在编译前由预处理器处理的一种标记。在编译代码之前，编译器会将使用宏定义的地方替换成宏所定义的值。C 样式编程通常使用宏来定义编译时常量值。 但宏容易出错且难以调试。 在现代 C++ 中，应优先使用 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/constexpr-cpp?view=msvc-170"><code>constexpr</code></a> 变量定义编译时常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 10 <span class="hljs-comment">// C-style</span></span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>; <span class="hljs-comment">// modern C++</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number = <span class="hljs-number">114514</span>;<br><br></code></pre></td></tr></table></figure><h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>在现代 C++ 中，可以使用任何类型的括号初始化。 在初始化数组、矢量或其他容器时，这种初始化形式会非常方便。在下面的这个例子中声明了一个类S，三个均为std::vetor(向量)类型的变量v1,v1,v3并用不同方式进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br>    std::string name;<br>    <span class="hljs-type">float</span> num;<br>    <span class="hljs-built_in">S</span>(std::string s, <span class="hljs-type">float</span> f) : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">num</span>(f) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// C-style initialization</span><br>    std::vector&lt;S&gt; v;<br>    <span class="hljs-function">S <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>)</span></span>;<br><br>    v.<span class="hljs-built_in">push_back</span>(s1);<br>    v.<span class="hljs-built_in">push_back</span>(s2);<br>    v.<span class="hljs-built_in">push_back</span>(s3);<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    std::vector&lt;S&gt; v2 &#123;s1, s2, s3&#125;;<br><br>    <span class="hljs-comment">// or...</span><br>    std::vector&lt;S&gt; v3&#123; &#123;<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>&#125;, &#123;<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>&#125;, &#123;<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>&#125; &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>若要了解详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/initializing-classes-and-structs-without-constructors-cpp?view=msvc-170">括号初始化</a>。</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>现代 C++ 提供了移动语义，此功能可以避免进行不必要的内存复制。 在此语言的早期版本中，在某些情况下无法避免复制。 移动操作会将资源的所有权从一个对象转移到下一个对象，而不必再进行复制。 一些类拥有堆内存、文件句柄等资源。 实现资源所属的类时，可以定义此类的移动构造函数和移动赋值运算符。 在解析重载期间，如果不需要进行复制，编译器会选择这些特殊成员。 如果定义了移动构造函数，则标准库容器类型会在对象中调用此函数。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符 (C++)</a>。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>在使用C语法编程中，一个函数可以通过返回函数指针的方式传递给另一个函数，这不方便位于和理解。它们引用的函数可能在源代码的其他地方定义，而不是从调用它的位置定义的。而且他们不是类型安全的。现代C++提供了对函数对象、类的运算符重写，从而使它们可以像函数一样进行调用。创建函数对象的最简便方法是使用内联 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">lambda 表达式</a>。 下面的示例演示如何使用 lambda 表达式传递函数对象，然后由 <code>for_each</code> 函数在vector的每个元素中调用此函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">find_if</span>(<span class="hljs-built_in">begin</span>(v), <span class="hljs-built_in">end</span>(v), [=](<span class="hljs-type">int</span> i) &#123; <br>    <span class="hljs-keyword">return</span> i &gt; x &amp;&amp; i &lt; y; <br>    &#125;<br>    );<br></code></pre></td></tr></table></figure><p>Lambda表达式的形式为<code>[]()&#123;&#125;</code>，这里的是<code>[=](int i) &#123; return i &gt; x &amp;&amp; i &lt; y; &#125;</code>。此函数有一个int类型的形参，并返回一个bool类型的值，指示该参数是否大于 <code>x</code> 且小于 <code>y</code>。这里使用的x,y是lambda之前声明的两个变量。行为上看似是[&#x3D;]接受了上文的变量，实际上是lambda接受了值的副本。有关更详细的内容请看相关专题。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><small>Exceptions</small><br>现代 c + + 强调异常，而不是错误代码，作为报告和处理错误条件的最佳方式。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-170">现代 C++ 处理异常和错误的最佳做法</a>。</p><h2 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h2><p>对线程间通信机制使用 C++ 标准库 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/atomic-structure?view=msvc-170"><code>std::atomic</code></a> 结构和相关类型。</p><h2 id="std-variant-C-17"><a href="#std-variant-C-17" class="headerlink" title="std::variant(C++17)"></a>std::variant(C++17)</h2><p>在以C风格编程程序时通过使用联合体（共用体）使不同类型的成员占据同一个内存位置而达到节约内存的目的。但这并不是安全的，并容易导致编译错误。 C++17 引入了更加安全可靠的 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-class?view=msvc-170"><code>std::variant</code></a> 类，来作为联合体（共用体）的替代项。可以使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-functions?view=msvc-170#visit"><code>std::visit</code></a> 函数以类型安全的方式访问 <code>variant</code> 类型的成员。</p><hr><p><strong>译者有话说</strong><br>本页的上述的示例代码为微软参考手册的简单案例，本人会在下方附上个人理解的完整代码。此部分代码也可以移步至<a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp: Code example of Microsoft modern C + + vs2022 translation (github.com)</a>进行阅览，请原谅本人代码水平不精，谢谢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;id)<br>        : <span class="hljs-built_in">stu_name</span>(name), <span class="hljs-built_in">stu_id</span>(id)&#123;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_name;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_id;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetCollege</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_college;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetCollage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string college)</span> </span>&#123;<br>        stu_college = college;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> std::string stu_name;<br>    <span class="hljs-type">const</span> std::string stu_id;<br>    std::string stu_college&#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> student = std::<span class="hljs-built_in">make_unique</span>&lt;Student&gt;(<span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>);<br>    std::cout &lt;&lt; student-&gt;<span class="hljs-built_in">GetId</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; (*student).<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">auto</span> ptr_stu = student.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// if smart pointer is released, this raw pointer will be null</span><br>    ptr_stu-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;computr network&quot;</span>);<br>    std::cout &lt;&lt; ptr_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">auto</span> share_stu = std::<span class="hljs-built_in">make_shared</span>&lt;Student&gt;(<span class="hljs-string">&quot;114&quot;</span>, <span class="hljs-string">&quot;1919810&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">share_stu_1</span><span class="hljs-params">(share_stu)</span></span>;<br>    share_stu_1-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;communication engineering&quot;</span>);<br>    std::cout &lt;&lt; share_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br>&#125;<br><br>  <br><br><span class="hljs-comment">// make_unique (C++14) creates a unique poniter that manages a new object</span><br><span class="hljs-comment">// make_unique_for_overwrite (C++20)</span><br></code></pre></td></tr></table></figure><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>RAII，Resouce Acquisition Is Initialization:资源获取即初始化<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><code>std::stransform</code> 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Modern_C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/C++语言参考</title>
    <link href="/2022/08/07/C++%20Language%20Reference/"/>
    <url>/2022/08/07/C++%20Language%20Reference/</url>
    
    <content type="html"><![CDATA[<p><strong>前言赘叙</strong><br>本系列文档是对于微软文档《Modern C++ vs2022》进行翻译并插入一定的个人见解。个人之力翻译可能并不标准，还望海涵，也请多多指点。敝人也尝试通过这次机会向大家分享，也希望个人也能在代码造诣上得到提高。为了能够帮助理解，本人也创建了一个仓库，会在接下来使用代码的地方进行插入，当然也欢迎直接阅读示例demo</p><p>点击此处可浏览仓库 <a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp</a><br>点击此处可浏览原文 <a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=msvc-170">C++ Language Reference | Microsoft Docs</a></p><hr><h1 id="C-语言参考"><a href="#C-语言参考" class="headerlink" title="C++语言参考"></a>C++语言参考</h1><p><em>C++ Language Reference</em></p><p>本参考说明了在 Microsoft C++ 编译器中实现的 C++ 编程语言。该组织基于 Margaret Ellis 和 Bjarne Stroustrup 的 The Annotated C++ Reference Manual 以及 ANSI&#x2F;ISO C++ 国际标准 (ISO&#x2F;IEC FDIS 14882)。包括 Microsoft 特定的 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果">[1]</span></a></sup>C++ 语言功能实现。<br>有关现代 C++ 编程实践的概述，请参阅《<a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>》<br>请参阅下表以快速找到关键字或运算符：</p><ul><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170">C++ Keywords</a> （C++关键字）</li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">C++ Operators</a>（C++操作符）</li></ul><h1 id="在这个部分"><a href="#在这个部分" class="headerlink" title="在这个部分"></a>在这个部分</h1><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lexical-conventions?view=msvc-170">Lexical Conventions</a>  词汇约定<br>C++程序的基本词法元素：预定义字符（标记）、注释、操作符、关键字、标点符号、字符串。此外还有：文件转译（文件操作）、运算符优先级&#x2F;关联性。</p><blockquote><p>Fundamental lexical elements of a C++ program: tokens, comments, operators, keywords, punctuators, literals. Also, file translation, operator precedence&#x2F;associativity.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/basic-concepts-cpp?view=msvc-170">Basic Concepts</a>  基本概念<br>范围、链接、程序的启动和终止、存储类和类型。</p><blockquote><p>Scope, linkage, program startup and termination, storage classes, and types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-170">Built-in types</a> 内置类型<br>C++编译器中内置的基本类型及其取值范围。</p><blockquote><p>The fundamental types that are built into the C++ compiler and their value ranges.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-170">Standard Conversions</a>  标准转换<br>内置类型之间的类型转换。此外，指针、引用和指向成员的类型之间的算术转换和转换。</p><blockquote><p>Type conversions between built-in types. Also, arithmetic conversions and conversions among pointer, reference, and pointer-to-member types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/declarations-and-definitions-cpp?view=msvc-170">Declarations and definitions</a> 声明和定义<br>声明和定义变量、类型和函数。</p><blockquote><p>Declaring and defining variables, types and functions.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">Operators, Precedence and Associativity</a><br>运算符、优先级和关联性<br>C++中的运算符。</p><blockquote><p>The operators in C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/expressions-cpp?view=msvc-170">Expressions</a>  表达式<br>表达式的类型、表达式的语义、运算符的参考主题、强制转换和强制转换运算符、运行时类型信息。</p><blockquote><p>Types of expressions, semantics of expressions, reference topics on operators, casting and casting operators, run-time type information.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">Lambda Expressions</a>  Lambda表达式<br>一种隐式定义函数对象类并构造该类类型的函数对象的编程技术。</p><blockquote><p>A programming technique that implicitly defines a function object class and constructs a function object of that class type.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/statements-cpp?view=msvc-170">Statements</a>  语句<br>表达式、null空值、复合语句、选择、迭代、跳转和声明语句。</p><blockquote><p>Expression, null, compound, selection, iteration, jump, and declaration statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/classes-and-structs-cpp?view=msvc-170">Classes and structs</a>  类和结构体<br>对于类、结构体和共用体的介绍。此外也有，成员函数、特殊成员函数、数据成员、位字段、this指针，嵌套类。</p><blockquote><p>Introduction to classes, structures, and unions. Also, member functions, special member functions, data members, bit fields, <strong><code>this</code></strong> pointer, nested classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/unions?view=msvc-170">Unions</a>  联合体<br>用户定义类型，其中所有成员共享同一内存位置。</p><blockquote><p>User-defined types in which all members share the same memory location.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/inheritance-cpp?view=msvc-170">Derived Classes</a>  派生类<br>单个和多个继承、虚函数、多继承、抽象类、范围规则。 此外，还有__super和__interface关键字。</p><blockquote><p>Single and multiple inheritance, <strong><code>virtual</code></strong> functions, multiple base classes, <strong>abstract</strong> classes, scope rules. Also, the <strong><code>__super</code></strong> and <strong><code>__interface</code></strong> keywords.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/member-access-control-cpp?view=msvc-170">Member-Access Control</a>  成员访问控制<br>控制对类成员的访问： public、 private关键字和 protected 关键字。 友元函数和友元类。</p><blockquote><p>Controlling access to class members: <strong><code>public</code></strong>, <strong><code>private</code></strong>, and <strong><code>protected</code></strong> keywords. Friend functions and classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/operator-overloading?view=msvc-170">Overloading</a>  重载<br>重载运算符，对运算符重载的规则。</p><blockquote><p>Overloaded operators, rules for operator overloading.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/exception-handling-in-visual-cpp?view=msvc-170">Exception Handling</a>  异常处理<br>C++ 异常处理、结构化异常处理 (SEH)、用于编写异常处理语句的关键字。</p><blockquote><p>C++ exception handling, structured exception handling (SEH), keywords used in writing exception handling statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/assertion-and-user-supplied-messages-cpp?view=msvc-170">Assertion and User-Supplied Messages</a>  断言和User-Supplied消息<br>#error 指令， static_assert 关键字， assert 宏。</p><blockquote><p><code>#error</code> directive, the <strong><code>static_assert</code></strong> keyword, the <code>assert</code> macro.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/templates-cpp?view=msvc-170">Templates</a>  模板<br>模板规范、函数模板、类模板、typename 关键字、模板对比于宏定义、模板和智能指针。</p><blockquote><p>Template specifications, function templates, class templates, <strong><code>typename</code></strong> keyword, templates vs. macros, templates and smart pointers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/event-handling?view=msvc-170">Event Handling</a>  事件处理<br>定义事件和事件处理程序</p><blockquote><p>Declaring events and event handlers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-specific-modifiers?view=msvc-170">Microsoft-Specific Modifiers</a>  独属于微软(msvc)的修饰符<br>Microsoft C++ 专用修饰符。 内存寻址、调用约定、naked函数、扩展存储类属性 (__declspec) 。 __w64</p><blockquote><p>Modifiers specific to Microsoft C++. Memory addressing, calling conventions, <strong><code>naked</code></strong> functions, extended storage-class attributes (<strong><code>__declspec</code></strong>), <strong><code>__w64</code></strong>.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/inline-assembler?view=msvc-170">Inline Assembler</a>  内联汇编程序<br>在__asm块中使用汇编语言和C++。</p><blockquote><p>Using assembly language and C++ in <strong><code>__asm</code></strong> blocks.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/compiler-com-support?view=msvc-170">Compiler COM Support</a>  编译器对COM的支持<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。">[2]</span></a></sup><br>有关用于支持 COM 类型的 Microsoft 专用类和全局函数的参考。</p><blockquote><p>A reference to Microsoft-specific classes and global functions used to support COM types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-extensions?view=msvc-170">Microsoft Extensions</a>  Microsoft的拓展<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等">[3]</span></a></sup><br>Microsoft微软对C++进行的扩展</p><blockquote><p>Microsoft extensions to C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/nonstandard-behavior?view=msvc-170">Nonstandard Behavior</a>  非标准行为<br>有关Microsoft C++编译器的非标准行为的信息。<br>Information about nonstandard behavior of the Microsoft C++ compiler.</p><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>  欢迎回到C++<br>一篇现代C + +编程实践概述，指引编写安全、正确、高效的程序。</p><blockquote><p>An overview of modern C++ programming practices for writing safe, correct and efficient programs.</p></blockquote><hr> <section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Modern_C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一篇闲言碎语</title>
    <link href="/2022/08/07/another-gossip/"/>
    <url>/2022/08/07/another-gossip/</url>
    
    <content type="html"><![CDATA[<h1 id="另一篇闲言碎语"><a href="#另一篇闲言碎语" class="headerlink" title="另一篇闲言碎语"></a>另一篇闲言碎语</h1><p>对于hexo我的技术力实在是太低了，于是乎就在hexo的主题库中找了一个–“anatole”非常的不错。其中一个巨大的原因是因为我发现我忘记怎么设计网页了，回忆以前还知道玩玩什么jqury,boostrapl，如果回到18年甚至可以手撸css,js。奈何现在是一位大专两年级的学生，除了每顿猛造两碗饭，其他的都忘记了。<br>所以坦白一下我是如何做了这个稀烂的主页的。</p><hr><p>首先用日常是开了一个科学上网，用winget把nodejs给整上，迅速的安装一波hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>npm install hexo<br>hexo init &lt;blog-name&gt;<br>cd &lt;blog-name&gt;<br>npm install<br></code></pre></td></tr></table></figure><p>对了，如果不能直接用hexo指令的话可以配置一下</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 &#96;hexo <command><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></li></ol><hr><p>上述步骤完成后，就是抄一个主题下来。感谢hexo设计的很简单，让我一下子就上手了。<br>把主题文件放到themes下就可以了，比如我的是<strong>E:\blog\themes\anatole</strong><br><small><em>什么？如何安装主题，当然是点一个然后 <code>git clone</code>下来哦</em></small></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole<br>cd anatole<br>git pull<br>npm install --save hexo-render-pug hexo-generator-archive hexo-generator-tag hexo-generator-index hexo-generator-category<br></code></pre></td></tr></table></figure><p>然后在_config.yml里填写一个特殊的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">archive_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>每一个主题的安装都不尽相同，所以得按照自己挑选的主题来进行配置。</strong></p><hr><p>按照主题的官网wiki配置一通以后，发现下面那个小蓝鸟，小粪坑不知道怎么关闭2333。在尝试去ejs中修改的我也放弃了。对了，这里要坦白我学会怎么修改favicon以及logo，于是就去主题中修改了源图标[手动狗头]。好了，今日吹水到此结束，明日（或许）开始认真更新一些东西。<br>顺便在下面贴上使用的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br>  <br><br><span class="hljs-comment"># Site</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">CvRaindays</span><br><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">std::shared_ptr&lt;Blog&gt;</span> <span class="hljs-string">CvRain(this);</span><br><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">C,C++,Linux</span><br><br><span class="hljs-attr">author:</span> <span class="hljs-string">CvRaindays,cvraindays@outlook.com</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-cn</span><br><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># URL</span><br><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://example.com</span><br><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><br><span class="hljs-attr">permalink_defaults:</span><br><br><span class="hljs-attr">pretty_urls:</span><br><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br>  <br><br><span class="hljs-comment"># Directory</span><br><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><br><span class="hljs-attr">skip_render:</span> <span class="hljs-string">README.md</span><br><br>  <br><br><span class="hljs-comment"># Writing</span><br><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><br><span class="hljs-attr">external_link:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">highlight:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">prismjs:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Home page setting</span><br><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><br><span class="hljs-attr">index_generator:</span><br><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br>  <br><br><span class="hljs-comment"># Category &amp; Tag</span><br><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><br><span class="hljs-attr">category_map:</span><br><br><span class="hljs-attr">tag_map:</span><br><br>  <br><br><span class="hljs-comment"># Metadata elements</span><br><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br>  <br><br><span class="hljs-comment"># Date / Time format</span><br><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Pagination</span><br><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br>  <br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><br><span class="hljs-attr">include:</span><br><br><span class="hljs-attr">exclude:</span><br><br><span class="hljs-attr">ignore:</span><br><br>  <br><br><span class="hljs-comment"># Extensions</span><br><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><br><span class="hljs-attr">theme:</span> <span class="hljs-string">anatole</span><br><br>  <br><br><span class="hljs-comment"># Deployment</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><br>  <br><br><span class="hljs-attr">deploy:</span><br><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/CvRain/cvrain.github.io.git</span><br><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br><br>  <br><br><span class="hljs-attr">archive_generator:</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br><br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好世界！</title>
    <link href="/2022/08/07/hello-world/"/>
    <url>/2022/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>经过了三个小时的辛苦劳作，鱼师傅成功摸出来一个HelloWorld!<br>第一篇blog，准备先写个小记作为一个段子乐呵乐呵。 </p><hr><h2 id="一盘饺子"><a href="#一盘饺子" class="headerlink" title="一盘饺子"></a>一盘饺子</h2><p>属实是有了一壶好醋，也是可怜了我的Surface Go2，跟着我并没有享受到作为“高端”电子设备的万千宠爱，反而是被不断刷机。不是因为购买的是丐版，而且其配置加上Windows11略有拉跨。不得不研究如何在上面刷一套Linux操作系统用来满足个人需求，提高工作效率。具体的相关情况请看后文内容，本篇小作文仅作为一个引子。<br>说回来，Go系列的刷系统确实难受，翻烂了各种帖子，总算是总结出一套目前看最完善的装系统经验。回味过来笔者果然是无聊透顶，可能坚持捣鼓刷系统的也没有多少了吧，当然也可以和个人性格以及家庭有些许关系。<br>准备录制一个视频和大家分享分析，经过一晚上的辗转反侧来看，还是需要写个什么东西使得叙述更完整一点。那就不如自己搞个博客吧！或许也只会发少量的东西，不过说不好也不好说。</p><h2 id="做些什么"><a href="#做些什么" class="headerlink" title="做些什么"></a>做些什么</h2><p>就目前看来，或许会更新一些个人在编程上的小经验，不过和其他奆佬比起来就是腐草荧光了。未来可能尝试自己做一个Hexo的主题（不过感觉60%要泡汤了），然后写一点关于模组教程的小作文。嗯，似乎没了。</p><h2 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h2><p>感觉自己越来越不会说话了，文采也不太行了。还没到老年却也喜欢絮絮叨叨一番。身心格外的疲倦，也不知道为什么，还是按时吃药吧，或许问题不大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
