<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Slint 内置枚举元素</title>
    <link href="/2024/01/28/Slint/builtin-enumerations/"/>
    <url>/2024/01/28/Slint/builtin-enumerations/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-内置枚举元素"><a href="#Slint-内置枚举元素" class="headerlink" title="Slint 内置枚举元素"></a>Slint 内置枚举元素</h1><h2 id="AccessibleRole"><a href="#AccessibleRole" class="headerlink" title="AccessibleRole"></a><code>AccessibleRole</code></h2><p> 此枚举表述了<code>accessible-role</code>属性中的不同值， 用于描述辅助技术（例如屏幕阅读器）中元素的作用。</p><ul><li><code>none</code> 此元素是不可访问的</li><li><code>button</code> 此元素是一个<code>Button</code>组件其或者行为类似<code>Button</code></li><li><code>checkbox</code> 此元素是一个<code>CheckBox</code>或者其行为类型<code>CheckBox</code></li><li><code>combobox</code> 此元素是一个<code>ComboBox</code>或者其行为类型<code>ComboBox</code></li><li><code>slider</code> 此元素是一个<code>Slider</code>或者其行为类型<code>Slider</code></li><li><code>spinbox</code> 此元素是一个<code>SpinBox</code>或者其行为类型<code>SpinBox</code></li><li><code>tab</code> 此元素是一个<code>Tab</code>或者其行为类型<code>Tab</code></li><li><code>text</code> 此元素是一个<code>Text</code>或者其行为类型<code>Text</code></li><li><code>progress-indicator</code> 此元素是一个<code>ProcessIndicator</code>或者其行为类型<code>ProcessIndicator</code></li></ul><h2 id="DialogButtonRole"><a href="#DialogButtonRole" class="headerlink" title="DialogButtonRole"></a><code>DialogButtonRole</code></h2><p>此枚举表示<code>dialog-button-role</code>属性的值，该属性可以添加到<code>Dialog</code>的任何元素以将该项目放入按钮行中，其确切位置取决于角色和平台。</p><ul><li><code>none</code> 这个按钮不是用来进入最下面一排的</li><li><code>accept</code> 此规则让主按钮点击后为确认对话框，如“确实”或者”是“</li><li><code>reject</code>  此规则让主按钮点击为拒绝对话框，如“取消”或者”不“</li><li><code>apply</code> “Apply（接受）”按钮的职责</li><li><code>reset</code>“Rest （重置）” 按钮的职责</li><li><code>help</code> “Help（帮助）”按钮的职责</li><li><code>action</code>  执行其他操作的任何其他按钮的的功能。</li></ul><h2 id="EventResult"><a href="#EventResult" class="headerlink" title="EventResult"></a><code>EventResult</code></h2><p>该枚举描述事件处理程序是否拒绝或接受事件。</p><ul><li><code>reject</code>  该事件被此事件处理程序拒绝，然后可能由父项处理</li><li><code>accept</code> 该事件已被接受，不会进一步处理</li></ul><h2 id="FillRule"><a href="#FillRule" class="headerlink" title="FillRule"></a><code>FillRule</code></h2><p>该枚举描述了决定路径所描述的形状内部应该是什么的不同方法。</p><ul><li><strong><code>nonzero</code></strong>: The <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule#nonzero">“nonzero” fill rule as defined in SVG</a>.</li><li><strong><code>evenodd</code></strong>: The <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule#evenodd">“evenodd” fill rule as defined in SVG</a></li></ul><h2 id="ImageFit"><a href="#ImageFit" class="headerlink" title="ImageFit"></a><code>ImageFit</code></h2><p>该枚举定义了图片资源在<code>Image</code>组件中怎样的适配方式</p><ul><li><code>fill</code> 图片的尺寸和缩放根据<code>Image</code>元素的宽度和高度自己适配</li><li><code>contain</code> 源图像被缩放以适应图像元素的尺寸，同时保留纵横比。</li><li><code>cover</code> 源图像被缩放以覆盖图像元素的尺寸，同时保留纵横比。如果源图像的长宽比与元素的长宽比不匹配，则图像将被剪裁以适合。</li></ul><h2 id="ImageRendering"><a href="#ImageRendering" class="headerlink" title="ImageRendering"></a><code>ImageRendering</code></h2><p>该枚举指定如何缩放源图像。</p><ul><li><code>smooth</code> 使用线性插值算法缩放图像。</li><li><code>pixelated</code> 使用最近邻算法缩放图像。</li></ul><h1 id="InputType"><a href="#InputType" class="headerlink" title="InputType"></a><code>InputType</code></h1><p>该枚举用于定义输入字段的类型。</p><ul><li><code>text</code> 默认值。以标准的方式渲染所有的字符</li><li><code>password</code> 默认的将所有的字符均渲染为“*”</li><li><code>number</code> 输入将只能接受并渲染数字字符（0-9）</li><li><code>decimal</code> 如果字符是小数的有效部分，这将接受并呈现字符</li></ul><h2 id="LayoutAlignment"><a href="#LayoutAlignment" class="headerlink" title="LayoutAlignment"></a><code>LayoutAlignment</code></h2><p>枚举类型描述了在<code>HorizontalBox</code>, <code>VerticalBox</code>, <code>HorizontalLayout</code>, <code>VerticalLayout</code>中的布局对其方式</p><ul><li><code>stretch</code> 使用布局中所有元素的最小大小，在所有元素之间基于 <code>*-stretch </code>分配剩余空间。</li><li><code>center</code> 对所有元素使用首选大小，在第一个元素之前和最后一个元素之后均匀分配剩余空间。</li><li><code>start</code> 对所有元素使用首选大小，将剩余空间放在最后一个元素之后。</li><li><code>end</code> 对所有元素使用首选大小，将剩余空间放在第一个元素之前。</li><li><code>space-between</code> 对所有元素使用首选大小，在元素之间均匀分配剩余空间。</li><li><code>space-around</code> 对所有元素使用首选大小，在第一个元素之前、最后一个元素之后以及元素之间均匀分配剩余空间。</li></ul><h2 id="MouseCurosr"><a href="#MouseCurosr" class="headerlink" title="MouseCurosr"></a><code>MouseCurosr</code></h2><p>该枚举代表不同类型的鼠标光标。它是 CSS 中可用鼠标光标的子集。有关详细信息和象形图，请参阅光标的 MDN 文档(<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values">MDN Documentation for cursor</a>)。根据后端和使用的操作系统，单向调整大小光标可能会替换为双向光标。</p><ul><li><strong><code>default</code></strong>: 系统默认的光标</li><li><strong><code>none</code></strong>: 无光标展示。</li><li><strong><code>help</code></strong>: 表明是帮助信息的光标。</li><li><strong><code>pointer</code></strong>: 表示为具有链接的光标。</li><li><strong><code>progress</code></strong>: 程序正在忙，但仍然可以交互。</li><li><strong><code>wait</code></strong>:  程序正在忙，需要等待。</li><li><strong><code>crosshair</code></strong>: 一个十字线   。</li><li><strong><code>text</code></strong>:  选中文本。</li><li><strong><code>alias</code></strong>: 正在创建别名或快捷方式。</li><li><strong><code>copy</code></strong>: 一个副本已被创建。</li><li><strong><code>move</code></strong>: 某些东西被移动了。</li><li><strong><code>no-drop</code></strong>: 一些东西不能往这里丢。</li><li><strong><code>not-allowed</code></strong>: 一个不被允许的行为。</li><li><strong><code>grab</code></strong>: 有东西是可以抓住的。</li><li><strong><code>grabbing</code></strong>: 有东西被抓住了。</li><li><strong><code>col-resize</code></strong>: 指示列可水平调整大小。</li><li><strong><code>row-resize</code></strong>: 指示行可垂直调整大小。</li><li><strong><code>n-resize</code></strong>: 向北单向调整大小。</li><li><strong><code>e-resize</code></strong>: 向东单向调整大小。</li><li><strong><code>s-resize</code></strong>: 向南单向调整大小。</li><li><strong><code>w-resize</code></strong>: 向西单向调整大小。</li><li><strong><code>ne-resize</code></strong>: 向东北方向单向调整大小。</li><li><strong><code>nw-resize</code></strong>: 向西北单向调整大小。</li><li><strong><code>se-resize</code></strong>: 单向调整东南方向大小。</li><li><strong><code>sw-resize</code></strong>: 向西南方向单向调整大小。</li><li><strong><code>ew-resize</code></strong>: 东西向双向调整大小。</li><li><strong><code>ns-resize</code></strong>: 南北双向调整大小。</li><li><strong><code>nesw-resize</code></strong>: 东北-西南双向调整大小。</li><li><strong><code>nwse-resize</code></strong>: 西北-东南方向双向调整大小。</li></ul><h2 id="Orientation"><a href="#Orientation" class="headerlink" title="Orientation"></a><code>Orientation</code></h2><p>表示元素或小部件（例如滑块）的方向。</p><ul><li><code>horizontal</code>: 水平元素定向</li><li><code>vertical</code>: 垂直元素定向</li></ul><h2 id="PathEvent"><a href="#PathEvent" class="headerlink" title="PathEvent"></a><code>PathEvent</code></h2><p>PathEvent 是描述路径组成的低级数据结构。通常，它是在编译时根据更高级别的描述（例如 SVG 命令）生成的。</p><ul><li>**<code>begin</code>**：路径的开始。  </li><li>**<code>line</code>**：路径上的直线。  </li><li>**<code>quadratic</code>**：路径上的二次贝塞尔曲线。  </li><li>**<code>cubic</code>**：路径上的三次贝塞尔曲线。  </li><li>**<code>end-open</code>**：保持开放的路径末端。  </li><li>**<code>end-closed</code>**：闭合路径的末端。</li></ul><h2 id="PointerEventButton"><a href="#PointerEventButton" class="headerlink" title="PointerEventButton"></a><code>PointerEventButton</code></h2><p>该枚举描述了指针事件的不同类型的按钮，通常是鼠标或铅笔上的按钮。</p><ul><li><code>other</code>： 非左、右、中按钮。例如，这用于具有多个按钮的鼠标上的第四个按钮。</li><li><code>left</code>：左按钮。</li><li><code>right</code>：右按钮。</li><li><code>middle</code>：中按钮。</li></ul><h2 id="PointerEventKind"><a href="#PointerEventKind" class="headerlink" title="PointerEventKind"></a><code>PointerEventKind</code></h2><p>枚举描述了 <code>PointerEventButton</code> 事件中存在的元素</p><ul><li><code>cancel</code>：行动被取消了。</li><li><code>down</code>：按钮被按下了。</li><li><code>up</code>：按钮被释放了（抬起按钮）。</li></ul><h2 id="SortOrder"><a href="#SortOrder" class="headerlink" title="SortOrder"></a><code>SortOrder</code></h2><p>该枚举表示排序顺序属性的不同值。它用于按列对 <a href="https://slint.dev/releases/1.3.2/docs/slint/src/language/widgets/standardtableview.html"><code>StandardTableView</code></a> 进行排序。</p><ul><li><code>unsorted</code>：此列未能排序。</li><li><code>ascending</code>：该列按升序排序。</li><li><code>descending</code>：该列按降序排序。</li></ul><h2 id="StandardButtonKind"><a href="#StandardButtonKind" class="headerlink" title="StandardButtonKind"></a><code>StandardButtonKind</code></h2><p>使用此枚举将标准按钮添加到<a href="https://slint.dev/releases/1.3.2/docs/slint/src/language/builtins/elements.html#dialog"><code>Dialog</code></a>中。这些<a href="https://slint.dev/releases/1.3.2/docs/slint/src/language/widgets/standardbutton.html"><code>StandardButton</code></a>标准按钮的外观和位置取决于应用程序运行的环境（操作系统、UI 环境等）。</p><p>（按照本人的理解是，在一个弹出的对话框中可以添加多个按钮，每个按钮有不同作用以及相对应的功能）</p><ul><li><code>ok</code>：接受对话框的“确定”按钮，单击时将其关闭。</li><li><code>cancel</code>：一个“取消”按钮，用于拒绝对话框，单击时将其关闭。</li><li><code>apply</code>：一个“应用”按钮，应该接受来自对话框的值而不关闭它。</li><li><code>close</code>：“关闭”按钮，它应该关闭对话框而不查看值。</li><li><code>reset</code>：“重置”按钮，该按钮应将对话框重置为其初始状态。</li><li><code>help</code>：“帮助”按钮，单击时应显示上下文相关文档。</li><li><code>yes</code>：“是”按钮，用于确认操作。</li><li><code>no</code>：“否”按钮，用于拒绝操作。</li><li><code>abort</code>：“中止”按钮，用于中止操作。</li><li><code>retry</code>：“重试”按钮，用于重试失败的操作。</li><li><code>ignore</code>：“忽略”按钮，用于忽略失败的操作。</li></ul><h2 id="TextHorizontalAlignment"><a href="#TextHorizontalAlignment" class="headerlink" title="TextHorizontalAlignment"></a><code>TextHorizontalAlignment</code></h2><p>该枚举描述了文本沿 Text 元素水平轴的不同类型的对齐方式。</p><ul><li><code>left</code>：文本将与包含框的左边缘对齐。</li><li><code>center</code>：文本将在包含框中水平居中。</li><li><code>right</code>：文本将与包含框的右侧对齐。</li></ul><h2 id="TextOverflow"><a href="#TextOverflow" class="headerlink" title="TextOverflow"></a><code>TextOverflow</code></h2><p>该枚举描述了当文本太宽而无法适应文本宽度时文本的显示方式。</p><ul><li><code>clip</code>：文本将被简单地剪切。</li><li><code>elide</code>：多出的文本会以省略号呈现</li></ul><h2 id="TextVerticalAlignment"><a href="#TextVerticalAlignment" class="headerlink" title="TextVerticalAlignment"></a><code>TextVerticalAlignment</code></h2><p>该枚举描述了文本沿 Text 元素垂直轴的不同类型的对齐方式。</p><ul><li><code>top</code>：文本将与包含框的顶部对齐。</li><li><code>center</code>：文本将在包含框中垂直居中。</li><li><code>bottom</code>：文本将与包含框的底部对齐。</li></ul><h2 id="TextWrap"><a href="#TextWrap" class="headerlink" title="TextWrap"></a><code>TextWrap</code></h2><p>该枚举描述了文本太宽而无法适应文本宽度时如何换行。</p><ul><li><code>no-warp</code>：文本不会换行，而是会溢出。</li><li><code>word-warp</code>：文本将在单词边界处换行。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 内置元素</title>
    <link href="/2024/01/27/Slint/builtin-elements/"/>
    <url>/2024/01/27/Slint/builtin-elements/</url>
    
    <content type="html"><![CDATA[<h1 id="内置元素"><a href="#内置元素" class="headerlink" title="内置元素"></a>内置元素</h1><h2 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h2><h3 id="几何坐标"><a href="#几何坐标" class="headerlink" title="几何坐标"></a>几何坐标</h3><p>这些属性对所有可见项目都有效：</p><ul><li><code>width</code> 和 <code>height</code> (length)：元素的尺寸，被设置后可以重写默认的大小</li><li><code>x</code>和<code>y</code>（length）：元素相对于其父级元素的偏移位置</li><li><code>z</code>(float)：允许指定不同的顺序来将项目与其同级项目堆叠。 （默认值：0）</li><li><code>absolute-position</code>(float)：元素在所包含窗口中的位置。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 内置函数-回调</title>
    <link href="/2024/01/27/Slint/builtin-callbacks/"/>
    <url>/2024/01/27/Slint/builtin-callbacks/</url>
    
    <content type="html"><![CDATA[<h1 id="内置回调函数"><a href="#内置回调函数" class="headerlink" title="内置回调函数"></a>内置回调函数</h1><h1 id="init"><a href="#init" class="headerlink" title="init()"></a><code>init()</code></h1><p>每一个组件都隐式定义了一个<code>init</code>回调函数。您可以为其分配一个代码块，该代码块将在实例化元素时以及使用其最终绑定的值初始化所有属性后调用。调用顺序是从内到外。以下示例将打印“first”，然后“second”，然后“third”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component MyButton inherits Rectangle &#123;<br>    in-out property &lt;string&gt; text: &quot;Initial&quot;;<br>    init =&gt; &#123;<br>        // If `text` is queried here, it will have the value &quot;Hello&quot;.<br>        debug(&quot;first&quot;);<br>    &#125;<br>&#125;<br><br>component MyCheckBox inherits Rectangle &#123;<br>    init =&gt; &#123; debug(&quot;second&quot;); &#125;<br>&#125;<br><br>export component MyWindow inherits Window &#123;<br>    MyButton &#123;<br>        text: &quot;Hello&quot;;<br>        init =&gt; &#123; debug(&quot;third&quot;); &#125;<br>    &#125;<br>    MyCheckBox &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不要使用回调函数用来初始化组件的属性，因为这违反了描述式语法的规则。避免以这样的方式使用回调，除非真的需要它，例如，为了通知某些本机代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Slint">global SystemService  &#123;<br>    // This callback can be implemented in native code using the Slint API<br>    callback ensure_service_running();<br>&#125;<br><br>export component MySystemButton inherits Rectangle &#123;<br>    init =&gt; &#123;<br>        SystemService.ensure_service_running();<br>    &#125;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 过时语法</title>
    <link href="/2024/01/27/Slint/slint-legacy-syntax/"/>
    <url>/2024/01/27/Slint/slint-legacy-syntax/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-过时语法"><a href="#Slint-过时语法" class="headerlink" title="Slint 过时语法"></a>Slint 过时语法</h1><p>为了维护对早期版本的兼容性，在1.0版本之前定义组件的语法<code>:=</code>目前也是支持的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export MyApp := Window &#123;<br>    //...<br>&#125;<br></code></pre></td></tr></table></figure><p>此语法更改还会影响属性查找规则和默认元素放置。</p><p>在新语法中定义的组件中，只有在组件内声明的属性才在范围内。默认情况下，父元素将其子元素呈现为居中，并将应用所有布局约束。</p><p>在使用旧语法定义的组件中，除了组件本身内部定义的所有属性之外， <code>self</code> 和 <code>root</code> 的基础的所有属性都在范围内。元素放置在位置 <code>x: 0</code> 和<code> y: 0</code> 处，并且不应用它们的约束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 模块</title>
    <link href="/2024/01/15/Slint/slint-modules/"/>
    <url>/2024/01/15/Slint/slint-modules/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-模块"><a href="#Slint-模块" class="headerlink" title="Slint 模块"></a>Slint 模块</h1><p>定义在<code>.slint</code>文件用的组件能够作为一个元素被其他<code>.slint</code>文件使用，也就是说可以被导出或者导入</p><p>在一般情况下，每一个被定义在<code>.slint</code>文件中的类型都是私有的，使用<code>export</code>属性可以改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component ButtonHelper inherits Rectangle &#123;<br>    // ...<br>&#125;<br><br>component Button inherits Rectangle &#123;<br>    // ...<br>    ButtonHelper &#123;<br>        // ...<br>    &#125;<br>&#125;<br><br>export &#123; Button &#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Button</code>能够被其他<code>.slint</code>文件访问，但是<code>ButtonHelper</code>不可以</p><p>也可以仅出于导出目的更改名称，而不影响其内部使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component Button inherits Rectangle &#123;<br>    // ...<br>&#125;<br><br>export &#123; Button as ColorButton &#125;<br></code></pre></td></tr></table></figure><p>在这里例子中，<code>Button</code>不再能够被其他<code>.slint</code>文件访问到了，取而代之的是<code>ColorButton</code>这个名字</p><p>为了方便起见，导出组件的第三种方法是立即声明它已导出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Button inherits Rectangle &#123;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，可以导入从其他文件导出的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; Button &#125; from &quot;./button.slint&quot;;<br><br>export component App inherits Rectangle &#123;<br>    // ...<br>    Button &#123;<br>        // ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果两个文件以相同的名称导出类型，则您可以选择在导入时分配不同的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Sint">import &#123; Button &#125; from &quot;./button.slint&quot;;<br>import &#123; Button as CoolButton &#125; from &quot;../other_theme/button.slint&quot;;<br><br>export component App inherits Rectangle &#123;<br>    // ...<br>    CoolButton &#123;&#125; // from other_theme/button.slint<br>    Button &#123;&#125; // from button.slint<br>&#125;<br></code></pre></td></tr></table></figure><p>元素，全局单例以及结构体都能够被导入和导出。<br>还可以导出从其他文件导入的全局变量（请参阅全局单例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; Logic as MathLogic &#125; from &quot;math.slint&quot;;<br>export &#123; MathLogic &#125; // known as &quot;MathLogic&quot; when using native APIs to access globals<br></code></pre></td></tr></table></figure><h1 id="模块语法"><a href="#模块语法" class="headerlink" title="模块语法"></a>模块语法</h1><p>导入类型支持以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; export1 &#125; from &quot;module.slint&quot;;<br>import &#123; export1, export2 &#125; from &quot;module.slint&quot;;<br>import &#123; export1 as alias1 &#125; from &quot;module.slint&quot;;<br>import &#123; export1, export2 as alias2, /* ... */ &#125; from &quot;module.slint&quot;;<br></code></pre></td></tr></table></figure><p>导出类型支持以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Slint">// Export declarations<br>export component MyButton inherits Rectangle &#123; /* ... */ &#125;<br><br>// Export lists<br>component MySwitch inherits Rectangle &#123; /* ... */ &#125;<br>export &#123; MySwitch &#125;;<br>export &#123; MySwitch as Alias1, MyButton as Alias2 &#125;;<br><br>// Re-export all types from other module<br>export * from &quot;other_module.slint&quot;;<br></code></pre></td></tr></table></figure><h1 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h1><p>将代码库拆分为单独的模块文件可以促进重用，并通过允许您隐藏帮助器组件来改进封装。这在项目自己的目录结构中效果很好。要在项目之间共享组件库而不对其相对路径进行硬编码，请使用组件库语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; MySwitch &#125; from &quot;@mylibrary&quot;;<br></code></pre></td></tr></table></figure><p>在上面的示例中，MySwitch 组件将从名为“mylibrary”的组件库中导入。该库的路径必须在编译时单独定义。使用以下方法之一帮助 Slint 编译器将“mylibrary”解析为磁盘上的正确路径：</p><ul><li>当使用Rust语言并存在<code>build.rs</code>文件，调用<a href="https://slint.dev/releases/1.3.2/docs/rust/slint_build/struct.CompilerConfiguration"><code>with_library_paths</code></a>来提供从库名称到路径的映射。</li><li>当在命令行中使用<code>slint-viewer</code>时，附加参数<code>-Lmylibrary=/path/to/my/library</code>为每一个组件库</li><li>在 VS 代码扩展中使用实时预览时，请使用<code>Slint: Library Paths</code>设置配置 Slint 扩展的库路径。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 全局单例</title>
    <link href="/2024/01/15/Slint/slint-global-singletions/"/>
    <url>/2024/01/15/Slint/slint-global-singletions/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-全局单例"><a href="#Slint-全局单例" class="headerlink" title="Slint 全局单例"></a>Slint 全局单例</h1><p>定义一个全局单例的实例需要使用到<code>global Name &#123; /*各种属性和回调函数*/&#125; </code>的方式，以使属性和回调在整个项目中可用。使用 Name.property 访问它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Slint">global Palette  &#123;<br>    in-out property&lt;color&gt; primary: blue;<br>    in-out property&lt;color&gt; secondary: green;<br>&#125;<br><br>export component Example inherits Rectangle &#123;<br>    background: Palette.primary;<br>    border-color: Palette.secondary;<br>    border-width: 2px;<br>&#125;<br></code></pre></td></tr></table></figure><p>导出全局以使其可从其他文件访问（请参阅模块<a href="https://slint.dev/releases/1.3.2/docs/slint/src/language/syntax/modules.html">Modules</a>）。从文件中导出全局变量，同时导出主应用程序组件，以使其对业务逻辑中的本机代码可见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export global Logic  &#123;<br>    in-out property &lt;int&gt; the-value;<br>    pure callback magic-operation(int) -&gt; int;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在Rust中的使用方式</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Rust">slint::slint!&#123;<br>export global Logic &#123;<br>    <span class="hljs-keyword">in</span>-out property &lt;int&gt; the-value;<br>    pure callback magic-<span class="hljs-title function_ invoke__">operation</span>(int) <span class="hljs-punctuation">-&gt;</span> int;<br>&#125;<br><br>export component App inherits Window &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = App::<span class="hljs-title function_ invoke__">new</span>();<br>    app.global::&lt;Logic&gt;().<span class="hljs-title function_ invoke__">on_magic_operation</span>(|value| &#123;<br>        <span class="hljs-built_in">eprintln!</span>(<span class="hljs-string">&quot;magic operation input: &#123;&#125;&quot;</span>, value);<br>        value * <span class="hljs-number">2</span><br>    &#125;);<br>    app.global::&lt;Logic&gt;().<span class="hljs-title function_ invoke__">set_the_value</span>(<span class="hljs-number">42</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在C++中的使用方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;app.h&quot;</span></span><br><br><span class="hljs-function">fn <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> app = App::<span class="hljs-built_in">create</span>();<br>    app-&gt;<span class="hljs-built_in">global</span>&lt;Logic&gt;().<span class="hljs-built_in">on_magic_operation</span>([](<span class="hljs-type">int</span> value) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;<br>    &#125;);<br>    app-&gt;<span class="hljs-built_in">global</span>&lt;Logic&gt;().<span class="hljs-built_in">set_the_value</span>(<span class="hljs-number">42</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用双向绑定语法从全局重新公开回调或属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Slint">global Logic  &#123;<br>    in-out property &lt;int&gt; the-value;<br>    pure callback magic-operation(int) -&gt; int;<br>&#125;<br><br>component SomeComponent inherits Text &#123;<br>    // use the global in any component<br>    text: &quot;The magic value is:&quot; + Logic.magic-operation(42);<br>&#125;<br><br>export component MainWindow inherits Window &#123;<br>    // re-expose the global properties such that the native code<br>    // can access or modify them<br>    in-out property the-value &lt;=&gt; Logic.the-value;<br>    pure callback magic-operation &lt;=&gt; Logic.magic-operation;<br><br>    SomeComponent &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint Stats语句</title>
    <link href="/2024/01/14/Slint/slint-states/"/>
    <url>/2024/01/14/Slint/slint-states/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-States"><a href="#Slint-States" class="headerlink" title="Slint States"></a>Slint States</h1><p>states 语句允许一次性声明状态并设置多个元素的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br>    default-font-size: 24px;<br><br>    label := Text &#123; &#125;<br>    ta := TouchArea &#123;<br>        clicked =&gt; &#123;<br>            active = !active;<br>        &#125;<br>    &#125;<br>    property &lt;bool&gt; active: true;<br>    states [<br>        active when active &amp;&amp; !ta.has-hover: &#123;<br>            label.text: &quot;Active&quot;;<br>            root.background: blue;<br>        &#125;<br>        active-hover when active &amp;&amp; ta.has-hover: &#123;<br>            label.text: &quot;Active\nHover&quot;;<br>            root.background: green;<br>        &#125;<br>        inactive when !active: &#123;<br>            label.text: &quot;Inactive&quot;;<br>            root.background: gray;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，活动和活动悬停状态是根据活动布尔属性的值和 TouchArea 的 has-hover 来定义的。当用户将鼠标悬停在示例上时，它将在蓝色和绿色背景之间切换，并相应地调整文本标签。单击可切换活动属性，从而进入非活动状态。</p><h1 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h1><p>转换将动画绑定到状态更改<br>此示例定义了两个转换。首先，out 关键字用于在离开禁用状态时为所有属性设置 800 毫秒的动画。第二个转换使用 in 关键字在转换到按下状态时对背景进行动画处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br><br>    text := Text &#123; text: &quot;hello&quot;; &#125;<br>    in-out property&lt;bool&gt; pressed;<br>    in-out property&lt;bool&gt; is-enabled;<br><br>    states [<br>        disabled when !root.is-enabled : &#123;<br>            background: gray; // same as root.background: gray;<br>            text.color: white;<br>            out &#123;<br>                animate * &#123; duration: 800ms; &#125;<br>            &#125;<br>        &#125;<br>        down when pressed : &#123;<br>            background: blue;<br>            in &#123;<br>                animate background &#123; duration: 300ms; &#125;<br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 动画效果</title>
    <link href="/2024/01/14/Slint/slint-animations/"/>
    <url>/2024/01/14/Slint/slint-animations/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-动画效果"><a href="#Slint-动画效果" class="headerlink" title="Slint 动画效果"></a>Slint 动画效果</h1><p>定义具有动画效果的属性需要使用<code>animate</code>关键字，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br><br>    background: area.pressed ? blue : red;<br>    animate background &#123;<br>        duration: 250ms;<br>    &#125;<br><br>    area := TouchArea &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果是当鼠标点击窗口，背景颜色会从红色变成蓝色名，变化的过程为250毫秒</p><p>使用以下参数微调动画：</p><ul><li><code>delay</code>：在动画开始前的等待时间。</li><li><code>duration</code>：动画完成所需要用到的时间。</li><li><code>iteration-count</code>：动画应运行的次数。负值指定无限重新运行。分形值是可能的。对于永久运行的动画，请参阅<a href="https://slint.dev/releases/1.3.2/docs/slint/src/language/builtins/functions.html#animation-tick-duration"><code>animation-tick()</code></a>。</li><li><code>easing</code>：可以是下方任意一个，从<a href="https://easings.net/"><code>easings.net</code></a>网站可以查看视觉效果。<ul><li><code>linear</code></li><li><code>ease-in-quad</code></li><li><code>ease-out-quad</code></li><li><code>ease-in-out-quad</code></li><li><code>ease</code></li><li><code>ease-in</code></li><li><code>ease-out</code></li><li><code>ease-in-out</code>    </li><li><code>ease-in-quart</code>    </li><li><code>ease-out-quart</code>    </li><li><code>ease-in-out-quart</code>    </li><li><code>ease-in-quint</code>    </li><li><code>ease-out-quint</code>    </li><li><code>ease-in-out-quint</code>    </li><li><code>ease-in-expo</code>    </li><li><code>ease-out-expo</code>    </li><li><code>ease-in-out-expo</code>    </li><li><code>ease-in-sine</code>    </li><li><code>ease-out-sine</code>    </li><li><code>ease-in-out-sine</code>    </li><li><code>ease-in-back</code>    </li><li><code>ease-out-back</code>    </li><li><code>ease-in-out-back</code>    </li><li><code>ease-in-circ</code>    </li><li><code>ease-out-circ</code>    </li><li><code>ease-in-out-circ</code>    </li><li><code>ease-in-elastic</code>    </li><li><code>ease-out-elastic</code>    </li><li><code>ease-in-out-elastic</code>    </li><li><code>ease-in-bounce</code>    </li><li><code>ease-out-bounce</code>    </li><li><code>ease-in-out-bounce</code>    </li><li><code>cubic-bezier(a, b, c, d)</code></li></ul></li></ul><p>还可以在图库示例的“缓动”选项卡上找到缓动示例。</p><hr><p>还可以使用相同的动画为多个属性设置动画，比如这样：<br><code>animate x, y &#123; duration: 100ms; easing: ease-out-bounce; &#125;</code></p><p>这样编写也可以达到一样的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Slint">animate x &#123; duration: 100ms; easing: ease-out-bounce; &#125;<br>animate y &#123; duration: 100ms; easing: ease-out-bounce; &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 条件元素</title>
    <link href="/2024/01/13/Slint/slint-conditional-element/"/>
    <url>/2024/01/13/Slint/slint-conditional-element/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-条件元素"><a href="#Slint-条件元素" class="headerlink" title="Slint 条件元素"></a>Slint 条件元素</h1><p>仅当给定条件为 true 时，if 构造才会实例化元素。语法为 if 条件 : id :&#x3D; Element { … }<br><em><strong>（这东西让我有一种看rust里 if let的感觉）</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 50px;<br>    preferred-height: 50px;<br>    if area.pressed : foo := Rectangle &#123; background: blue; &#125;<br>    if !area.pressed : Rectangle &#123; background: red; &#125;<br>    area := TouchArea &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>推荐if语句从右往左读，然后拆一下紧密布局的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 50px;<br>    preferred-height: 50px;<br><br><br>    if area.pressed : foo := Rectangle &#123; <br>    background: blue; <br>    &#125;<br>    <br>    if !area.pressed : Rectangle &#123; <br>    background: red; <br>    &#125;<br>    area := TouchArea &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果就是有一个红色的矩形，点击的时候就成了蓝色，markdown里展示效果不太理想，这里贴上原文链接<br><a href="https://slint.dev/releases/1.3.2/docs/slint/src/language/syntax/conditions">https://slint.dev/releases/1.3.2/docs/slint/src/language/syntax/conditions</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint  重复（repetition）</title>
    <link href="/2024/01/13/Slint/slint-repetition/"/>
    <url>/2024/01/13/Slint/slint-repetition/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-Repetition"><a href="#Slint-Repetition" class="headerlink" title="Slint Repetition"></a>Slint Repetition</h1><p>使用 <code>for in</code>语句可以多次创建同一元素<br>语法看起来长这个样子：&#96;for name[index] in model : id :&#x3D; Element { … }</p><p>model 能够是以下类型：</p><ul><li>一个整数，在这种情况下该元素将重复指定的次数</li><li>原生声明的数组类型或模型，在这种情况下，将为数组或模型中的每个元素实例化该元素。<br>该名称可用于在元素内查找，并且将类似于设置为模型值的伪属性。索引是可选的，将设置为模型中该元素的索引。 id 也是可选的。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 300px;<br>    preferred-height: 100px;<br>    for my-color[index] in [ #e11, #1a2, #23d ]: Rectangle &#123;<br>        height: 100px;<br>        width: 60px;<br>        x: self.width * index;<br>        background: my-color;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建了一个<code>color</code>类型的数组<code>[ #e11, #1a2, #23d ]</code>，对它进行遍历，<code>index</code>的内容就会从0到2, my-color的颜色就会从<code>#e11, #1a2, #23d</code>进行选择。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 50px;<br>    preferred-height: 50px;<br>    in property &lt;[&#123;foo: string, col: color&#125;]&gt; model: [<br>        &#123;foo: &quot;abc&quot;, col: #f00 &#125;,<br>        &#123;foo: &quot;def&quot;, col: #00f &#125;,<br>    ];<br>    VerticalLayout &#123;<br>        for data in root.model: my-repeated-text := Text &#123;<br>            color: data.col;<br>            text: data.foo;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 语句（statements）</title>
    <link href="/2024/01/13/Slint/slint-statements/"/>
    <url>/2024/01/13/Slint/slint-statements/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-Statements"><a href="#Slint-Statements" class="headerlink" title="Slint Statements"></a>Slint Statements</h1><p>在编程中，表达式是值、变量、操作符和函数调用的组合，其计算结果为单个值。例如，’ 2 + 3 ‘是一个求值为’ 5 ‘的表达式。表达式可以用作较大表达式的一部分，也可以用作函数的参数。</p><p>另一方面，语句是执行一个操作的完整代码行。语句可以包括表达式，但也可以包括关键字、循环、条件和其他编程结构。例如，’ if (x &gt; 0) {y &#x3D; 1;}是一个检查’ x ‘是否大于’ 0 ‘的语句，如果大于’ 0 ‘，则将’ y ‘设置为’ 1 ‘。</p><p>表达式和语句之间的主要区别在于表达式的计算结果是一个值，而语句执行一个操作。表达式可以用作语句的一部分，但语句不能用作表达式的一部分。</p><hr><p>回调函数能够包含复杂的语句：<br>赋值：<code>clicked =&gt; &#123; some-property = 42; &#125;</code></p><p>自赋值运算：<code>clicked =&gt; &#123; some-property += 42; &#125;</code></p><p>调用一个回调函数：<code>clicked =&gt; &#123; root.some-callback(); &#125;</code></p><p>条件语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Slint">clicked =&gt; &#123;<br>    if (condition) &#123;<br>        foo = 42;<br>    &#125; else if (other-condition) &#123;<br>        bar = 28;<br>    &#125; else &#123;<br>        foo = 4;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Slint">clicked =&gt; &#123;&#125;<br>clicked =&gt; &#123;;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 消息回调</title>
    <link href="/2024/01/12/Slint/slint-callbacks/"/>
    <url>/2024/01/12/Slint/slint-callbacks/</url>
    
    <content type="html"><![CDATA[<h1 id="消息回调"><a href="#消息回调" class="headerlink" title="消息回调"></a>消息回调</h1><p>组件能够定义回调以和外界交流改变的状态信息。回调是通过“调用”它们来调用的，就像调用函数一样。<br><em><strong>个人的理解，消息回调类似于Qt中常用的信号槽之槽函数。</strong></em><br>您可以通过使用 &#x3D;&gt; 箭头语法声明处理程序来对回调调用做出反应。内置的 TouchArea 元素声明一个 clicked 回调，当用户触摸该元素覆盖的矩形区域或用鼠标单击该区域时会调用该回调。在下面的示例中，通过声明处理程序并调用我们的自定义回调，将该回调的调用转发到另一个自定义回调（hello）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Rectangle &#123;<br>    // declare a callback<br>    callback hello;<br><br>    area := TouchArea &#123;<br>        // sets a handler with `=&gt;`<br>        clicked =&gt; &#123;<br>            // emit the callback<br>            root.hello()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以向回调添加参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Rectangle &#123;<br>    // declares a callback<br>    callback hello(int, string);<br>    hello(aa, bb) =&gt; &#123; /* ... */ &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回调也可能返回一个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Rectangle &#123;<br>    // declares a callback with a return value<br>    callback hello(int, int) -&gt; int;<br>    hello(aa, bb) =&gt; &#123; aa + bb &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>可以用与双向绑定类似的方式声明回调别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Rectangle &#123;<br>    callback clicked &lt;=&gt; area.clicked;<br>    area := TouchArea &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 函数</title>
    <link href="/2024/01/12/Slint/slint-functions/"/>
    <url>/2024/01/12/Slint/slint-functions/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-函数"><a href="#Slint-函数" class="headerlink" title="Slint 函数"></a>Slint 函数</h1><p>在slint中定义一个函数需要使用到<code>function</code>关键字</p><p>函数可以在括号中添加参数，参数需要遵循<code>函数名:类型</code>的格式。这些参数可以通过函数体内的名称来引用。</p><p>函数也可以返回一个值，返回的类型需要使用<code>-&gt;</code>符号在函数中标明。<br><code>function 函数名称(参数1: 类型) -&gt; 返回类型</code><br><code>return </code>关键字在函数体内使用以返回声明类型的表达式。如果函数没有显式返回值，则默认返回最后一条语句的值。（这一点和Rust的函数语法很像）</p><p>函数可以用 <code>pure</code> 关键字注释。这表明该功能不会引起任何副作用。更多详细信息可以在“纯度”章节中找到。</p><p>默认情况下，函数是私有的，无法从外部组件访问。但是，可以使用 <code>public</code> 或 <code>protected</code> 关键字修改它们的可访问性。</p><ul><li>用 <code>public</code> 注解的函数可以被任何组件访问。</li><li>用 <code>protected</code> 注解的函数只能被直接继承它的组件访问。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    in-out property &lt;int&gt; min;<br>    in-out property &lt;int&gt; max;<br>    protected function set-bounds(min: int, max: int) &#123;<br>        root.min = min;<br>        root.max = max<br>    &#125;<br>    public pure function inbound(x: int) -&gt; int &#123;<br>        return Math.min(root.max, Math.max(root.min, x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，set-bounds 是一个受保护的函数，用于更新根组件的 min 和 max 属性。入站函数是一个公共纯函数，它接受整数 x 并返回限制在最小和最大边界内的值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 表达式</title>
    <link href="/2024/01/11/Slint/slint-expressions/"/>
    <url>/2024/01/11/Slint/slint-expressions/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-表达式"><a href="#Slint-表达式" class="headerlink" title="Slint 表达式"></a>Slint 表达式</h1><p>表达式是在用户界面中声明关系和连接的强大方式。它们通常用于将基本算术与访问其他元素的属性结合起来。当这些属性发生变化时，表达式会自动重新求值，并为与该表达式关联的属性赋一个新值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    // declare a property of type int<br>    in-out property&lt;int&gt; my-property;<br><br>    // This accesses the property<br>    width: root.my-property * 20px;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>my-property</code>改变时，宽度也会自动改变</p><p>数字表达式中的算术运算与大多数编程语言中的操作符*、+、-、&#x2F;类似:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    in-out property &lt;int&gt; p: 1 * 2 + 3 * 4; // same as (1 * 2) + (3 * 4)<br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>+</code>串联字符串。<br>运算符&amp;&amp;和||表示布尔值之间的逻辑与或。操作符<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>和<code>&lt;=</code>比较相同类型的值。</p><p>访问元素的属性，方法是使用元素的名称，后跟一个“<code>.</code>属性名”:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    foo := Rectangle &#123;<br>        x: 42px;<br>    &#125;<br>    x: foo.x;<br>&#125;<br></code></pre></td></tr></table></figure><p>三目运算符<code>expression : expression ? expression</code> 在slint中也是被支持的，就像C语言和JavaScript中一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br><br>    Rectangle &#123;<br>        touch := TouchArea &#123;&#125;<br>        background: touch.pressed ? #111 : #eee;<br>        border-width: 5px;<br>        border-color: !touch.enabled ? #888<br>            : touch.pressed ? #aaa<br>            : #555;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 属性</title>
    <link href="/2024/01/11/Slint/slint-properties/"/>
    <url>/2024/01/11/Slint/slint-properties/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-属性"><a href="#Slint-属性" class="headerlink" title="Slint 属性"></a>Slint 属性</h1><p>所有元素均有属性。内置元素具有常见特性，如颜色或尺寸特性。你可以为它们设定一个值或者一个完整的表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    // 简单表达式：以分号结尾<br>    width: 42px;<br>    // 或者用一个代码块包裹，这样就没有分号了<br>    height: &#123; 42px &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>（一股浓郁的Rust语法味道扑面而来）</strong></em></p><p>属性的默认值一般是属性的类型的默认值，比如说布尔的默认是<code>false</code>，整数<code>int</code>的默认值是<code>0</code>。</p><p>除了现有属性外，还可以通过指定名称、类型和默认值（可选）来定义额外的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    // 定义了一个叫做my-property的int类型的扩展属性<br>    property&lt;int&gt; my-property;<br><br>    // 定义了一个叫做my-second-property的int类型的属性，并设置其默认值为42<br>    property&lt;int&gt; my-second-property: 42;<br>&#125;<br></code></pre></td></tr></table></figure><p>用限定符注释额外的属性，指定如何读取和写入属性：</p><ul><li><code>private</code> ：默认为此，属性仅能在当前组件内被访问</li><li><code>in</code>：这个属性能被输入，它可以由该组件的用户设置和修改，例如通过绑定或回调中的赋值。组件可以提供默认绑定，但不能通过赋值覆盖它</li><li><code>out</code>：只能由组件设置的输出属性。对于组件的用户来说，它是只读的。</li><li><code>in-out</code>：任何人都可以对此属性进行读写<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Button &#123;<br>    // 这意味着通过用户设置组件<br>    in property &lt;string&gt; text;<br>    // 表明了该属性将由组件的用户读取。<br>    out property &lt;bool&gt; pressed;<br>    // 此属性意味着用户和组件本身都可以更改。<br>    in-out property &lt;bool&gt; checked;<br><br>    // 此属性是该组件的内部属性。<br>    private property &lt;bool&gt; has-mouse;<br>&#125;<br></code></pre></td></tr></table></figure>当使用组件作为元素时，或者通过业务逻辑的语言绑定，可以从外部访问在组件顶层声明的所有非私有属性。</li></ul><h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p>当表达式中访问的属性发生更改时，会自动重新评估绑定表达式。</p><p>在以下示例中，当用户按下按钮时，按钮的文本会自动更改。增加计数器属性会自动使绑定到文本的表达式无效并触发重新计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; Button &#125; from &quot;std-widgets.slint&quot;;<br>export component Example inherits Window &#123;<br>    preferred-width: 50px;<br>    preferred-height: 50px;<br>    Button &#123;<br>        property &lt;int&gt; counter: 3;<br>        clicked =&gt; &#123; self.counter += 3 &#125;<br>        text: self.counter * 2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在查询属性时惰性地进行重新计算。</p><p>在内部，在计算绑定时访问的任何属性都要注册依赖项。当属性更改时，会通知依赖项，并将所有依赖绑定标记为脏绑定。***(脏绑定是由于其所依赖的某个属性发生更改而被标记为无效的绑定。当查询属性时，脏绑定将被重新计算)***</p><p>默认情况下，本机代码中的回调不依赖于任何属性，除非它们查询本机代码中的属性。</p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>使用&lt;&#x3D;&gt;语法在属性之间创建双向绑定。这些属性将被链接在一起，并且总是包含相同的值。</p><p>&lt;&#x3D;&gt;的右侧必须是对同一类型属性的引用。对于双向绑定，属性类型是可选的，如果没有指定，它将被推断出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example  &#123;<br>    in property&lt;brush&gt; rect-color &lt;=&gt; r.background;<br>    // It&#x27;s allowed to omit the type to have it automatically inferred<br>    in property rect-color2 &lt;=&gt; r.background;<br>    r:= Rectangle &#123;<br>        width: parent.width;<br>        height: parent.height;<br>        background: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相对长度"><a href="#相对长度" class="headerlink" title="相对长度"></a>相对长度</h2><p>有时用相对百分比来表示长度属性之间的关系是很方便的。例如，下面的内部蓝色矩形的大小是外部绿色窗口的一半</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br><br>    background: green;<br>    Rectangle &#123;<br>        background: blue;<br>        width: parent.width * 50%;<br>        height: parent.height * 50%;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种以百分比表示父元素同名属性的宽度或高度的模式很常见。为了方便起见，这里有一种简写的语法:</p><ul><li>属性是<code>width</code>或者<code>height</code></li><li>绑定的表达式求值是百分比</li></ul><p>如果满足这些条件，那么就没有必要指定parent属性，而是可以简单地使用百分比。前面的例子如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br><br>    background: green;<br>    Rectangle &#123;<br>        background: blue;<br>        width: 50%;<br>        height: 50%;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; LineEdit, Button &#125; from &quot;std-widgets.slint&quot;;  <br>  <br>component InputWithLabel inherits HorizontalLayout&#123;  <br>    in property &lt;string&gt; label_str;  <br>    in-out property &lt;string&gt; intput_src &lt;=&gt;  input.text;  <br>    spacing: 2px;  <br>    Rectangle &#123;  <br>        border-color: grey;  <br>        border-width: 2px;  <br>        border-radius: 5px;  <br>        Text&#123;  <br>            text: label-str;  <br>            font-size: 14px;  <br>        &#125;  <br>    &#125;  <br>    Rectangle &#123;  <br>        border-color: grey;  <br>        border-width: 2px;  <br>        border-radius: 5px;  <br>        input := LineEdit &#123;  <br>            font-size: 14px;  <br>            input-type: number;  <br>        &#125;  <br>  <br>    &#125;  <br>&#125;  <br>  <br>export component MainWindow inherits Window &#123;  <br>    preferred-height: 480px;  <br>    preferred-width: 640px;  <br>          <br>    VerticalLayout &#123;  <br>        spacing: 2px;  <br>        alignment: start;  <br>        input1 := InputWithLabel &#123;  <br>            label-str: &quot;number 1&quot;;  <br>        &#125;  <br>        input2 := InputWithLabel &#123;  <br>            label-str: &quot;number 2&quot;;  <br>        &#125;  <br>  <br>        VerticalLayout &#123;  <br>            Button &#123;  <br>                text: &quot;sum&quot;;  <br>                clicked =&gt; &#123;  <br>                    result.text = add(input1.intput_src.to-float(), input2.intput_src.to-float());  <br>                &#125;  <br>            &#125;  <br>            result := TextInput&#123;  <br>                enabled: false;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>  <br>    pure function add(a: int, b: int) -&gt; int &#123;  <br>        return a + b;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint DSL 类型</title>
    <link href="/2024/01/10/Slint/slint-syntax/"/>
    <url>/2024/01/10/Slint/slint-syntax/</url>
    
    <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>Slint支持C类风格的注释：</p><ol><li>使用两个斜杠(<code>//</code>) 的方式注释此行中在&#x2F;&#x2F;之后的所有内容</li><li>块注释(<code>/* ... */ </code>) ， 注释处于<code>/*</code> 到 <code>*/</code>之间的所有内容<br>例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component MyRectangle inherits Rectangle&#123;  // 这是一个注释<br>  /*<br>这是一个注释<br>这也是一个注释<br>  */<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>标识符可以由字母 <code>(a-zA-Z)</code>、数字<code> (0-9)</code>、下划线<code>(_)</code>或破折号 <code>(-)</code> 组成。它们<strong>不能以数字或破折号开头</strong>（但可以以下划线开头）下划线被标准化为破折号。这意味着这两个标识符是相同的：foo_bar 和 foo-bar。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Slint">hello_world  // ok<br>hello-world  // ok<br>helloWorld   // ok<br>HelloWorld   // ok<br>_hello_world // ok<br>123Apple     // error<br>-apple       // error<br></code></pre></td></tr></table></figure><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>在Slint中所有属性都是具有类型的，下表展示了Slint中的基本类型：</p><table><thead><tr><th>类型</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>angle</code></td><td>角度单位，对应于文字如 90deg、1.2rad、0.25turn</td><td>0deg</td></tr><tr><td><code>bool</code></td><td>布尔值，<code>true</code>和<code>false</code></td><td>false</td></tr><tr><td><code>brush</code></td><td>画笔是一种特殊类型，可以从颜色或渐变规范初始化。有关详细信息，请参阅颜色和画笔部分。 <a href="https://slint.dev/releases/1.3.2/docs/slint/src/language/syntax/types#colors-and-brushes">Colors and Brushes Section</a></td><td>transparent</td></tr><tr><td><code>color</code></td><td>具有 Alpha 通道的 RGB 颜色，每个通道具有 8 位精度。支持 CSS 颜色名称以及十六进制颜色编码，例如 <code>#RRGGBBAA</code> 或<code> #RGB</code>。</td><td>transparent</td></tr><tr><td><code>duration</code></td><td>输入动画的持续时间。 ms（毫秒）或 s（秒）等后缀用于指示精度。</td><td>0ms</td></tr><tr><td><code>easing</code></td><td>属性动画允许指定缓动曲线。有效值是线性的（值是线性插值的），CSS 中已知四个常见的立方贝塞尔函数：<code>ease</code>、<code>ease_in</code>、<code>ease_in_out</code>、<code>ease_out</code>。<br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#Keywords_for_common_cubic-bezier_easing_functions">four common cubiz-bezier functions known from CSS</a></td><td>linear</td></tr><tr><td><code>float</code></td><td>有符号的 32 位浮点数。带有 % 后缀的数字会自动除以 100，因此例如 30% 等于 0.30。</td><td>0</td></tr><tr><td><code>image</code></td><td>对图像的引用可以使用 @image-url(“…”) 构造进行初始化</td><td>empty image</td></tr><tr><td><code>int</code></td><td>带符号的整数。</td><td>0</td></tr><tr><td><code>length</code></td><td>用于 x、y、宽度和高度坐标的类型。对应于 1px、1pt、1in、1mm 或 1cm 等文字。如果绑定在可以访问设备像素比的上下文中运行，则可以将其与长度进行转换。</td><td>0px</td></tr><tr><td><code>percent</code></td><td>有符号的 32 位浮点数，可以理解为百分比。分配给该类型属性的文字数字必须带有 % 后缀。</td><td>0%</td></tr><tr><td><code>physical-length</code></td><td>这是物理像素的数量。要将整数转换为长度单位，只需乘以 1px 即可。或者要将长度转换为浮点数，可以除以 1phx。</td><td>0phx</td></tr><tr><td><code>relative-font-size</code></td><td>相对字体大小系数，与 <code>Window.default-font-size</code> 相乘，可以转换为长度。</td><td>0rem</td></tr><tr><td><code>string</code></td><td>UTF-8 编码、引用计数字符串。</td><td><code>&quot;&quot;</code></td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>任何一个使用utf8编码字符组成的系列都可以称为一个字符串(<code>string</code>) 比如：”foo”<br>转义序列可以嵌入到字符串中以插入难以直接插入的字符（就是很难直接打出来的字符）：</p><table><thead><tr><th align="left">转移字符</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left"><code>\&quot;</code></td><td align="left"><code>&quot;</code></td></tr><tr><td align="left"><code>\\</code></td><td align="left"><code>\</code></td></tr><tr><td align="left"><code>\n</code></td><td align="left">换到新一行</td></tr><tr><td align="left"><code>\u&#123;x&#125;</code></td><td align="left">其中 x 是一个十六进制数字，扩展为该数字表示的 unicode 代码点</td></tr><tr><td align="left"><code>\&#123;expression&#125;</code></td><td align="left">表达式的求值结果</td></tr><tr><td align="left"><strong>非转义字符 \ 后面的任何其他内容都是错误。</strong></td><td align="left"></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Text &#123;<br>    text: &quot;hello&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong> 这种<code>\&#123;...&#125;</code>的语法在Rust语言中的<code>slint!</code>宏中使用是无效的</p><h2 id="颜色和笔刷（画笔）"><a href="#颜色和笔刷（画笔）" class="headerlink" title="颜色和笔刷（画笔）"></a>颜色和笔刷（画笔）</h2><p>颜色文字遵循 CSS 语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    background: blue;<br>    property&lt;color&gt; c1: #ffaaff;<br>    property&lt;brush&gt; b2: Colors.red;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了纯色之外，许多元素都有类型为brush而不是color的属性。画笔是一种可以是颜色也可以是渐变的类型。然后使用画笔填充元素或绘制轮廓。</p><p>CSS颜色名称仅在类型Color或brush表达式的作用域内。否则，您可以从colors名称空间访问颜色。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>所以的<code>colors</code>和<code>brushed</code>遵从以下方法的定义：</p><p><strong><code>brighter(factor: float) -&gt; brush</code></strong><br>返回从该颜色派生的新颜色，但其亮度增加指定的因子。例如，如果因子为0.5(或例如50%)，则返回的颜色要亮50%。负面因素会降低亮度。</p><p><strong><code>darker(factor: float) -&gt; brush</code></strong><br>返回从该颜色派生的新颜色，但其亮度降低指定的因子。例如，如果因子为0.5(或例如50%)，则返回的颜色暗50%。负面因素增加了亮度。</p><p><strong><code>mix(other: brush, factor: float) -&gt; brush</code></strong><br>返回一种新颜色，它是这种颜色和其他颜色的混合，混合的比例由参数<code>factor</code>决定(将被限制在0.0和1.0之间)。</p><p><strong><code>transparentize(factor: float) -&gt; brush</code></strong><br>返回不透明度降低的新颜色。通过将alpha通道乘以(1 -<code>factor</code>)获得透明度。</p><p><strong><code>with_alpha(alpha: float) -&gt; brush</code></strong><br>返回一个新的颜色，alpha值设置为alpha(介于0和1之间)</p><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>线性梯度描述光滑、彩色的表面。它们是用一个角度和一系列颜色点来指定的。颜色将在止光点之间线性内插，与以指定角度旋转的假想线对齐。这被称为线性梯度，并使用带有以下签名的<code>@linear-gradient</code>宏指定:<br><strong><code>@linear-gradient(angle, color percentage, color percentage, ...)</code></strong></p><p>宏的第一个参数是一个角度(参见类型)。梯度线的起始点将以指定的值旋转。</p><p>在初始角度之后是一个或多个颜色停止，描述为一个颜色值和百分比的空格分隔对。颜色指定线性颜色插值在沿梯度轴的指定百分比处应达到的值。</p><p>下面的例子显示了一个矩形，填充了一个线性渐变，以浅蓝色开始，在中心插入一个非常浅的阴影，并以橙色色调结束:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br><br>    Rectangle &#123;<br>        background: @linear-gradient(90deg, #3f87a6 0%, #ebf8e1 50%, #f69d3c 100%);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><p>线性渐变就像真正的渐变，但颜色是在一个圆内插入而不是沿着一条线。要描述一个径向渐变，使用以下签名<code>@radial-gradient</code>宏：<br><strong><code>@radial-gradient(circle, color percentage, color percentage， ...) </code></strong><br>该宏的第一个参数总是circle，因为只支持圆形渐变。<br>语法是基于CSS <code>radial-gradient</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 100px;<br>    preferred-height: 100px;<br>    Rectangle &#123;<br>        background: @radial-gradient(circle, #f00 0%, #0f0 50%, #00f 100%);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图像类型是对图像的引用。它是使用 <code>@image-url(&quot;...&quot;)</code> 构造定义的。<code> @image-url</code> 函数中的地址必须在编译时已知。<br>Slint 在以下位置查找图像：</p><ul><li>绝对路径或相对于当前 .slint 文件的路径。</li><li>编译器用来查找 .slint 文件的包含路径。</li></ul><p>使用图像的宽度和高度属性访问图像的尺寸。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Window &#123;<br>    preferred-width: 150px;<br>    preferred-height: 50px;<br><br>    in property &lt;image&gt; some_image: @image-url(&quot;https://slint.dev/logo/slint-logo-full-light.svg&quot;);<br><br>    Text &#123;<br>        text: &quot;The image is &quot; + some_image.width + &quot;x&quot; + some_image.height;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>使用关键字<code>struct</code>来定义结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export struct Player  &#123;<br>    name: string,<br>    score: int,<br>&#125;<br><br>export component Example &#123;<br>    in-out property&lt;Player&gt; player: &#123; name: &quot;Foo&quot;, score: 100 &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体的默认值是通过将其所有字段设置为其默认值来初始化的。</p><h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>使用 <code>&#123;identifier1: type2,identifier1:type2 &#125; </code>语法声明匿名结构，并使用 <code>&#123;identifier1: expression1,identifier2: expression2 &#125; </code>对其进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    in-out property&lt;&#123;name: string, score: int&#125;&gt; player: &#123; name: &quot;Foo&quot;, score: 100 &#125;;<br>    in-out property&lt;&#123;a: int, &#125;&gt; foo: &#123; a: 3 &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>使用关键字<code>enum</code>定义枚举类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export enum CardSuit &#123; clubs, diamonds, hearts, spade &#125;<br><br>export component Example &#123;<br>    in-out property&lt;CardSuit&gt; card: spade;<br>    out property&lt;bool&gt; is-clubs: card == CardSuit.clubs;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举值可以通过使用枚举的名称和值的名称，中间用点分开来引用。 (例如：CardSuit.spade)<br> 在该枚举类型的绑定中，或者如果回调函数的返回值是该枚举，则可以省略枚举的名称。<br> 每个枚举类型的默认值总是第一个值。</p><h2 id="数组和模型"><a href="#数组和模型" class="headerlink" title="数组和模型"></a>数组和模型</h2><p>数组是通过将数组元素的类型括在<code> [</code> 和 <code>]</code> 方括号中来声明的。  </p><p>数组文字以及保存数组的属性充当 for 表达式中的模型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    in-out property&lt;[int]&gt; list-of-int: [1,2,3];<br>    in-out property&lt;[&#123;a: int, b: string&#125;]&gt; list-of-structs: [&#123; a: 1, b: &quot;hello&quot; &#125;, &#123;a: 2, b: &quot;world&quot;&#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>数组定义了以下操作：<br><code>array.length</code>：可以使用内置的 .length 属性查询数组和模型的长度。<br><code>array[index]</code>：索引运算符检索数组的各个元素。<br>对数组的越界访问将返回默认构造的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    in-out property&lt;[int]&gt; list-of-int: [1,2,3];<br><br>    out property &lt;int&gt; list-len: list-of-int.length;<br>    out property &lt;int&gt; first-int: list-of-int[0];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Slint支持不同类型之间的转换。为了使UI描述更健壮，需要显式转换，但是为了方便，在某些类型之间允许隐式转换。</p><p>可以进行以下转换:</p><ul><li>Int可以隐式地转换为float，反之亦然</li><li>Int和float可以隐式转换为string</li><li>物理长度和长度只能在像素比已知的情况下隐式地相互转换。</li><li>单位类型(长度、物理长度、持续时间等)不能转换为数字(float或int)，但它们可以自己除以得到一个数字。同样，一个数字可以乘以这些单位中的一个。这个想法是，一个人将乘以1px或除以1px来进行这样的转换</li><li>字面值0可以转换为具有相关单位的任何这些类型。</li><li>如果结构类型具有相同的属性名，并且它们的类型可以转换，那么它们将与另一个结构类型转换。源结构可以有缺失的属性，也可以有额外的属性。但不是两者都有。</li><li>数组通常不会相互转换。如果元素类型是可转换的，则可以转换数组字面值。</li><li>使用to-float函数可以将String转换为float。如果字符串不是一个有效的数字，该函数返回0。您可以使用is-float()检查字符串是否包含有效数字</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    // OK: int converts to string<br>    property&lt;&#123;a: string, b: int&#125;&gt; prop1: &#123;a: 12, b: 12 &#125;;<br>    // OK: even if a is missing, it will just have the default value (&quot;&quot;)<br>    property&lt;&#123;a: string, b: int&#125;&gt; prop2: &#123; b: 12 &#125;;<br>    // OK: even if c is too many, it will be discarded<br>    property&lt;&#123;a: string, b: int&#125;&gt; prop3: &#123; a: &quot;x&quot;, b: 12, c: 42 &#125;;<br>    // ERROR: b is missing and c is extra, this doesn&#x27;t compile, because it could be a typo.<br>    // property&lt;&#123;a: string, b: int&#125;&gt; prop4: &#123; a: &quot;x&quot;, c: 42 &#125;;<br><br>    property&lt;string&gt; xxx: &quot;42.1&quot;;<br>    property&lt;float&gt; xxx1: xxx.to-float(); // 42.1<br>    property&lt;bool&gt; xxx2: xxx.is-float(); // true<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 语言翻译</title>
    <link href="/2024/01/09/Slint/slint-translations/"/>
    <url>/2024/01/09/Slint/slint-translations/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-语言翻译"><a href="#Slint-语言翻译" class="headerlink" title="Slint 语言翻译"></a>Slint 语言翻译</h1><p>使用Slint自带基本翻译功能可以让你的程序实现切换不同的语言</p><p>完成下面几个步骤便可以完成程序的翻译工作：</p><ol><li>表明所有对用户可见且需要翻译的字符串并使用<code>@tr()</code>宏进行注释</li><li>使用 <code>slint-tr-extractor</code> 工具提取带注释的字符串并生成 .pot 文件。  </li><li>使用第三方工具将字符串翻译为目标语言，如 .po 文件。  </li><li>使用 gettext 的 msgfmt 工具将 .po 文件转换为运行时可加载的 .mo 文件。  </li><li>根据用户的区域设置，使用 Slint 的 API 在运行时选择并加载 .mo 文件。此时，所有标记为翻译的字符串将自动以目标语言呈现。</li></ol><h1 id="注释可翻译字符串"><a href="#注释可翻译字符串" class="headerlink" title="注释可翻译字符串"></a>注释可翻译字符串</h1><p>在 .slint 文件中使用 @tr 宏来标记要翻译的字符串。该宏将通过替换 {} 占位符来处理翻译和格式设置。<br>第一个参数必须是纯字符串文字，后跟参数(这个写法好像printf)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    property &lt;string&gt; name;<br>    Text &#123;<br>        text: @tr(&quot;Hello, &#123;&#125;&quot;, name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p><code>@tr </code>宏将标记为翻译的字符串中的每个<code>&#123;&#125;</code>占位符替换为相应的参数。还可以使用 <code>&#123;0&#125;、&#123;1&#125; </code>等对参数重新排序。即使原始字符串没有，翻译人员也可以使用有序占位符。</p><h2 id="复数格式"><a href="#复数格式" class="headerlink" title="复数格式"></a>复数格式</h2><p>当涉及可变数量元素的文本翻译应根据是单个元素还是多个元素而变化时，请使用复数格式。<br>在计算某些东西的个数时，使用<code>count</code>和表达式来表示，用 <code>| </code>形成复数形式和 <code>% </code>符号如下：<br><code>@tr(&quot;I have &#123;n&#125; item&quot; | &quot;I have &#123;n&#125; items&quot; % count)</code>.<br>（也就是说slint会根据数字的单数还是复数来选择使用什么格式的翻译，比如这里就会存在 “I have a&#x2F;one item” 和 “I have two&#x2F;three items”的情况）</p><p>在格式字符串中使用 {n} 来访问 % 之后的表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example inherits Text &#123;<br>    in property &lt;int&gt; score;<br>    in property &lt;int&gt; name;<br>    text: @tr(&quot;Hello &#123;0&#125;, you have one point&quot; | &quot;Hello &#123;0&#125;, you have &#123;n&#125; point&quot; % score, name);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语境"><a href="#语境" class="headerlink" title="语境"></a>语境</h2><p>通过使用 “…” &#x3D;&gt; 语法向 @tr(…) 宏添加语境，消除具有相同源文本但上下文语境含义不同的字符串的翻译歧义。<br>使用上下文为译者提供额外的上下文信息，确保翻译准确且符合当前语境。<br>上下文必须是纯字符串文字，并且在 .pot 文件中显示为 msgctx。如果未指定，上下文默认为周围组件的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component MenuItem &#123;<br>    property &lt;string&gt; name : @tr(&quot;Name&quot; =&gt; &quot;Default Name&quot;); // Default: `MenuItem` will be the context.<br>    property &lt;string&gt; tooltip : @tr(&quot;ToolTip&quot; =&gt; &quot;ToolTip for &#123;&#125;&quot;, name); // Specified: The context will be `ToolTip`.<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="提取可翻译字符串"><a href="#提取可翻译字符串" class="headerlink" title="提取可翻译字符串"></a>提取可翻译字符串</h2><p>使用<code>slint-tr-extractor</code> 工具从<code>.slint</code>文件生成出<code>.pot</code>文件，可以这样运行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find -name \*.slint | xargs slint-tr-extractor -o MY_PROJECT.pot<br></code></pre></td></tr></table></figure><p>这将创建一个名为 MY_PROJECT.pot 的文件。将 MY_PROJECT 替换为您的实际项目名称。要了解项目名称如何影响翻译查找，请参阅以下部分。<br><code>.pot</code> files are <a href="https://www.gnu.org/software/gettext/">Gettext</a> template files.</p><h1 id="翻译字符串"><a href="#翻译字符串" class="headerlink" title="翻译字符串"></a>翻译字符串</h1><p>通过从 .pot 文件创建 .po 文件来开始新翻译。两种文件格式相同。您可以手动复制文件，也可以使用 Gettext 的 msginit 等工具来启动新的 .po 文件。<br>.po 文件将包含目标语言的字符串。<br>.po 和 .pot 文件是纯文本文件，您可以使用文本编辑器进行编辑。我们建议使用专用翻译工具来处理它们，例如：</p><ul><li><a href="https://poedit.net/">poedit</a></li><li><a href="https://omegat.org/">OmegaT</a></li><li><a href="https://userbase.kde.org/Lokalize">Lokalize</a></li><li><a href="https://www.transifex.com/">Transifex</a> (web interface)</li></ul><h2 id="转换-po文件到-mo文件"><a href="#转换-po文件到-mo文件" class="headerlink" title="转换.po文件到.mo文件"></a>转换<code>.po</code>文件到<code>.mo</code>文件</h2><p>人类可读的 .po 文件需要转换为机器友好的 .mo 文件，这是一种读取效率非常高的二进制表示形式。<br>使用 <a href="https://www.gnu.org/software/gettext/">Gettext</a>的<code>msgfmt</code> 命令行工具以将<code>.po</code>文件转换到<code>.mo</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">msgfmt translation.po -o translation.mo<br></code></pre></td></tr></table></figure><h2 id="在运行时选择并加载-mo文件"><a href="#在运行时选择并加载-mo文件" class="headerlink" title="在运行时选择并加载.mo文件"></a>在运行时选择并加载<code>.mo</code>文件</h2><p>Slint 使用 Gettext 库在运行时加载翻译。 Gettext 将翻译文件生成在以下指定位置下：<br><code>dir_name/locale/LC_MESSAGES/domain_name.mo</code></p><ul><li>dir_name: 你自由原则的根目录文件夹</li><li>locale: 给定目标语言的用户区域设置名称，例如 fr 代表法语，de 代表德语。区域设置通常是使用操作系统设置的环境变量来确定的。</li><li>domain_name: 根据您使用 Slint 的编程语言进行选择。</li></ul><h1 id="在Rust中选择并加载翻译文件"><a href="#在Rust中选择并加载翻译文件" class="headerlink" title="在Rust中选择并加载翻译文件"></a>在Rust中选择并加载翻译文件</h1><p>首先，启用 <code>slint create</code> 的 <code>gettext </code>功能来访问翻译 API 并激活运行时翻译支持。<br>接下来，使用 <code>slint::init_translations！</code>指定 <code>.mo</code> 文件的基本位置。这是上一节方案中的 dir_name。 .mo 文件应位于相应的子目录中，并且它们的文件名 - 域名 - 必须与 Cargo.toml 中的包名称匹配。这通常与crate名称相同。<br>举个🌰:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust">slint::init_translations!(<span class="hljs-built_in">concat!</span>(<span class="hljs-built_in">env!</span>(<span class="hljs-string">&quot;CARGO_MANIFEST_DIR&quot;</span>), <span class="hljs-string">&quot;/lang/&quot;</span>));<br></code></pre></td></tr></table></figure><p>假设您的 Cargo.toml 包含以下行，并且用户的区域设置为 fr：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;gallery&quot;</span><br></code></pre></td></tr></table></figure><p>通过这些设置，Slint 将在 lang&#x2F;fr&#x2F;LC_MESSAGES&#x2F;gallery.mo 中查找 gallery.mo。</p><h1 id="在C-中选择并加载翻译文件"><a href="#在C-中选择并加载翻译文件" class="headerlink" title="在C++中选择并加载翻译文件"></a>在C++中选择并加载翻译文件</h1><p>首先，在编译 Slint 时启用 <code>SLINT_FEATURE_GETTEXT</code> cmake 选项，以访问翻译 API 并激活运行时翻译支持。<br>在C++应用中使用CMake，用<code>domain_name</code>作为cmake目标名称</p><p>接下来，使用标准 gettext 库将文本域绑定到路径。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">find_package</span>(Intl)<br><span class="hljs-keyword">if</span>(Intl_FOUND)<br>    <span class="hljs-keyword">target_compile_definitions</span>(gallery PRIVATE HAVE_GETTEXT SRC_DIR=<span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)<br>    <span class="hljs-keyword">target_link_libraries</span>(gallery PRIVATE Intl::Intl)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>(可以通过vcpkg安装第三方库，非常的方便)</p><p>然后可以设置区域设置和文本域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_GETTEXT</span><br><span class="hljs-meta">#    <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span></span><br><span class="hljs-meta">#    <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libintl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> HAVE_GETTEXT</span><br>    <span class="hljs-built_in">bindtextdomain</span>(<span class="hljs-string">&quot;my_application&quot;</span>, SRC_DIR <span class="hljs-string">&quot;/lang/&quot;</span>);<br>    std::locale::<span class="hljs-built_in">global</span>(std::<span class="hljs-built_in">locale</span>(<span class="hljs-string">&quot;&quot;</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假设您正在使用上述内容，并且用户的区域设置设置为 fr，Slint 将在 lang&#x2F;fr&#x2F;LC_MESSAGES&#x2F;gallery.mo 中查找 gallery.mo。</p><h1 id="使用-slint-viewer-预览翻译"><a href="#使用-slint-viewer-预览翻译" class="headerlink" title="使用 slint-viewer 预览翻译"></a>使用 slint-viewer 预览翻译</h1><p>预览<code> .slint</code> 文件时使用 <code>slint-viewer </code>预览翻译：</p><ol><li>启用<code>gettext</code>功能在编译slint-viewer时</li><li>使用<code>--translation-domain</code>和<code>translation-dir</code>选项加载并展示本地化翻译文件，语言的选择基于当前系统设定的语言。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 纯度</title>
    <link href="/2024/01/09/Slint/slint-purity/"/>
    <url>/2024/01/09/Slint/slint-purity/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-纯度"><a href="#Slint-纯度" class="headerlink" title="Slint 纯度"></a>Slint 纯度</h1><p><strong>友情提示</strong><br>本章节内容本人做了一定的补充，实际内容和原文有一定区别。原文内容使用引用符号标注。</p><blockquote><p>Slint中的属性是评估是惰性的并且”相对的、被动“的。当某个属性在被读取时，才会评估属性绑定。属性之间的依赖关系是在属性评估过程中自动发现的。该属性存储评估的结果。当属性发生更改时，会通知所有依赖属性，以便下次读取其值时，重新评估其绑定。</p></blockquote><p>这种加载方式和编程时用的懒拷贝技术并不是完全一样的，当存在一个主控件，此组件下面又存在多个小组件，他们的的宽度属性是这样设置的： <code>width : parent.width % 75%</code>。我们可以得知，子组件的宽度属性是父组件的75% 。<br>实际上实现的效果并不是在每一帧的渲染中将父组件的宽度属性乘上75%的值设置给子控件，而是在第一次设置之后，当上级组件发生属性改变之后，再将值传给后依赖此属性的后续组件。</p><blockquote><p>为了让任何相对系统都能正常工作，评估一个属性不应该改变任何可观察的状态，而应该改变属性本身。如果是这样的话，那么这个表达是“纯的”，否则就被认为有副作用。副作用是有问题的，因为并不总是清楚它们何时会发生：懒惰的评估可能会改变它们的顺序，或者影响它们是否会发生。此外，在属性的绑定评估过程中，由于副作用而对属性进行的更改可能会导致意外行为。</p></blockquote><p>如果我们写出类似这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component A &#123;<br>Rectangle&#123;<br>@children<br>&#125;<br>&#125;<br><br>component MainWindow inherits Window&#123;<br>width: A.width<br>A&#123;<br>width: parent.width<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这样的代码是无法运行的，仅借此表示一个直观的含义。主窗口的宽度需要组件A的宽度，然而组件A依赖MainWindow的宽度，一旦有一个组件被i修改了，这样就很难评估改变的顺序，这也会导致产生以外的行为。</p><blockquote><p>因此，Slint 中的绑定必须是纯的。 Slint 编译器强制纯上下文中的代码没有副作用。纯上下文包括绑定表达式、纯函数体和纯回调处理程序体。在这种情况下，不允许更改属性或调用非纯回调或函数。<br>使用 pure 关键字注释回调和公共函数，以便可以从属性绑定和其他纯回调和函数访问它们。<br>私有函数的纯度是自动推断的。您可以显式声明私有函数为“pure”，以使编译器强制执行其纯度。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component Example &#123;<br>    pure callback foo() -&gt; int;<br>    public pure function bar(x: int) -&gt; int<br>    &#123; return x + foo(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 字体处理</title>
    <link href="/2024/01/09/Slint/slint-font-handling/"/>
    <url>/2024/01/09/Slint/slint-font-handling/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-字体处理"><a href="#Slint-字体处理" class="headerlink" title="Slint 字体处理"></a>Slint 字体处理</h1><p>一些元素诸如<code>Text</code>和<code>TextInput</code> 能够渲染文本以及允许通过不同的属性自定义文本的外观。以 font- 为前缀的属性，例如 font-family、font-size 和 font-weight 会影响用于渲染到屏幕的字体的选择。如果未指定任何这些属性，则应用周围 Window 元素中的 default-font- 值，例如 default-font-family。</p><p>选择用于渲染的字体会自动从系统中获取。还可以在您的设计中包含自定义字体。自定义字体必须是 TrueType 字体 (.ttf)、TrueType 字体集合 (.ttc) 或 OpenType 字体 (.otf)。您可以使用导入语句选择自定义字体：在 .slint 文件中导入“.&#x2F;my_custom_font.ttf”。这指示 Slint 编译器包含字体并使字体系列全局可与 font-family 属性一起使用。</p><p>简单来说，Slint支持自定义字体，而且方法并不复杂。甚至只需要两个步骤就可以了</p><ol><li><code>import</code> + 字体文件路径</li><li><code>default-font-family</code> 设置字体样式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &quot;./NotoSans-Regular.ttf&quot;;<br><br>export component Example inherits Window &#123;<br>    default-font-family: &quot;Noto Sans&quot;;<br><br>    Text &#123;<br>        text: &quot;Hello World&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 焦点处理</title>
    <link href="/2024/01/08/Slint/slint-focus-handling/"/>
    <url>/2024/01/08/Slint/slint-focus-handling/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-焦点处理"><a href="#Slint-焦点处理" class="headerlink" title="Slint 焦点处理"></a>Slint 焦点处理</h1><p>某些元素(如TextInput)不仅接受来自鼠标&#x2F;手指的输入，还接受来自(虚拟)键盘的键事件。为了让控件接收这些事件，它必须具有焦点。这可以通过has-focus (out)属性看到。</p><p>你可以通过调用focus()来手动激活元素的焦点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; Button &#125; from &quot;std-widgets.slint&quot;;<br><br>export component App inherits Window &#123;<br>    VerticalLayout &#123;<br>        alignment: start;<br>        Button &#123;<br>            text: &quot;press me&quot;;<br>            clicked =&gt; &#123; input.focus(); &#125;<br>        &#125;<br>        input := TextInput &#123;<br>            text: &quot;I am a text input field&quot;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你已经在组件中包装了TextInput，那么你可以使用forward-focus属性来转发这样的焦点激活，以引用应该接收它的元素:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Slint">import &#123; Button &#125; from &quot;std-widgets.slint&quot;;<br><br>component LabeledInput inherits GridLayout &#123;<br>    forward-focus: input;<br>    Row &#123;<br>        Text &#123;<br>            text: &quot;Input Label:&quot;;<br>        &#125;<br>        input := TextInput &#123;&#125;<br>    &#125;<br>&#125;<br><br>export component App inherits Window &#123;<br>    GridLayout &#123;<br>        Button &#123;<br>            text: &quot;press me&quot;;<br>            clicked =&gt; &#123; label.focus(); &#125;<br>        &#125;<br>        label := LabeledInput &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在窗口上使用forward-focus属性，则指定的元素将在窗口第一次接收焦点时接收焦点-它将成为初始焦点元素。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 容器组件</title>
    <link href="/2024/01/08/Slint/slint-container-components/"/>
    <url>/2024/01/08/Slint/slint-container-components/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-容器组件"><a href="#Slint-容器组件" class="headerlink" title="Slint 容器组件"></a>Slint 容器组件</h1><p>在创建组件时，有时影响子元素在使用时的位置是很有用的。例如，假设有一个组件在用户放置的元素上方绘制一个标签:</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component MyApp inherits Window &#123;<br><br>    BoxWithLabel &#123;<br>        Text &#123;<br>            // ...<br>        &#125;<br>    &#125;<br><br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><p>您可以使用布局实现这样的BoxWithLabel。默认情况下，像Text元素这样的子元素成为BoxWithLabel的直接子元素，但是我们需要它们成为布局的子元素。为此，你可以在组件的元素层次结构中使用@children表达式来改变默认的子节点位置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component BoxWithLabel inherits GridLayout &#123;<br>    Row &#123;<br>        Text &#123; text: &quot;label text here&quot;; &#125;<br>    &#125;<br>    Row &#123;<br>        @children<br>    &#125;<br>&#125;<br><br>export component MyApp inherits Window &#123;<br>    preferred-height: 100px;<br>    BoxWithLabel &#123;<br>        Rectangle &#123; background: blue; &#125;<br>        Rectangle &#123; background: yellow; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面说的有点弯弯绕了，甚至前五分钟我没有理解这到底在说什么，简单来说。假设一个用户创建了一个组件，但是这个组件实际的工作性质是一个容器，也就是可以嵌入其他组件，那么就在需要嵌入的地方塞一个<code>@children</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component GridRectangle &#123;  <br>    GridLayout &#123;  <br>        spacing: 5px;  <br>        Row&#123;  <br>            Rectangle &#123;  <br>                width: 50px;  <br>                height: 50px;  <br>                background: #FFDDDD;  <br>            &#125;  <br>            Rectangle &#123;  <br>                width: 50px;  <br>                height: 50px;  <br>                background: #FFEEDD;  <br>            &#125;  <br>        &#125;  <br>        Row&#123;  <br>            Rectangle &#123;  <br>                width: 50px;  <br>                height: 50px;  <br>                background: #FFEEEE;  <br>                @children  <br>            &#125;  <br>            Rectangle &#123;  <br>                width: 50px;  <br>                height: 50px;  <br>                background: #FFDDEE;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br>component ColordRectangle &#123;  <br>    Rectangle &#123;  <br>        background: lightpink;  <br>        @children  <br>    &#125;  <br>&#125;  <br>  <br>export component MainWindow inherits Window &#123;  <br>    preferred-width: 640px;  <br>    preferred-height: 480px;  <br>  <br>    max-height: 640px;  <br>    max-width: 480px;  <br>  <br>    ColordRectangle &#123;  <br>        preferred-width: parent.width;  <br>        preferred-height: parent.height;  <br>        GridRectangle &#123;&#125;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>@children是一个表达式，它允许您在自定义组件中嵌套其他组件。例如，如果您想在BoxWithLabel组件中添加一个标签，您可以将子元素放在BoxWithLabel的布局中，而不是直接作为BoxWithLabel的子元素。这样，您就可以使用@children表达式来控制标签的位置。</p><p><strong><code>@children</code>占位符只能在元素层次结构中出现一次</strong><br>比如上面的例子修改成为这样是不可以的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component BoxWithLabel inherits GridLayout &#123;<br>    Row &#123;<br>        @children<br>    &#125;<br>    Row &#123;<br>        @children<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint 元素的定位和布局</title>
    <link href="/2023/12/22/Slint/slint-position-layout/"/>
    <url>/2023/12/22/Slint/slint-position-layout/</url>
    
    <content type="html"><![CDATA[<p>2# Slint 元素的定位和布局<br>所有视觉元素都显示在一个窗口中。 x 和 y 属性存储元素相对于其父元素的坐标。 Slint 通过将父元素的位置添加到元素的位置来确定元素的绝对位置。如果父元素存在了一个坐标，那么子类就会从进行坐标的累加计算，直到顶级元素。<br><code>width</code>和<code>height</code>会存储元素的宽度和高度（很容易理解不是）</p><p>您可以通过两种方式放置元素来创建整个图形用户界面：</p><ul><li>通过<code>x</code>,<code>y</code>,<code>width</code>,<code>height</code>属性显式创建</li><li>通过布局元素自动设置</li></ul><p>显式放置非常适合元素很少的静态场景。布局适用于复杂的用户界面，并有助于创建可扩展的用户界面。布局元素表达元素之间的几何关系。</p><h2 id="显式放置"><a href="#显式放置" class="headerlink" title="显式放置"></a>显式放置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component Example inherits Window &#123;<br>    width: 200px;    //设置窗口宽度为200px<br>    height: 200px;   //设置窗口高度为200px<br>    Rectangle &#123;      //定义一个矩形<br>        x: 100px;<br>        y: 70px;<br>        width: parent.width - self.x;    // 宽度是父元素宽度减自身x位置<br>        height: parent.height - self.y;<br>        background: blue;    // 背景颜色是蓝色<br>        Rectangle &#123;<br>            x: 10px;<br>            y: 5px;<br>            width: 50px;<br>            height: 30px;<br>            background: green;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个矩形的位置和内部绿色矩形的大小都是固定的。外部蓝色矩形的大小是使用宽度和高度属性的绑定表达式自动计算的。计算结果是左下角与窗口的角对齐 - 只要窗口的宽度和高度发生变化，它就会更新。</p><p>当为任何几何属性指定显式值时，Slint 要求您为数字附加一个单位。您可以选择两种不同的单位：</p><ul><li>逻辑像素，使用px单位后缀。这是推荐单位。</li><li>物理像素，使用phx单位后缀</li></ul><p>逻辑像素会根据系统配置的设备像素比率自动缩放。  宽度和高度属性也可以指定为百分比单位，该单位相对于父元素应用。例如宽度：50% 表示父级宽度的一半。  </p><p>x 和 y 属性的默认值使得元素在其父元素中居中。  </p><p>宽度和高度的默认值取决于元素的类型。有些元素会根据它们的内容自动调整大小，比如Image、Text和大多数小部件。以下元素没有内容，当它们没有子元素时，默认会填充它们的父元素:</p><ul><li><code>Rectangle</code></li><li><code>TouchArea</code></li><li><code>FocusScope</code></li><li><code>Flickable</code><br>布局也默认填充父级，无论它们自己的首选大小如何。<br>其他元素（包括没有基础的自定义元素）默认使用其首选尺寸。</li></ul><h2 id="首选尺寸"><a href="#首选尺寸" class="headerlink" title="首选尺寸"></a>首选尺寸</h2><p>元素的首选大小可以通过preferred-width和preferred-height属性指定。</p><p>当未显式设置时，首选大小取决于子元素，并且是具有更大首选大小的子元素的首选大小，其x和y属性未设置。因此，首选大小从子到父计算，就像其他约束(最大和最小大小)一样，除非显式覆盖。</p><p>一种特殊情况是使用100%作为值将首选大小设置为父元素的大小。例如，这个组件将默认使用父组件的大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs slint">component MyComponent &#123;<br>    preferred-width: 100%;<br>    preferred-height: 100%;<br>    // ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用布局自动放置"><a href="#使用布局自动放置" class="headerlink" title="使用布局自动放置"></a>使用布局自动放置</h2><p>Slint带有不同的布局元素，可以自动计算其子元素的位置和大小:</p><ul><li><code>verticallout</code> &#x2F; <code>HorizontalLayout</code>:子元素沿着垂直或水平轴放置。可以理解是水平对齐和垂直布局</li><li><code>GridLayout</code> 元素通过行列进行放置<br>布局是可以嵌套的，通过嵌套布局可以完成更加复杂的组建排布</li></ul><p>您可以使用不同的约束来调整自动放置，以适应用户界面的设计。每个元素都有最小大小、最大大小和首选大小。使用以下属性显式设置这些属性:</p><ul><li><code>min-width</code></li><li><code>min-height</code></li><li><code>max-width</code></li><li><code>max-height</code></li><li><code>preferred-width</code></li><li><code>preferred-height</code><br>任何指明了<code>width</code>和<code>height</code>的元素都会存在固定的大小（比如给MainWindow设置了大小，那么就无法再放大和缩小窗口了）</li></ul><p>当布局中有额外的空间时，元素可以沿着布局轴拉伸。你可以用这些属性来控制元素和它的兄弟元素之间的拉伸系数:</p><ul><li><code>horizontal-stretch</code></li><li><code>vertical-stretch</code><br>值为 0 意味着元素根本不会拉伸。如果所有元素的拉伸因子都为 0，则所有元素都会同等拉伸。<br>这些约束属性的默认值可能取决于元素的内容。如果元素的 x 或 y 未设置，这些约束也会自动应用于父元素。</li></ul><h2 id="布局元素的通用属性"><a href="#布局元素的通用属性" class="headerlink" title="布局元素的通用属性"></a>布局元素的通用属性</h2><ul><li><code>spacing</code> 控制两个并列元素的间距</li><li><code>padding</code> 这指定布局内的填充、元素之间的空间以及布局的边框距离（可以参考css的盒子模型）。<br>如果不设置spacing的大小（默认为0）则会导致两个元素堆积在一起。为了进行更细粒度的控制，可以将 padding 属性拆分为布局每一侧的属性：</li><li><code>padding-left</code></li><li><code>padding-right</code></li><li><code>padding-top</code></li><li><code>padding-bottom</code></li></ul><h2 id="VerticalLayout-和-HorizontalLayout"><a href="#VerticalLayout-和-HorizontalLayout" class="headerlink" title="VerticalLayout 和 HorizontalLayout"></a><code>VerticalLayout</code> 和 <code>HorizontalLayout</code></h2><p><code>verticalalLayout</code>和<code>HorizontalLayout</code>元素将它们的子元素放置在列或行中。默认情况下，它们会拉伸或收缩以占用整个空间。您可以根据需要调整元素的对齐方式。</p><p>下面的示例将蓝色和黄色矩形放在一行中，并均匀地拉伸到200个逻辑像素的宽度上:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs slint">// Stretch by default<br>export component Example inherits Window &#123;<br>    width: 200px;<br>    height: 200px;<br>    HorizontalLayout &#123;<br>        Rectangle &#123; background: blue; min-width: 20px; &#125;<br>        Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一方面，下面的示例指定矩形应对齐布局的开始(可视左侧)。这将导致不拉伸，而是矩形保留其指定的最小宽度:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs slint">// Unless an alignment is specified<br>export component Example inherits Window &#123;<br>    width: 200px;<br>    height: 200px;<br>    HorizontalLayout &#123;<br>        alignment: start;<br>        Rectangle &#123; background: blue; min-width: 20px; &#125;<br>        Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的例子包含了两个更复杂场景的布局:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component Example inherits Window &#123;<br>    width: 200px;<br>    height: 200px;<br>    HorizontalLayout &#123;<br>        // Side panel<br>        Rectangle &#123; background: green; width: 10px; &#125;<br><br>        VerticalLayout &#123;<br>            padding: 0px;<br>            //toolbar<br>            Rectangle &#123; background: blue; height: 7px; &#125;<br><br>            Rectangle &#123;<br>                border-color: red; border-width: 2px;<br>                HorizontalLayout &#123;<br>                    Rectangle &#123; border-color: blue; border-width: 2px; &#125;<br>                    Rectangle &#123; border-color: green; border-width: 2px; &#125;<br>                &#125;<br>            &#125;<br>            Rectangle &#123;<br>                border-color: orange; border-width: 2px;<br>                HorizontalLayout &#123;<br>                    Rectangle &#123; border-color: black; border-width: 2px; &#125;<br>                    Rectangle &#123; border-color: pink; border-width: 2px; &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h2><p>如果指定了每个元素的宽度或高度，则根据它们的宽度或高度设置大小，否则它将被设置为最小大小，这是通过min-width或min-height属性设置的，或者是内部布局的最小大小，无论大小较大。</p><p>元素按照对齐方式放置。只有当布局的对齐属性为layoutalalignment时，元素的大小才会大于最小尺寸。拉伸(默认)</p><p>这个例子展示了不同的对齐可能性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component Example inherits Window &#123;<br>    width: 300px;<br>    height: 200px;<br>    VerticalLayout &#123;<br>        HorizontalLayout &#123;<br>            alignment: stretch;<br>            Text &#123; text: &quot;stretch (default)&quot;; &#125;<br>            Rectangle &#123; background: blue; min-width: 20px; &#125;<br>            Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>        &#125;<br>        HorizontalLayout &#123;<br>            alignment: start;<br>            Text &#123; text: &quot;start&quot;; &#125;<br>            Rectangle &#123; background: blue; min-width: 20px; &#125;<br>            Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>        &#125;<br>        HorizontalLayout &#123;<br>            alignment: end;<br>            Text &#123; text: &quot;end&quot;; &#125;<br>            Rectangle &#123; background: blue; min-width: 20px; &#125;<br>            Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>        &#125;<br>        HorizontalLayout &#123;<br>            alignment: start;<br>            Text &#123; text: &quot;start&quot;; &#125;<br>            Rectangle &#123; background: blue; min-width: 20px; &#125;<br>            Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>        &#125;<br>        HorizontalLayout &#123;<br>            alignment: center;<br>            Text &#123; text: &quot;center&quot;; &#125;<br>            Rectangle &#123; background: blue; min-width: 20px; &#125;<br>            Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>        &#125;<br>        HorizontalLayout &#123;<br>            alignment: space-between;<br>            Text &#123; text: &quot;space-between&quot;; &#125;<br>            Rectangle &#123; background: blue; min-width: 20px; &#125;<br>            Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>        &#125;<br>        HorizontalLayout &#123;<br>            alignment: space-around;<br>            Text &#123; text: &quot;space-around&quot;; &#125;<br>            Rectangle &#123; background: blue; min-width: 20px; &#125;<br>            Rectangle &#123; background: yellow; min-width: 30px; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/slint/20231222205719.png"></p><h2 id="拉伸算法"><a href="#拉伸算法" class="headerlink" title="拉伸算法"></a>拉伸算法</h2><p>当对齐设置为拉伸(默认值)时，元素的大小将达到最小大小，然后额外的空间将在元素之间共享，这些元素与使用水平拉伸和垂直拉伸属性设置的拉伸因子成比例。拉伸后的尺寸不会超过最大尺寸。拉伸因子是一个浮点数。具有默认内容大小的元素通常默认为0，而默认为其父元素大小的元素默认为1。伸缩因子为0的元素将保持其最小大小，除非所有其他元素的伸缩因子也为0或达到其最大大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component Example inherits Window &#123;<br>    width: 300px;<br>    height: 200px;<br>    VerticalLayout &#123;<br>        // Same stretch factor (1 by default): the size is divided equally<br>        HorizontalLayout &#123;<br>            Rectangle &#123; background: blue; &#125;<br>            Rectangle &#123; background: yellow;&#125;<br>            Rectangle &#123; background: green;&#125;<br>        &#125;<br>        // Elements with a bigger min-width are given a bigger size before they expand<br>        HorizontalLayout &#123;<br>            Rectangle &#123; background: cyan; min-width: 100px;&#125;<br>            Rectangle &#123; background: magenta; min-width: 50px;&#125;<br>            Rectangle &#123; background: gold;&#125;<br>        &#125;<br>        // Stretch factor twice as big:  grows twice as much<br>        HorizontalLayout &#123;<br>            Rectangle &#123; background: navy; horizontal-stretch: 2;&#125;<br>            Rectangle &#123; background: gray; &#125;<br>        &#125;<br>        // All elements not having a maximum width have a stretch factor of 0 so they grow<br>        HorizontalLayout &#123;<br>            Rectangle &#123; background: red; max-width: 20px; &#125;<br>            Rectangle &#123; background: orange; horizontal-stretch: 0; &#125;<br>            Rectangle &#123; background: pink; horizontal-stretch: 0; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/20231222205558.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component Example inherits Window &#123;<br>    width: 200px;<br>    height: 50px;<br>    HorizontalLayout &#123;<br>        Rectangle &#123; background: green; &#125;<br>        for t in [ &quot;Hello&quot;, &quot;World&quot;, &quot;!&quot; ] : Text &#123;<br>            text: t;<br>        &#125;<br>        Rectangle &#123; background: blue; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/20231222205536.png"></p><h2 id="表格对齐"><a href="#表格对齐" class="headerlink" title="表格对齐"></a>表格对齐</h2><p>GridLayout将元素放置在网格中。每个元素获得row、col、rowspan和colspan属性。可以使用Row子元素，也可以显式设置Row属性。这些属性在编译时必须是静态已知的，因此不可能使用算术运算或依赖属性。到目前为止，在网格布局中不允许使用for或if。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component Foo inherits Window &#123;<br>    width: 200px;<br>    height: 200px;<br>    GridLayout &#123;<br>        spacing: 5px;<br>        Row &#123;<br>            Rectangle &#123; background: red; &#125;<br>            Rectangle &#123; background: blue; &#125;<br>        &#125;<br>        Row &#123;<br>            Rectangle &#123; background: yellow; &#125;<br>            Rectangle &#123; background: green; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/slint/20231222205302.png" alt="效果图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component Foo inherits Window &#123;<br>    width: 200px;<br>    height: 150px;<br>    GridLayout &#123;<br>        spacing: 0px;<br>        Rectangle &#123; background: red; &#125;<br>        Rectangle &#123; background: blue; &#125;<br>        Rectangle &#123; background: yellow; row: 1; &#125;<br>        Rectangle &#123; background: green; &#125;<br>        Rectangle &#123; background: black; col: 2; row: 0; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>![[20231222205507.png]]</p><h2 id="一个综合实例"><a href="#一个综合实例" class="headerlink" title="一个综合实例"></a>一个综合实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs slint">component GridRectangle &#123;<br>    GridLayout &#123;<br>        spacing: 5px;<br>        Row&#123;<br>            Rectangle &#123;<br>                width: 50px;<br>                height: 50px;<br>                background: #FFDDDD;<br>            &#125;<br>            Rectangle &#123;<br>                width: 50px;<br>                height: 50px;<br>                background: #FFEEDD;<br>            &#125;<br>        &#125;<br>        Row&#123;<br>            Rectangle &#123;<br>                width: 50px;<br>                height: 50px;<br>                background: #FFEEEE;<br>            &#125;<br>            Rectangle &#123;<br>                width: 50px;<br>                height: 50px;<br>                background: #FFDDEE;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>export component MainWindow inherits Window &#123;<br>    in property &lt;int&gt; window_width;<br>    in property &lt;int&gt; window_height;<br><br>    preferred-width: 640px;<br>    preferred-height: 480px;<br><br>    max-height: 640px;<br>    max-width: 480px;<br><br>    Rectangle &#123;<br>        width: parent.width;<br>        height: parent.height;<br>        background: #FFEEFF;<br><br>        HorizontalLayout &#123;<br>            alignment: space-between;<br>            GridRectangle&#123;&#125;<br>            Rectangle &#123;<br>                height: parent.height;<br>                width: 15%;<br>                background: #FFCCBB;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/slint/20231222204439.png" alt="效果图"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint C++  实现最后的逻辑</title>
    <link href="/2023/12/21/Slint/slint-game-logic/"/>
    <url>/2023/12/21/Slint/slint-game-logic/</url>
    
    <content type="html"><![CDATA[<h1 id="实现最后的逻辑"><a href="#实现最后的逻辑" class="headerlink" title="实现最后的逻辑"></a>实现最后的逻辑</h1><p>我们也将用 C++ 实现游戏规则。 Slint 的总体理念是，仅用 .slint 语言实现用户界面，并用您最喜欢的编程语言实现业务逻辑。游戏规则应强制规定最多有两块牌的窗帘打开。如果图块匹配，那么我们认为它们已解决并且它们保持打开状态。否则，我们会等待一段时间，以便玩家可以记住图标的位置，然后再次关闭它们。</p><span id="more"></span><p>我们将修改 memory.slint 文件中的 .slint 标记，以便在用户单击图块时向 C++ 代码发出信号。需要对 MainWindow 进行两处更改： 我们需要为 MainWindow 添加一种调用 C++ 代码的方法，以便检查一对图块是否已被解决。我们需要添加一个属性，C++ 代码可以切换该属性以禁用进一步的图块交互，以防止玩家打开超过允许的图块。不允许作弊！首先，我们将回调和属性声明粘贴到 MainWindow 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs slint">export component MainWindow inherits Window &#123;<br>    width: 326px;<br>    height: 326px;<br><br>    callback check_if_pair_solved(); // 在这里添加一个回调函数<br>    in property &lt;bool&gt; disable_tiles; // 对外暴露一个禁用磁贴的变量<br><br>    in-out property &lt;[TileData]&gt; memory_tiles: [<br>       &#123; image: @image-url(&quot;icons/at.png&quot;) &#125;,<br></code></pre></td></tr></table></figure><p>之后修改组件MainWindow中的内容，修改其中的点击事件，在原来是让图片从可视化到不可视化的切换，现在则首先判断是否是禁用状态的，再修改图片可视化状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Slint">for tile[i] in memory_tiles : MemoryTile &#123;<br>    x: mod(i, 4) * 74px;<br>    y: floor(i / 4) * 74px;<br>    width: 64px;<br>    height: 64px;<br>    icon: tile.image;<br>    open_curtain: tile.image_visible || tile.solved;<br>    // propagate the solved status from the model to the tile<br>    solved: tile.solved;<br>    clicked =&gt; &#123;<br>        // old: tile.image_visible = !tile.image_visible;<br>        // new:<br>        if (!root.disable_tiles) &#123;<br>            tile.image_visible = !tile.image_visible;<br>            root.check_if_pair_solved();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 C++ 方面，我们现在可以向 check_if_pair_solved 回调添加一个处理程序，该处理程序将检查是否打开了两个图块。如果它们匹配，则已求解的属性在模型中设置为 true。如果它们不匹配，则启动一个计时器，该计时器将在一秒钟后关闭它们。当计时器运行时，我们禁用每个图块，以便在此期间无法单击任何内容。<br><strong>官方代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br>    <span class="hljs-keyword">auto</span> tiles_model = std::make_shared&lt;slint::VectorModel&lt;TileData&gt;&gt;(new_tiles);<br>    main_window-&gt;<span class="hljs-built_in">set_memory_tiles</span>(tiles_model);<br><br>    main_window-&gt;<span class="hljs-built_in">on_check_if_pair_solved</span>(<br>            [main_window_weak = slint::<span class="hljs-built_in">ComponentWeakHandle</span>(main_window)] &#123;<br>                <span class="hljs-keyword">auto</span> main_window = *main_window_weak.<span class="hljs-built_in">lock</span>();<br>                <span class="hljs-keyword">auto</span> tiles_model = main_window-&gt;<span class="hljs-built_in">get_memory_tiles</span>();<br>                <span class="hljs-type">int</span> first_visible_index = <span class="hljs-number">-1</span>;<br>                TileData first_visible_tile;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tiles_model-&gt;<span class="hljs-built_in">row_count</span>(); ++i) &#123;<br>                    <span class="hljs-keyword">auto</span> tile = *tiles_model-&gt;<span class="hljs-built_in">row_data</span>(i);<br>                    <span class="hljs-keyword">if</span> (!tile.image_visible || tile.solved)<br>                        <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (first_visible_index == <span class="hljs-number">-1</span>) &#123;<br>                        first_visible_index = i;<br>                        first_visible_tile = tile;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-type">bool</span> is_pair_solved = tile == first_visible_tile;<br>                    <span class="hljs-keyword">if</span> (is_pair_solved) &#123;<br>                        first_visible_tile.solved = <span class="hljs-literal">true</span>;<br>                        tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(first_visible_index,<br>                                                  first_visible_tile);<br>                        tile.solved = <span class="hljs-literal">true</span>;<br>                        tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(i, tile);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    main_window-&gt;<span class="hljs-built_in">set_disable_tiles</span>(<span class="hljs-literal">true</span>);<br><br>                    slint::Timer::<span class="hljs-built_in">single_shot</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>),<br>                        [=]() <span class="hljs-keyword">mutable</span> &#123;<br>                            main_window-&gt;<span class="hljs-built_in">set_disable_tiles</span>(<span class="hljs-literal">false</span>);<br>                            first_visible_tile.image_visible = <span class="hljs-literal">false</span>;<br>                            tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(first_visible_index,<br>                                                      first_visible_tile);<br>                            tile.image_visible = <span class="hljs-literal">false</span>;<br>                            tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(i, tile);<br>                        &#125;);<br>                &#125;<br>            &#125;);<br><br>    main_window-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>代码解析</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 调用main_window的on_check_if_pair_solved函数，检查是否是成对</span><br>main_window-&gt;<span class="hljs-built_in">on_check_if_pair_solved</span>(<br>            [main_window_weak = slint::<span class="hljs-built_in">ComponentWeakHandle</span>(main_window)] &#123;<br>                <span class="hljs-keyword">auto</span> main_window = main_window_weak.<span class="hljs-built_in">lock</span>().<span class="hljs-built_in">value</span>();<br>                <span class="hljs-keyword">auto</span> tiles_model = main_window-&gt;<span class="hljs-built_in">get_memory_tiles</span>();<br>                <span class="hljs-type">int</span> first_visible_index = <span class="hljs-number">-1</span>;<br>                TileData first_visible_tile;<br>                <span class="hljs-comment">// 遍历每一行</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tiles_model-&gt;<span class="hljs-built_in">row_count</span>(); ++i) &#123;<br>                    <span class="hljs-keyword">auto</span> tile = tiles_model.<span class="hljs-built_in">get</span>()-&gt;<span class="hljs-built_in">row_data</span>(i).<span class="hljs-built_in">value</span>();<br>                    <span class="hljs-comment">// 如果tile不可见或者已经解决，则跳过</span><br>                    <span class="hljs-keyword">if</span> (!tile.image_visible || tile.solved)<br>                        <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// 如果当前行是第一个可见行，则记录下当前tile</span><br>                    <span class="hljs-keyword">if</span> (first_visible_index == <span class="hljs-number">-1</span>) &#123;<br>                        first_visible_index = i;<br>                        first_visible_tile = tile;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果当前tile和第一个可见tile相同，则将两个tile都设置为已解决</span><br>                    <span class="hljs-type">bool</span> is_pair_solved = tile == first_visible_tile;<br>                    <span class="hljs-keyword">if</span> (is_pair_solved) &#123;<br>                        first_visible_tile.solved = <span class="hljs-literal">true</span>;<br>                        tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(first_visible_index,<br>                                                  first_visible_tile);<br>                        tile.solved = <span class="hljs-literal">true</span>;<br>                        tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(i, tile);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 如果不是成对，则禁用所有tile，1秒后恢复</span><br>                    main_window-&gt;<span class="hljs-built_in">set_disable_tiles</span>(<span class="hljs-literal">true</span>);<br><br>                    slint::Timer::<span class="hljs-built_in">single_shot</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>),<br>                        [=]() <span class="hljs-keyword">mutable</span> &#123;<br>                            main_window-&gt;<span class="hljs-built_in">set_disable_tiles</span>(<span class="hljs-literal">false</span>);<br>                            first_visible_tile.image_visible = <span class="hljs-literal">false</span>;<br>                            tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(first_visible_index,<br>                                                      first_visible_tile);<br>                            tile.image_visible = <span class="hljs-literal">false</span>;<br>                            tiles_model-&gt;<span class="hljs-built_in">set_row_data</span>(i, tile);<br>                        &#125;);<br>                &#125;<br>            &#125;);<br></code></pre></td></tr></table></figure><p><strong>至此，整个Slint C++ tutorial 就完结了（撒花）</strong><br>基本摸清了创建一个简单Slint应用的简单流程，之后便是研究研究其他控件还有通信的东西了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint C++  生成随机排列的磁贴</title>
    <link href="/2023/12/21/Slint/slint-shuffle-tile/"/>
    <url>/2023/12/21/Slint/slint-shuffle-tile/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-C-生成随机排列的磁贴"><a href="#Slint-C-生成随机排列的磁贴" class="headerlink" title="Slint C++ 生成随机排列的磁贴"></a>Slint C++ 生成随机排列的磁贴</h1><p>我们要做的就是获取以 .slint 语言声明的图块列表，复制它，然后对其进行打乱。我们将通过 C++ 代码访问 memory_tiles 属性来完成此操作。对于每个顶级属性，都会生成一个 getter 和 setter 函数 - 在我们的例子中为 get_memory_tiles 和 set_memory_tiles。由于 memory_tiles 是 .slint 语言中的数组，因此它表示为 std::shared_ptr<a href="slint::Model">slint::Model</a>。我们无法修改 .slint 生成的模型，但我们可以从中提取图块，并将其放入继承自 Model 的 slint::VectorModel 中。 VectorModel允许我们进行修改，我们可以用它来替换静态生成的模型。</p><p><strong>官方的示例代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// ...</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span> <span class="hljs-comment">// Added</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> main_window = MainWindow::<span class="hljs-built_in">create</span>();<br>    <span class="hljs-keyword">auto</span> old_tiles = main_window-&gt;<span class="hljs-built_in">get_memory_tiles</span>();<br>    std::vector&lt;TileData&gt; new_tiles;<br>    new_tiles.<span class="hljs-built_in">reserve</span>(old_tiles-&gt;<span class="hljs-built_in">row_count</span>() * <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; old_tiles-&gt;<span class="hljs-built_in">row_count</span>(); ++i) &#123;<br>        new_tiles.<span class="hljs-built_in">push_back</span>(*old_tiles-&gt;<span class="hljs-built_in">row_data</span>(i));<br>        new_tiles.<span class="hljs-built_in">push_back</span>(*old_tiles-&gt;<span class="hljs-built_in">row_data</span>(i));<br>    &#125;<br>    std::default_random_engine rng &#123;&#125;;<br>    std::<span class="hljs-built_in">shuffle</span>(new_tiles.<span class="hljs-built_in">begin</span>(), new_tiles.<span class="hljs-built_in">end</span>(), rng);<br>    <span class="hljs-keyword">auto</span> tiles_model = std::make_shared&lt;slint::VectorModel&lt;TileData&gt;&gt;(new_tiles);<br>    main_window-&gt;<span class="hljs-built_in">set_memory_tiles</span>(tiles_model);<br><br>    main_window-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>修改后并添加注释的代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memory.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Create the main window</span><br>    <span class="hljs-keyword">auto</span> main_window = MainWindow::<span class="hljs-built_in">create</span>();<br><br>    <span class="hljs-comment">// Get the current tiles and store them</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> old_tiles = main_window-&gt;<span class="hljs-built_in">get_memory_tiles</span>();<br>    <span class="hljs-comment">// Create a new vector to store the new tiles</span><br>    std::vector&lt;TileData&gt; new_tiles&#123;&#125;;<br>    <span class="hljs-comment">// Reserve space for the new tiles</span><br>    new_tiles.<span class="hljs-built_in">reserve</span>(old_tiles-&gt;<span class="hljs-built_in">row_count</span>() * <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// Copy the old tiles into the new vector</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; old_tiles-&gt;<span class="hljs-built_in">row_count</span>(); i++) &#123;<br>        new_tiles.<span class="hljs-built_in">emplace_back</span>(*old_tiles-&gt;<span class="hljs-built_in">row_data</span>(i));<br>        new_tiles.<span class="hljs-built_in">emplace_back</span>(*old_tiles-&gt;<span class="hljs-built_in">row_data</span>(i));<br>    &#125;<br>    <span class="hljs-comment">// Create a random number generator</span><br>    <span class="hljs-function">std::default_random_engine <span class="hljs-title">rng</span><span class="hljs-params">(std::random_device&#123;&#125;())</span></span>;<br>    <span class="hljs-comment">// Shuffle the new tiles</span><br>    std::<span class="hljs-built_in">shuffle</span>(new_tiles.<span class="hljs-built_in">begin</span>(), new_tiles.<span class="hljs-built_in">end</span>(), rng);<br><br>    <span class="hljs-comment">// Create a new model with the shuffled tiles</span><br>    <span class="hljs-keyword">auto</span> &amp;&amp;tiles_model = std::make_shared&lt;slint::VectorModel&lt;TileData&gt;&gt;(new_tiles);<br>    <span class="hljs-comment">// Set the new tiles as the memory tiles</span><br>    main_window-&gt;<span class="hljs-built_in">set_memory_tiles</span>(tiles_model);<br><br>    <span class="hljs-comment">// Run the main window</span><br>    main_window-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Slint C++  创建更多的磁贴</title>
    <link href="/2023/12/20/Slint/slint-more-tile/"/>
    <url>/2023/12/20/Slint/slint-more-tile/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-C-创建更多的磁贴"><a href="#Slint-C-创建更多的磁贴" class="headerlink" title="Slint C++ 创建更多的磁贴"></a>Slint C++ 创建更多的磁贴</h1><p>前一个章节我们完成了一个磁贴的创建，接下来我们需要创建一个网格，在里面创建更多的磁贴来完成游戏的基本布局。当然，我们需要分两步走：</p><span id="more"></span><ol><li><p>数据模型：这应该是一个数组，其中每个元素描述图块数据结构，例如图像的 url、图像是否可见以及该图块是否已解决。我们从 C++ 代码修改模型。  一种使用上面的 .slint 标记代码创建多个图块实例的方法。  </p></li><li><p>在 Slint 中，我们可以使用括号声明结构数组，以创建模型。我们可以使用 for 循环创建同一元素的多个实例。在 .slint 中，for 循环是声明性的，并且在模型更改时自动更新。我们实例化所有不同的 MemoryTile 元素，并根据它们的索引将它们放置在网格上，图块之间有一点间距。</p></li></ol><h2 id="创建一个磁贴模型"><a href="#创建一个磁贴模型" class="headerlink" title="创建一个磁贴模型"></a>创建一个磁贴模型</h2><p>现在我们需要控制多个磁贴了，如果还是像之前那样操作单个磁贴就非常麻烦，他有不同的属性：图片地址，是否可见，是否被点击。在C++中可以使用结构体或者类来完成我们的需求，在<code>Slint</code>中也可以实现，让我们在<code>.slint</code>文件中最上面添加他们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Slint">struct TileData&#123;<br>image: image,<br>image_visable: bool,<br>solved: bool,<br>&#125;<br></code></pre></td></tr></table></figure><p>创建了一个叫做<code>TileData</code>的结构体，结构体冒号左边的是名字，右边是类型：</p><ul><li>image:  图片类型，用来存放图片</li><li>image_visable:  图片是否可见</li><li>sovled：是否被消除掉，（我不是很喜欢这个名字）</li></ul><h2 id="修改MainWindow组件"><a href="#修改MainWindow组件" class="headerlink" title="修改MainWindow组件"></a>修改MainWindow组件</h2><p>接下来，我们使用以下代码片段替换 memory.slint 文件底部的导出组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Slint">export component MainWindow inherits Window &#123;<br>    width: 326px;<br>    height: 326px;<br><br>    in property &lt;[TileData]&gt; memory_tiles: [<br>        &#123; image: @image-url(&quot;icons/at.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/balance-scale.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/bicycle.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/bus.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/cloud.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/cogs.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/motorcycle.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/video.png&quot;) &#125;,<br>    ];<br>    for tile[i] in memory_tiles : MemoryTile &#123;<br>        x: mod(i, 4) * 74px;<br>        y: floor(i / 4) * 74px;<br>        width: 64px;<br>        height: 64px;<br>        icon: tile.image;<br>        open_curtain: tile.image_visible || tile.solved;<br>        // propagate the solved status from the model to the tile<br>        solved: tile.solved;<br>        clicked =&gt; &#123;<br>            tile.image_visible = !tile.image_visible;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p><code>in property &lt;[TileData]&gt; memory_tiles: [ ... ]</code>：定义了一个名为<code>memory_tiles</code>的属性，其类型为<code>&lt;[TileData]&gt;</code>，表示它是一个数组，其中每个元素都是一个<code>TileData</code>类型的对象。<code>TileData</code>类型未知，可能是一个包含图像URL和其他属性的对象。</p></li><li><p><code>for tile[i] in memory_tiles : MemoryTile &#123; ... &#125;</code>：这是一个使用QML的for循环语法遍历<code>memory_tiles</code>数组的过程。对于数组中的每个元素，都会创建一个名为<code>tile</code>的局部变量，并将其传递给名为<code>MemoryTile</code>的子组件。</p></li><li><p><code>x: mod(i, 4) * 74px;</code> 和 <code>y: floor(i / 4) * 74px;</code>：这两个表达式用于计算<code>tile</code>组件的坐标。<code>mod(i, 4)</code>表示将<code>i</code>除以4的余数，<code>floor(i / 4)</code>表示将<code>i</code>除以4的整数部分向下取整。然后，这些值乘以74像素（这是每个小方块的宽度），以计算<code>tile</code>组件的x和y坐标。</p></li><li><p><code>width: 64px;</code> 和 <code>height: 64px;</code>：定义了<code>tile</code>组件的宽度和高度，均为64像素。</p></li><li><p><code>icon: tile.image;</code>：将<code>tile.image</code>（可能是图像URL或其他属性）分配给<code>icon</code>属性，该属性将显示在<code>tile</code>组件上。</p></li><li><p><code>open_curtain: tile.image_visible || tile.solved;</code>：这个表达式定义了<code>open_curtain</code>属性的值。<code>tile.image_visible</code>是一个布尔值，表示图像是否可见。<code>tile.solved</code>也是一个布尔值，表示该方块是否已解决。<code>||</code>表示逻辑或操作，即如果<code>tile.image_visible</code>为真或<code>tile.solved</code>为真，则<code>open_curtain</code>为真。这意味着<code>tile</code>组件的遮罩层（如果有的话）将始终显示。</p></li><li><p><code>solved: tile.solved;</code>：将<code>tile.solved</code>（布尔值，表示方块是否已解决）分配给<code>solved</code>属性。</p></li><li><p><code>clicked =&gt; &#123; ... &#125;</code>：这是一个事件处理程序，当<code>tile</code>组件被单击时触发。事件处理程序中的代码将在被单击的<code>tile</code>组件上执行。</p></li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>你也可以将数组复制一次，这样可以得到4x4个完整的磁贴</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs Slint">struct TileData &#123;<br>    image: image,<br>    image_visible: bool,<br>    solved: bool,<br>&#125;<br><br>component MemoryTile inherits Rectangle&#123;<br>    callback clicked;  <br>    in property &lt;bool&gt; open_curtain; <br>    in property &lt;bool&gt; solved;<br>    in property &lt;image&gt; icon;<br><br>    width: 64px;<br>    height: 64px;<br>    background: solved? darkgrey : grey;<br><br>    animate background &#123;<br>         duration: 800ms;<br>    &#125;<br><br>    Image &#123;<br>        width: parent.width;<br>        height: parent.height;<br>        source: icon;<br>    &#125;<br><br>    // 左幕布<br>    Rectangle &#123;<br>        width: open_curtain ? 0px : (parent.width / 2);<br>        height: parent.height;<br>        x: 0px;<br>        background: darkgrey;<br>        animate width &#123;<br>             duration: 250ms;<br>             easing: ease-in;<br>        &#125;<br>    &#125;<br><br>    // 右幕布<br>    Rectangle &#123;<br>        width: open_curtain ? 0px : (parent.width / 2);<br>        height: parent.height;<br>        x: open_curtain ? parent.width : (parent.width / 2);<br>        background: darkgrey;<br>        animate width &#123;<br>            duration: 250ms;<br>            easing: ease-in;<br>       &#125;<br>       animate x &#123;<br>            duration: 250ms;<br>            easing: ease-in;<br>       &#125;<br>    &#125;<br><br>    TouchArea &#123;<br>        clicked =&gt; &#123;<br>            root.clicked();<br>        &#125;<br>    &#125;<br>&#125;<br>export component MainWindow inherits Window &#123;<br>    width: 326px;<br>    height: 326px;<br><br>    in property &lt;[TileData]&gt; memory_tiles: [<br>        &#123; image: @image-url(&quot;icons/at.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/balance-scale.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/bicycle.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/bus.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/cloud.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/cogs.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/motorcycle.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/video.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/at.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/balance-scale.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/bicycle.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/bus.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/cloud.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/cogs.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/motorcycle.png&quot;) &#125;,<br>        &#123; image: @image-url(&quot;icons/video.png&quot;) &#125;,<br>    ];<br><br>    for tile[i] in memory_tiles : MemoryTile &#123;<br>        x: mod(i, 4) * 74px;<br>        y: floor(i / 4) * 74px;<br>        width: 64px;<br>        height: 64px;<br>        icon: tile.image;<br>        open_curtain: tile.image_visible || tile.solved;<br>        // propagate the solved status from the model to the tile<br>        solved: tile.solved;<br>        clicked =&gt; &#123;<br>            tile.image_visible = !tile.image_visible;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java小实验-初步使用Swing</title>
    <link href="/2023/12/18/Java/java-example-4/"/>
    <url>/2023/12/18/Java/java-example-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Java小实验-初步使用Swing"><a href="#Java小实验-初步使用Swing" class="headerlink" title="Java小实验-初步使用Swing"></a>Java小实验-初步使用Swing</h1><p>Swing是Java的GUI工具包，它是Java基础类的一部分。Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。Swing提供许多比AWT更好的屏幕显示元素。它们用纯Java写成，所以同Java本身一样可以跨平台运行，这一点不像AWT。Swing是JFC的一部分。Swing支持可更换的面板和主题，然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用JAVA支持的任意面板。Swing提供了一组丰富的GUI组件，如按钮、文本框、复选框、列表框等，以及容器组件，如面板和框架，用于构建交互式应用程序的用户界面。</p><span id="more"></span><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>1、完成图1显示的窗体。</p><p><img src="/img/java-example-4/demo.png" alt="图1 学生成绩输入窗体"></p><p>2、单击“提交”按钮，会将姓名、Java文本框中的内容写入到scores.txt中，写入形式如下：<br>    王明 95<br>    刘小林 75</p><p>3、单击“重写”按钮，会清空姓名、Java文本框中的内容。</p><p>4、要求必须处理程序中可能出现的所有异常。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.io.BufferedWriter;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个JFrame对象，用于显示窗口</span><br>        <span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;学生成绩输入&quot;</span>);<br>        <span class="hljs-comment">// 设置窗口的大小</span><br>        frame.setSize(<span class="hljs-number">300</span>, <span class="hljs-number">150</span>);<br>        <span class="hljs-comment">// 设置窗口的关闭操作</span><br>        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br><br>        <span class="hljs-comment">// 创建一个JPanel对象，用于添加组件</span><br>        <span class="hljs-type">JPanel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>        <span class="hljs-comment">// 将JPanel对象添加到JFrame对象中</span><br>        frame.add(panel);<br>        <span class="hljs-comment">// 调用placeComponents方法，用于添加组件</span><br>        placeComponents(panel);<br><br>        <span class="hljs-comment">// 设置窗口可见</span><br>        frame.setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">placeComponents</span><span class="hljs-params">(JPanel panel)</span> &#123;<br>        <span class="hljs-comment">// 设置布局管理器</span><br>        panel.setLayout(<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 创建一个JLabel对象，用于显示用户名</span><br>        <span class="hljs-type">JLabel</span> <span class="hljs-variable">userLabel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;用户名:&quot;</span>);<br>        <span class="hljs-comment">// 设置JLabel的位置</span><br>        userLabel.setBounds(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">80</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">// 将JLabel添加到JPanel中</span><br>        panel.add(userLabel);<br><br>        <span class="hljs-comment">// 创建一个JTextField对象，用于显示用户名</span><br>        <span class="hljs-type">JTextField</span> <span class="hljs-variable">userText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextField</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">// 设置JTextField的位置</span><br>        userText.setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>, <span class="hljs-number">165</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">// 将JTextField添加到JPanel中</span><br>        panel.add(userText);<br><br>        <span class="hljs-comment">// 创建一个JLabel对象，用于显示成绩</span><br>        <span class="hljs-type">JLabel</span> <span class="hljs-variable">scoreLabel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JLabel</span>(<span class="hljs-string">&quot;清除:&quot;</span>);<br>        <span class="hljs-comment">// 设置JLabel的位置</span><br>        scoreLabel.setBounds(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">80</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">// 将JLabel添加到JPanel中</span><br>        panel.add(scoreLabel);<br><br>        <span class="hljs-comment">// 创建一个JTextField对象，用于显示成绩</span><br>        <span class="hljs-type">JTextField</span> <span class="hljs-variable">scoreText</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextField</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">// 设置JTextField的位置</span><br>        scoreText.setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">165</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">// 将JTextField添加到JPanel中</span><br>        panel.add(scoreText);<br><br>        <span class="hljs-comment">// 创建一个JButton对象，用于提交数据</span><br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">submitButton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;提交&quot;</span>);<br>        <span class="hljs-comment">// 设置JButton的位置</span><br>        submitButton.setBounds(<span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">// 将JButton添加到JPanel中</span><br>        panel.add(submitButton);<br><br>        <span class="hljs-comment">// 创建一个JButton对象，用于清除输入框中的数据</span><br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">clearButton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;清除&quot;</span>);<br>        <span class="hljs-comment">// 设置JButton的位置</span><br>        clearButton.setBounds(<span class="hljs-number">180</span>, <span class="hljs-number">80</span>, <span class="hljs-number">80</span>, <span class="hljs-number">25</span>);<br>        <span class="hljs-comment">// 将JButton添加到JPanel中</span><br>        panel.add(clearButton);<br><br>        <span class="hljs-comment">// 为提交按钮添加点击事件</span><br>        submitButton.addActionListener(e -&gt; &#123;<br>            <span class="hljs-comment">// 获取输入框中的用户名和成绩</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> userText.getText();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> scoreText.getText();<br><br>            <span class="hljs-comment">// 检查输入框中的数据是否合法</span><br>            <span class="hljs-keyword">if</span> (checkFormat(name, score)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 将用户名和成绩写入文件</span><br>                    writeToFile(name, name);<br>                    <span class="hljs-comment">// 弹出提示框</span><br>                    JOptionPane.showMessageDialog(panel, <span class="hljs-string">&quot;写入成功！&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>                    <span class="hljs-comment">// 弹出提示框</span><br>                    JOptionPane.showMessageDialog(panel, <span class="hljs-string">&quot;写入文件失败！&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 弹出提示框</span><br>                JOptionPane.showMessageDialog(panel, <span class="hljs-string">&quot;用户名或者成绩输入不合法&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 为清除按钮添加点击事件</span><br>        clearButton.addActionListener(e -&gt; &#123;<br>            <span class="hljs-comment">// 将输入框中的数据清空</span><br>            userText.setText(<span class="hljs-string">&quot;&quot;</span>);<br>            scoreText.setText(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkFormat</span><span class="hljs-params">(String username, String score)</span> &#123;<br>        <span class="hljs-comment">// 检查输入框中的数据是否合法</span><br>        <span class="hljs-keyword">if</span>(username.isEmpty() || score.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 检查输入框中的数据是否是数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; score.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (!Character.isDigit(score.charAt(i))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToFile</span><span class="hljs-params">(String username, String score)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 将用户名和成绩写入文件</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fileWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;scores.txt&quot;</span>,<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(fileWriter);<br>        bufferedWriter.append(<span class="hljs-string">&quot;用户名：&quot;</span>).append(username).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        bufferedWriter.append(<span class="hljs-string">&quot;成绩：&quot;</span>).append(score).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        bufferedWriter.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="/img/java-example-4/final1.png" alt="运行结果"></p><p><img src="/img/java-example-4/final2.png" alt="运行结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint C++  开幕动画</title>
    <link href="/2023/12/10/Slint/slint-polish-tile/"/>
    <url>/2023/12/10/Slint/slint-polish-tile/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-C-图片开幕动画"><a href="#Slint-C-图片开幕动画" class="headerlink" title="Slint C++ 图片开幕动画"></a>Slint C++ 图片开幕动画</h1><p>按照小游戏的设定，一开始图片是被挡住的，当鼠标点击了所在图片之后，图片就被掀开。现在我们需要做一个类似开幕的效果，他的实现方式也不是很困难：给这个矩形上面附加两个1&#x2F;2大小的矩形，再叠加一个透明矩形用来接受鼠标事件，当点击之后左边的矩形往左走，右边的矩形往右走，为他们两个顺便加上过度动画效果。</p><span id="more"></span><h2 id="动画设计"><a href="#动画设计" class="headerlink" title="动画设计"></a>动画设计</h2><ul><li>左幕布<ul><li>高度设置为磁贴块的大小</li><li>宽度设置为磁贴块的一半大小</li><li>位置设置在磁贴块的左边</li><li>当点击之后宽度逐渐到0,到0后设置为不可见</li></ul></li><li>右幕布<ul><li>高度设置为磁贴块的大小</li><li>宽度设置为磁贴块的一半大小</li><li>位置设置在磁贴块的右边</li><li>当点击之后宽度逐渐到0,到0后设置为不可见</li></ul></li></ul><h2 id="添加一块幕布"><a href="#添加一块幕布" class="headerlink" title="添加一块幕布"></a>添加一块幕布</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component MemoryTile inherits Rectangle&#123;<br>    width: 64px;<br>    height: 64px;<br>    background: gray;<br><br>    Image &#123;<br>        width: parent.width;<br>        height: parent.height;<br>        source: @image-url(&quot;icons/bus.png&quot;);<br>    &#125;<br><br>    // 左幕布<br>    Rectangle &#123;<br>        width: parent.width / 2;<br>        height: parent.height;<br>        x: 0px;<br>        background: darkgray;<br>    &#125;<br>&#125;<br>export component MainWindow inherits Window &#123;<br>    MemoryTile &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加一块的效果<br><img src="/img/slint-polish-tile/img01.png" alt="添加一块的效果"></p><h2 id="添加两块幕布"><a href="#添加两块幕布" class="headerlink" title="添加两块幕布"></a>添加两块幕布</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component MemoryTile inherits Rectangle&#123;<br>    width: 64px;<br>    height: 64px;<br>    background: gray;<br><br>    Image &#123;<br>        width: parent.width;<br>        height: parent.height;<br>        source: @image-url(&quot;icons/bus.png&quot;);<br>    &#125;<br><br>    // 左幕布<br>    Rectangle &#123;<br>        width: parent.width / 2;<br>        height: parent.height;<br>        x: 0px;<br>        background: darkgray;<br>    &#125;<br><br>    // 右幕布<br>    Rectangle &#123;<br>        width: parent.width / 2;<br>        height: parent.height;<br>        x: parent.width / 2;<br>        background: darkgray;<br>    &#125;<br>&#125;<br>export component MainWindow inherits Window &#123;<br>    MemoryTile &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>定义了一个名为<code>MemoryTile</code>的组件，以及一个名为<code>MainWindow</code>的窗口组件。<code>MemoryTile</code>组件继承自<code>Rectangle</code>，具有以下属性和回调函数：</p><ol><li><code>callback clicked</code>：定义了一个名为<code>clicked</code>的回调函数。</li><li><code>in property &lt;bool&gt; open_curtain</code>：定义了一个名为<code>open_curtain</code>的属性，类型为布尔值，表示幕布的打开状态。</li><li><code>in property &lt;bool&gt; solved</code>：定义了一个名为<code>solved</code>的属性，类型为布尔值，表示组件的状态。</li><li><code>in property &lt;image&gt; icon</code>：定义了一个名为<code>icon</code>的属性，类型为图像，表示组件的图标。</li></ol><p>组件的宽度和高度分别为64像素，背景颜色根据<code>solved</code>属性的值来决定，如果是<code>solved</code>则为深灰色，否则为灰色。</p><p>接下来，代码定义了一个名为<code>animate</code>的动画属性，用于改变组件的背景颜色。动画的持续时间为800毫秒，使用<code>ease-in</code>ease-in&#96; easing函数。</p><p>然后，代码定义了一个名为<code>Image</code>的子组件，其宽度、高度和源图像都来自父组件的<code>icon</code>属性。</p><p>接下来，代码定义了两个名为<code>Rectangle</code>的子组件，分别表示左幕布和右幕布。左幕布的宽度根据<code>open_curtain</code>属性的值来决定，如果是<code>open_curtain</code>则为0像素，否则为父组件宽度的一半。背景颜色为深灰色。当<code>open_curtain</code>属性改变时，宽度会通过动画进行更新。</p><p>右幕布的宽度、高度和背景颜色与左幕布相同。此外，当<code>open_curtain</code>属性改变时，还会通过动画更新位置和宽度。</p><p>最后，代码定义了一个名为<code>TouchArea</code>的子组件，当用户点击时，会调用父组件的<code>clicked</code>回调函数。</p><p>最后，代码导出了<code>MainWindow</code>组件，并在其中定义了一个<code>MemoryTile</code>组件，其<code>icon</code>属性为<code>icons/bus.png</code>，当点击时会改变<code>open_curtain</code>属性的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Slint">component MemoryTile inherits Rectangle&#123;<br>    callback clicked;<br>    in property &lt;bool&gt; open_curtain;<br>    in property &lt;bool&gt; solved;<br>    in property &lt;image&gt; icon;<br><br>    width: 64px;<br>    height: 64px;<br>    background: solved? darkgrey : grey;<br><br>    animate background &#123;<br>         duration: 800ms;<br>    &#125;<br><br>    Image &#123;<br>        width: parent.width;<br>        height: parent.height;<br>        source: icon;<br>    &#125;<br><br>    // 左幕布<br>    Rectangle &#123;<br>        width: open_curtain ? 0px : (parent.width / 2);<br>        height: parent.height;<br>        x: 0px;<br>        background: darkgrey;<br>        animate width &#123;<br>             duration: 250ms;<br>             easing: ease-in;<br>        &#125;<br>    &#125;<br><br>    // 右幕布<br>    Rectangle &#123;<br>        width: open_curtain ? 0px : (parent.width / 2);<br>        height: parent.height;<br>        x: open_curtain ? parent.width : (parent.width / 2);<br>        background: darkgrey;<br>        animate width &#123;<br>            duration: 250ms;<br>            easing: ease-in;<br>       &#125;<br>       animate x &#123;<br>            duration: 250ms;<br>            easing: ease-in;<br>       &#125;<br>    &#125;<br><br>    TouchArea &#123;<br>        clicked =&gt; &#123;<br>            root.clicked();<br>        &#125;<br>    &#125;<br>&#125;<br>export component MainWindow inherits Window &#123;<br>    MemoryTile &#123;<br>        icon: @image-url(&quot;icons/bus.png&quot;);<br>        clicked =&gt; &#123;<br>            self.open-curtain = !self.open-curtain;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint C++  画一个矩形</title>
    <link href="/2023/12/10/Slint/slint-rectangle/"/>
    <url>/2023/12/10/Slint/slint-rectangle/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-C-画一个矩形"><a href="#Slint-C-画一个矩形" class="headerlink" title="Slint C++ 画一个矩形"></a>Slint C++ 画一个矩形</h1><p>官方在教程中给的一个案例是记忆磁贴，也就是一组图片里选择两个相同图案的消除。这个是官方给的<a href="https://slint.dev/blog/memory-game-tutorial/memory_clip.mp4">demo</a><br>现在我们已经有了一个窗口，接下来就是研究一下怎么画一个矩形然后在里面塞一个图片。</p><p>打开熟悉的memory.slint</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs slint">component MemoryTile inherits Rectangle&#123;<br>    width: 64px;<br>    height: 64px;<br>    background: gray;<br>&#125;<br>export component MainWindow inherits Window &#123;<br>    MemoryTile &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在这里创建了一个叫做<code>MemoryTile</code>的组件，他继承了<code>Rectangle</code>，在其中我们设置了宽度、高度、背景颜色，和QML不同的是：.slint语言中的长度有一个单位，这里是px后缀。这使得代码更容易阅读，编译器可以检测到何时意外地将值与附加的不同单元混合在一起。<br><img src="/img/slint-rectangle/img01.png" alt="运行效果"></p><p>请注意，我们导出MainWindow组件。这是必要的，以便我们以后可以从业务逻辑中访问它。</p><p>接下来就是往里面塞图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs slint">component MemoryTile inherits Rectangle&#123;<br>    width: 64px;<br>    height: 64px;<br>    background: gray;<br><br>    Image &#123;<br>        width: parent.width;<br>        height: parent.height;<br>        source: @image-url(&quot;icons/bus.png&quot;);<br>    &#125;<br>&#125;<br>export component MainWindow inherits Window &#123;<br>    MemoryTile &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在矩形中，我们放置了一个Image元素，该元素使用@Image-url（）宏加载一个图标。该路径是相对于memory.slint所在的文件夹的。这个图标和我们稍后要使用的其他图标需要先安装。图片素材可以自己做一套也可以直接下载 <a href="https://slint.dev/blog/memory-game-tutorial/icons.zip">Zip archive</a><br><img src="/img/slint-rectangle/img02.png" alt="贴图片的效果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slint C++  环境配置</title>
    <link href="/2023/12/09/Slint/slint-hello/"/>
    <url>/2023/12/09/Slint/slint-hello/</url>
    
    <content type="html"><![CDATA[<h1 id="Slint-C-环境配置"><a href="#Slint-C-环境配置" class="headerlink" title="Slint C++ 环境配置"></a>Slint C++ 环境配置</h1><h2 id="准备部分"><a href="#准备部分" class="headerlink" title="准备部分"></a>准备部分</h2><p><code>Slint</code> 支持使用<code>C++</code>,<code>Rust</code>,<code>JavaScript</code>进行开发。使用C++进行开发需要准备如下环境：</p><ul><li>C++ &gt;&#x3D; 20</li><li>CMake &gt;&#x3D; 3.21</li><li>Ninja<br>实际上Slint的实现库使用的语言是Rust， 简单的可以理解在C++中使用Slint时，会将Rust代码编译成为C++可以调用的库。<code>.slint</code>文件也会编译成为C++头文件以供调用。来看一下原文：<blockquote><p>我们还没有提供Slint的二进制文件，所以我们将使用CMake集成，它将自动从源代码构建工具和库。由于它是用Rust编程语言实现的，这意味着您还需要安装Rust编译器（1.70或更新版本）。您可以按照Rust网站上的说明轻松安装Rust编译器。我们将使用cmake的内置FetchContent模块来获取Slint的源代码。</p></blockquote></li></ul><p>上一个初始使用到的<code>CMakeLists.txt</code>文件，一定要记得安装Rust并且还拥有git</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># CMakeLists.txt</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.21</span>)<br><span class="hljs-keyword">project</span>(memory LANGUAGES CXX)<br><br><span class="hljs-keyword">include</span>(FetchContent)<br>FetchContent_Declare(<br>    Slint<br>    GIT_REPOSITORY https://github.com/slint-ui/slint.git<br>    <span class="hljs-comment"># `release/1` will auto-upgrade to the latest Slint &gt;= 1.0.0 and &lt; 2.0.0</span><br>    <span class="hljs-comment"># `release/1.0` will auto-upgrade to the latest Slint &gt;= 1.0.0 and &lt; 1.1.0</span><br>    GIT_TAG release/<span class="hljs-number">1</span><br>    SOURCE_SUBDIR api/cpp<br>)<br>FetchContent_MakeAvailable(Slint)<br><br><span class="hljs-keyword">add_executable</span>(memory_game main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(memory_game PRIVATE Slint::Slint)<br>slint_target_sources(memory_game memory.slint)<br><span class="hljs-comment"># On Windows, copy the Slint DLL next to the application binary so that it&#x27;s found.</span><br><span class="hljs-keyword">if</span> (WIN32)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> memory_game POST_BUILD <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy $&lt;TARGET_RUNTIME_DLLS:memory_game&gt; $&lt;TARGET_FILE_DIR:memory_game&gt; COMMAND_EXPAND_LISTS)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>在第一次配置CMake的时候会自动下载并编译Slint的Rust库。可以在cmake build 文件夹中看到:<br><img src="/img/slint-hello/img01.png" alt="img01"></p><p>在加载CMakeLists.txt中前几次可能出现加载失败的情况，在信息中可以找到下面几行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[cmake]</span> 正克隆到 <span class="hljs-string">&#x27;slint-src&#x27;</span>...<br><span class="hljs-selector-attr">[cmake]</span> 致命错误：在 <span class="hljs-string">&#x27;/mnt/Workspace/CLang/Slint/HelloWorld/build/_deps/slint-src&#x27;</span> 检测到可疑的仓库所有权<br><span class="hljs-selector-attr">[cmake]</span> 要为本仓库创建特例，请运行：<br><span class="hljs-selector-attr">[cmake]</span> <br><span class="hljs-selector-attr">[cmake]</span> git config <span class="hljs-attr">--global</span> <span class="hljs-attr">--add</span> safe<span class="hljs-selector-class">.directory</span> /mnt/Workspace/CLang/Slint/HelloWorld/build/_deps/slint-<span class="hljs-attribute">src</span><br><span class="hljs-selector-attr">[cmake]</span> CMake Error at slint-subbuild/slint-populate-prefix/tmp/slint-populate-gitclone<span class="hljs-selector-class">.cmake</span>:<span class="hljs-number">49</span> (message):<br><span class="hljs-selector-attr">[cmake]</span>   Failed to checkout tag: <span class="hljs-string">&#x27;release/1&#x27;</span><br></code></pre></td></tr></table></figure><p>然后我们从善如流，将这条指令敲一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git config --global --add safe.directory /mnt/Workspace/CLang/Slint/HelloWorld/build/_deps/slint-src<br><br>git config --global --add safe.directory /mnt/Workspace/CLang/Slint/HelloWorld/build/_deps/corrosion-src<br></code></pre></td></tr></table></figure><p>然后就可以喝杯<code>java</code>等待一下了</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>熟悉CMake的人应该对此很熟悉。我们看到这个CMakeLists.txt引用了一个main.cpp，我们稍后会添加它，它还有一行slint_target_sources（memory_game memory.slint），这是一个slint函数，用于将memory.slinnt文件添加到目标。然后，我们必须在同一目录中创建memory.slint文件。现在让我们用一个你好的世界来填充它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Slint">// memory.slint<br>export component MainWindow inherits Window &#123;<br>    Text &#123;<br>        text: &quot;hello world&quot;;<br>        color: green;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个名为MainWindow的组件，它继承自Window组件。下面是代码的逐行解释：</p><ol><li><code>export component MainWindow inherits Window &#123;</code>：这行代码定义了一个名为MainWindow的组件，它继承自Window组件。Slint是一种JavaScript静态代码检查工具，它可以帮助你发现代码中的错误和问题。</li><li><code>Text &#123;</code>：这行代码定义了一个名为Text的子组件。子组件通常包含在父组件中使用的UI元素。</li><li><code>text: &quot;hello world&quot;</code>：这行代码定义了Text组件的text属性，其值为”hello world”。</li><li><code>color: green</code>：这行代码定义了Text组件的color属性，其值为”green”。</li></ol><p>这个看上去有一种QML的味道，但是实际上又不太一样，不过QML也是通过编译成为头文件提供给C++使用的，所以猜猜接下来需要配置什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// main.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memory.h&quot;</span> <span class="hljs-comment">// generated header from memory.slint</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> main_window = MainWindow::<span class="hljs-built_in">create</span>();<br>    main_window-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>nice,就是这样，激动的心颤抖的手，来让我们运行一下，第一次运行可能时间有点久，但都是值得的，可以顺便起来喝口水。</p><p><img src="/img/slint-hello/img02.png" alt="最终结果"><br>由于本人写这篇文章的时候使用的桌面环境是 plasma kde - wayland 设置的主题是暗色的所以组件跟随提供主题是黑色的。但是这都不要紧，随后的文章中会介绍怎么做统一的主题风格。</p><p><img src="/img/slint-hello/img03.png" alt="白色主题"><br><em>写完这条post之后，感觉还是要交代以下输出来的东西具体长什么样子，于是在次日启动了我的wayfire桌面，这个桌面使用的是亮色主题，所以达到了官方的效果</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Slint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java初步了解一下数组</title>
    <link href="/2023/12/07/Java/java-learn-array/"/>
    <url>/2023/12/07/Java/java-learn-array/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-初步了解一下数组"><a href="#Java-初步了解一下数组" class="headerlink" title="Java - 初步了解一下数组"></a>Java - 初步了解一下数组</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>编程练习1：<br><strong>定义一个OneDimArray类，其中共有7个成员方法。其中：</strong></p><ol><li>方法一，为创建一个10个整数元素的数组，元素值为0~99之间的随机值，并返回该数组，</li><li>方法二，对形参表中中的数组进行备份，对其副本进行排序（参考教材中的冒泡排序方法），返回排序后的数组</li><li>方法三，求形参表中数组的最大值，并返回最大值</li><li>方法四，求形参表中数组的最小值,并返回最小值</li><li>方法五，求形参表中数组的元素的平均值，并返回平均值</li><li>方法六，对形参表中数组的元素进行打印。</li><li>主方法中创建OneDimArray的对象，依次调用上述方法一~六来产生数组，并进行相关值的计算和打印。</li></ol><p>编程练习2：<br><strong>定义一个TwoDimArray类，其中共有2个成员方法。包含：</strong></p><ol><li>方法一，创建并返回一个10*10的二维数组，数组中的元素值为 10到50之间的随机值；</li><li>方法二, 打印二维数组的值，并按数组的行，进行分行打印。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// App.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">oneDimArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneDimArray</span>();<br>        <span class="hljs-type">var</span> <span class="hljs-variable">oneArray</span> <span class="hljs-operator">=</span> oneDimArray.createArray();<br>        oneDimArray.printArray(oneArray);<br>        oneDimArray.printArray(oneDimArray.sortArray(oneArray));<br>        System.out.println(<span class="hljs-string">&quot;The max value of element is &quot;</span> + oneDimArray.getMax(oneArray).intValue());<br>        System.out.println(<span class="hljs-string">&quot;The min value of element is &quot;</span> + oneDimArray.getMin(oneArray).intValue());<br>        System.out.println(<span class="hljs-string">&quot;The average value in this array: &quot;</span> + oneDimArray.getAverage(oneArray).intValue());<br><br>        <span class="hljs-type">var</span> <span class="hljs-variable">twoDimArray</span> <span class="hljs-operator">=</span> TwoDimArray.createArray();<br>        TwoDimArray.printArray(twoDimArray);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// OneDimArray.Java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OneDimArray</span> &#123;<br>    <span class="hljs-keyword">public</span> Integer[] createArray() &#123;<br>        Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            array[i] = (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer[] sortArray(Integer[] array) &#123;<br>        Integer[] arrayCopy = array.clone();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayCopy.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arrayCopy.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arrayCopy[j] &gt; arrayCopy[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arrayCopy[j];<br>                    arrayCopy[j] = arrayCopy[j + <span class="hljs-number">1</span>];<br>                    arrayCopy[j + <span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrayCopy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getMax</span><span class="hljs-params">(Integer[] array)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (array[i] &gt; max) &#123;<br>                max = array[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getMin</span><span class="hljs-params">(Integer[] array)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (array[i] &lt; min) &#123;<br>                min = array[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAverage</span><span class="hljs-params">(Integer[] array)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            sum += array[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum / array.length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(Integer[] array)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            System.out.print(array[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// TwoDimArray.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoDimArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer[][] createArray() &#123;<br>        Integer[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array[i].length; j++) &#123;<br>                array[i][j] = (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">50</span> + <span class="hljs-number">10</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(Integer[][] array)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;Line:&quot;</span> + i + <span class="hljs-string">&quot;\t&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array[i].length; j++) &#123;<br>                System.out.print(array[i][j] + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云OSS C++ SDK CURLINFO_CONTENT_LENGTH_DOWNLOAD’ is deprecated</title>
    <link href="/2023/12/04/Cpp/cpp-oss-compile/"/>
    <url>/2023/12/04/Cpp/cpp-oss-compile/</url>
    
    <content type="html"><![CDATA[<h1 id="编译阿里云OSS-C-SDK-出现-错误：‘CURLINFO-CONTENT-LENGTH-DOWNLOAD’-is-deprecated-…"><a href="#编译阿里云OSS-C-SDK-出现-错误：‘CURLINFO-CONTENT-LENGTH-DOWNLOAD’-is-deprecated-…" class="headerlink" title="编译阿里云OSS C++ SDK 出现 错误：‘CURLINFO_CONTENT_LENGTH_DOWNLOAD’ is deprecated:…"></a>编译阿里云OSS C++ SDK 出现 错误：‘CURLINFO_CONTENT_LENGTH_DOWNLOAD’ is deprecated:…</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Text">[25/204] Building CXX object sdk/CMakeFiles/cpp-sdk.dir/src/http/CurlHttpClient.cc.o<br>FAILED: sdk/CMakeFiles/cpp-sdk.dir/src/http/CurlHttpClient.cc.o <br>/usr/bin/c++ -DPLATFORM_LINUX -I/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/include -I/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/include/alibabacloud/oss -I/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/src/external -std=c++11 -fno-exceptions -fPIC -Wall -Werror -pedantic -Wextra -MD -MT sdk/CMakeFiles/cpp-sdk.dir/src/http/CurlHttpClient.cc.o -MF sdk/CMakeFiles/cpp-sdk.dir/src/http/CurlHttpClient.cc.o.d -o sdk/CMakeFiles/cpp-sdk.dir/src/http/CurlHttpClient.cc.o -c &#x27;/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/src/http/CurlHttpClient.cc&#x27;<br>In file included from /home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/src/http/CurlHttpClient.cc:18:<br>/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/src/http/CurlHttpClient.cc: In function ‘size_t AlibabaCloud::OSS::recvHeaders(char*, size_t, size_t, void*)’:<br>/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/src/http/CurlHttpClient.cc:325:48: 错误：‘CURLINFO_CONTENT_LENGTH_DOWNLOAD’ is deprecated: since 7.55.0. Use CURLINFO_CONTENT_LENGTH_DOWNLOAD_T [-Werror=deprecated-declarations]<br>  325 |                 curl_easy_getinfo(state-&gt;curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &amp;dval);<br>      |                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>/usr/include/curl/curl.h:2883:3: 附注：在此声明<br> 2883 |   CURLINFO_CONTENT_LENGTH_DOWNLOAD<br>      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/src/http/CurlHttpClient.cc: In member function ‘virtual std::shared_ptr&lt;AlibabaCloud::OSS::HttpResponse&gt; AlibabaCloud::OSS::CurlHttpClient::makeRequest(const std::shared_ptr&lt;AlibabaCloud::OSS::HttpRequest&gt;&amp;)’:<br>/home/cvrain/下载/aliyun-oss-cpp-sdk/sdk/src/http/CurlHttpClient.cc:550:28: 错误：‘CURLOPT_PROGRESSFUNCTION’ is deprecated: since 7.32.0. Use CURLOPT_XFERINFOFUNCTION [-Werror=deprecated-declarations]<br>  550 |     curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progressCallback);<br>      |                            ^~~~~~~~~~~~~~~~~~~~~~~~<br>/usr/include/curl/curl.h:1299:3: 附注：在此声明<br> 1299 |   CURLOPTDEPRECATED(CURLOPT_PROGRESSFUNCTION, CURLOPTTYPE_FUNCTIONPOINT, 56,<br>      |   ^~~~~~~~~~~~~~~~~<br>cc1plus：所有的警告都被当作是错误<br>[38/204] Building CXX object sdk/CMakeFiles/cpp-sdk.dir/src/encryption/OssEncryptionClient.cc.o<br>ninja: build stopped: subcommand failed.<br>❯ <br></code></pre></td></tr></table></figure><p>这个问题是因为<code>curl</code>在7.55 废弃了<code>CURLINFO_CONTENT_LENGTH_DOWNLOAD</code><br>在7.32废弃了<code>CURLOPT_PROGRESSFUNCTION</code><br>存在两种修复方式，第二种是修改源代码使用现在支持的方式，这个比较麻烦。第一种方式是添加<code>flags</code>使其忽略此警告。<br>在<code>CMakeLists.txt</code>中添加如下代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(CMAKE_C_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-deprecated-declarations&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wno-deprecated-declarations&quot;</span>)<br></code></pre></td></tr></table></figure><p>完整的CMakeLists.txt</p><pre><code class="CMake">## Copyright 2009-2017 Alibaba Cloud All rights reserved.# # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at# #      http://www.apache.org/licenses/LICENSE-2.0# # Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.#cmake_minimum_required(VERSION 3.1)cmake_policy(SET CMP0048 NEW)set_property(GLOBAL PROPERTY USE_FOLDERS ON)set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Wno-deprecated-declarations&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wno-deprecated-declarations&quot;)#Project settingfile(STRINGS &quot;VERSION&quot; version)project(alibabacloud-oss-cpp-sdk VERSION $&#123;version&#125;)message(STATUS &quot;Project version: $&#123;PROJECT_VERSION&#125;&quot;)set(SDK_ROOT &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)set(TARGET_OUTPUT_NAME_PREFIX &quot;alibabacloud-oss-&quot; CACHE STRING &quot;The target&#39;s output name prefix&quot;)#Optionsoption(BUILD_SHARED_LIBS  &quot;Enable shared library&quot; OFF)option(BUILD_SAMPLE &quot;Build sample&quot; ON)option(BUILD_TESTS &quot;Build unit and perfermence tests&quot; OFF)option(ENABLE_COVERAGE &quot;Flag to enable/disable building code with -fprofile-arcs and -ftest-coverage. Gcc only&quot; OFF)option(ENABLE_RTTI &quot;Flag to enable/disable building code with RTTI information&quot; ON)#Platformif (CMAKE_CROSSCOMPILING)    if ($&#123;CMAKE_SYSTEM_NAME&#125; STREQUAL &quot;Android&quot;)        set(PLATFORM_ANDROID 1)        set(TARGET_OS &quot;ANDROID&quot;)    else()        message(FATAL_ERROR &quot;Do not support target platform&quot;)    endif()else()    if(CMAKE_HOST_APPLE)        set(PLATFORM_APPLE 1)        set(TARGET_OS &quot;APPLE&quot;)    elseif(CMAKE_HOST_UNIX)        set(PLATFORM_LINUX 1)        set(TARGET_OS &quot;LINUX&quot;)    elseif(CMAKE_HOST_WIN32)        set(PLATFORM_WINDOWS 1)        set(TARGET_OS &quot;WINDOWS&quot;)    else()        message(FATAL_ERROR &quot;Do not support unknown host OS&quot;)    endif()endif()message(STATUS &quot;TARGET_OS: $&#123;TARGET_OS&#125;&quot;)add_definitions(-DPLATFORM_$&#123;TARGET_OS&#125;)#Find dependency Library, curl, opensslif ($&#123;TARGET_OS&#125; STREQUAL &quot;WINDOWS&quot;)    set(WLIB_TARGET &quot;Win32&quot;)    if (CMAKE_CL_64)    set(WLIB_TARGET &quot;x64&quot;)    endif()    set(CRYPTO_LIBS         $&#123;CMAKE_SOURCE_DIR&#125;/third_party/lib/$&#123;WLIB_TARGET&#125;/ssleay32.lib         $&#123;CMAKE_SOURCE_DIR&#125;/third_party/lib/$&#123;WLIB_TARGET&#125;/libeay32.lib)    set(CRYPTO_INCLUDE_DIRS         $&#123;CMAKE_SOURCE_DIR&#125;/third_party/include)     set(CLIENT_LIBS         $&#123;CMAKE_SOURCE_DIR&#125;/third_party/lib/$&#123;WLIB_TARGET&#125;/libcurl.lib)     set(CLIENT_INCLUDE_DIRS         $&#123;CMAKE_SOURCE_DIR&#125;/third_party/include) else()    include(FindCURL)    include(FindOpenSSL)    if(NOT CURL_FOUND)        message(FATAL_ERROR &quot;Could not find curl&quot;)    endif()    if(NOT OPENSSL_FOUND)        message(FATAL_ERROR &quot;Could not find openssl&quot;)    endif()    set(CRYPTO_LIBS $&#123;OPENSSL_LIBRARIES&#125;)    set(CRYPTO_INCLUDE_DIRS $&#123;OPENSSL_INCLUDE_DIR&#125;)     set(CRYPTO_LIBS_ABSTRACT_NAME crypto ssl)    set(CLIENT_LIBS $&#123;CURL_LIBRARIES&#125;)    set(CLIENT_INCLUDE_DIRS $&#123;CURL_INCLUDE_DIRS&#125;)     set(CLIENT_LIBS_ABSTRACT_NAME curl)endif()#Compiler flagslist(APPEND SDK_COMPILER_FLAGS &quot;-std=c++11&quot;)if(CMAKE_CXX_COMPILER_ID MATCHES &quot;MSVC&quot;)    list(APPEND SDK_COMPILER_FLAGS &quot;/MP&quot;)    if (NOT ENABLE_RTTI)    list(APPEND SDK_COMPILER_FLAGS &quot;/GR-&quot;)    endif()elseif (CMAKE_CXX_COMPILER_ID MATCHES &quot;Clang&quot;)    list(APPEND SDK_COMPILER_FLAGS &quot;-fno-exceptions&quot; &quot;-fPIC&quot;)    if (NOT ENABLE_RTTI)    list(APPEND SDK_COMPILER_FLAGS &quot;-fno-rtti&quot;)    endif()        list(APPEND SDK_COMPILER_FLAGS &quot;-Wall&quot; &quot;-Werror&quot; &quot;-pedantic&quot; &quot;-Wextra&quot;)else()    list(APPEND SDK_COMPILER_FLAGS &quot;-fno-exceptions&quot; &quot;-fPIC&quot;)    if (NOT ENABLE_RTTI)    list(APPEND SDK_COMPILER_FLAGS &quot;-fno-rtti&quot;)    endif()        list(APPEND SDK_COMPILER_FLAGS &quot;-Wall&quot; &quot;-Werror&quot; &quot;-pedantic&quot; &quot;-Wextra&quot;)        if (ENABLE_COVERAGE)    SET(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -fprofile-arcs -ftest-coverage&quot;)    SET(CMAKE_C_FLAGS_DEBUG &quot;$&#123;CMAKE_C_FLAGS_DEBUG&#125; -fprofile-arcs -ftest-coverage&quot;)    SET(CMAKE_EXE_LINKER_FLAGS_DEBUG &quot;$&#123;CMAKE_EXE_LINKER_FLAGS_DEBUG&#125; -fprofile-arcs -ftest-coverage&quot;)    endif()endif()if (BUILD_SHARED_LIBS)    set(STATIC_LIB_SUFFIX &quot;-static&quot;)else()    set(STATIC_LIB_SUFFIX &quot;&quot;)endif()include(ExternalProject)include(GNUInstallDirs)add_subdirectory(sdk)if(BUILD_SAMPLE)    add_subdirectory(sample)endif()if(BUILD_TESTS)    add_subdirectory(test)    add_subdirectory(ptest)endif()```s</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Cmake 腾讯云COS  SDK 编译失败问题</title>
    <link href="/2023/12/03/Cpp/cpp-cos-compile/"/>
    <url>/2023/12/03/Cpp/cpp-cos-compile/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Cmake-腾讯云COS-SDK-编译失败问题"><a href="#解决-Cmake-腾讯云COS-SDK-编译失败问题" class="headerlink" title="解决 Cmake 腾讯云COS  SDK 编译失败问题"></a>解决 Cmake 腾讯云COS  SDK 编译失败问题</h1><p>对象存储 COS 的 XML C++ SDK 源码下载地址： </p><ul><li>Linux 版本&#x2F;Windows 版本&#x2F;macOS 版本： <a href="https://github.com/tencentyun/cos-cpp-sdk-v5" title="https://github.com/tencentyun/cos-cpp-sdk-v5">XML Linux C++ SDK</a>。</li><li>SDK 快速下载地址：<a href="https://cos-sdk-archive-1253960454.file.myqcloud.com/cos-cpp-sdk-v5/latest/cos-cpp-sdk-v5.zip" title="https://cos-sdk-archive-1253960454.file.myqcloud.com/cos-cpp-sdk-v5/latest/cos-cpp-sdk-v5.zip">XML C++ SDK</a>。</li><li>示例 Demo 下载地址：<a href="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/demo/cos_demo.cpp" title="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/demo/cos_demo.cpp">COS XML C++ SDK 示例</a>。</li><li>SDK 更新日志请参见 <a href="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/CHANGELOG.md" title="https://github.com/tencentyun/cos-cpp-sdk-v5/blob/master/CHANGELOG.md">ChangeLog</a>。</li></ul><p>如果用比较漂亮的语言来描述腾讯云cos-cpp-sdk，我觉得可以说是站在巨人肩膀上的健将，结构设计的还是比较漂亮的。 不过仍然存在一些小问题，这里进行一点小小的调整。</p><h2 id="uint64-t-不是一个类型名"><a href="#uint64-t-不是一个类型名" class="headerlink" title="uint64_t 不是一个类型名"></a><code>uint64_t</code> 不是一个类型名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Bash">/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:82:3: 错误：‘uint64_t’不是一个类型名<br>   82 |   uint64_t GetRealByte() const &#123; <span class="hljs-built_in">return</span> m_real_byte; &#125;<br>      |   ^~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:14:1: 附注：‘uint64_t’ is defined <span class="hljs-keyword">in</span> header ‘&lt;cstdint&gt;’; did you forget to ‘<span class="hljs-comment">#include &lt;cstdint&gt;’?</span><br>   13 | <span class="hljs-comment">#include &lt;string&gt;</span><br>  +++ |+<span class="hljs-comment">#include &lt;cstdint&gt;</span><br>   14 | <br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:98:20: 错误：‘uint64_t’未声明<br>   98 |   void SetRealByte(uint64_t real_byte) &#123; m_real_byte = real_byte; &#125;<br>      |                    ^~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:118:3: 错误：‘uint64_t’不是一个类型名<br>  118 |   uint64_t m_real_byte;<br>      |   ^~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:118:3: 附注：‘uint64_t’ is defined <span class="hljs-keyword">in</span> header ‘&lt;cstdint&gt;’; did you forget to ‘<span class="hljs-comment">#include &lt;cstdint&gt;’?</span><br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h: In copy constructor ‘qcloud_cos::CosResult::CosResult(const qcloud_cos::CosResult&amp;)’:<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:40:5: 错误：‘m_real_byte’在此作用域中尚未声明<br>   40 |     m_real_byte = other.m_real_byte;<br>      |     ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:40:25: 错误：‘const class qcloud_cos::CosResult’ has no member named ‘m_real_byte’<br>   40 |     m_real_byte = other.m_real_byte;<br>      |                         ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h: In member <span class="hljs-keyword">function</span> ‘qcloud_cos::CosResult&amp; qcloud_cos::CosResult::operator=(const qcloud_cos::CosResult&amp;)’:<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:52:7: 错误：‘m_real_byte’在此作用域中尚未声明<br>   52 |       m_real_byte = other.m_real_byte;<br>      |       ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:52:27: 错误：‘const class qcloud_cos::CosResult’ has no member named ‘m_real_byte’<br>   52 |       m_real_byte = other.m_real_byte;<br>      |                           ^~~~~~~~~~~<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h: In member <span class="hljs-keyword">function</span> ‘void qcloud_cos::CosResult::SetRealByte(int)’:<br>/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/include/op/cos_result.h:98:42: 错误：‘m_real_byte’ was not declared <span class="hljs-keyword">in</span> this scope; did you mean ‘real_byte’?<br>   98 |   void SetRealByte(uint64_t real_byte) &#123; m_real_byte = real_byte; &#125;<br>      |                                          ^~~~~~~~~~~<br>      |                                          real_byte<br>make[2]: *** [src/CMakeFiles/cossdk.dir/build.make:149：src/CMakeFiles/cossdk.dir/op/cos_result.cpp.o] 错误 1<br>make[2]: 离开目录“/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/build”<br>make[1]: *** [CMakeFiles/Makefile2:121：src/CMakeFiles/cossdk.dir/all] 错误 2<br>make[1]: 离开目录“/home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/build”<br>make: *** [Makefile:94：all] 错误 2<br><br></code></pre></td></tr></table></figure><p><strong>修复方式</strong></p><ol><li><p>转到 <code>include/op/cos_result.h</code> 添加头文件<code>&lt;cstdint&gt;</code>或者<code>&lt;stdint.h&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>转到<code>include/util/test_utils.h</code> 添加头文件 <code>&lt;cstdint&gt;</code> 或者 &lt;cstdint.h&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> qcloud_cos &#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUtils</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">WriteStringtoFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">const</span> std::string&amp; str)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">WriteRandomDatatoFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file, <span class="hljs-type">unsigned</span> len)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">RemoveFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">GetRandomString</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> size)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcFileMd5</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; file)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcStreamMd5</span><span class="hljs-params">(std::istream&amp; is)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcStringMd5</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">CalcStreamSHA1</span><span class="hljs-params">(std::istream&amp; is)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">GetEnvVar</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; env_var_name)</span></span>;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GetEnvVar TestUtils::GetEnvVar</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileInfo</span> &#123;<br>  std::string m_object_name;<br>  std::string m_local_file;<br>  std::string m_local_file_download;<br>  <span class="hljs-type">uint64_t</span> m_file_size;<br>  <span class="hljs-type">uint64_t</span> m_file_crc64_origin;<br>  std::string m_file_md5_origin;<br>  <span class="hljs-type">int</span> m_op_type;<br>&#125;;<br><br>&#125;  <span class="hljs-comment">// namespace qcloud_cos</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="undefined-referenct-to-‘xxxx-so’"><a href="#undefined-referenct-to-‘xxxx-so’" class="headerlink" title="undefined referenct to ‘xxxx.so’"></a>undefined referenct to ‘xxxx.so’</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `EVP_get_cipherbyname@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoNetSSL.so: undefined reference to `SSL_CTX_flush_sessions@libssl.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `d2i_PKCS12_bio@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoNetSSL.so: undefined reference to `FIPS_mode@libcrypto.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `BN_bn2bin@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `sk_num@libcrypto.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `EVP_BytesToKey@libcrypto.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoCrypto.so: undefined reference to `BIO_new_mem_buf@libcrypto.so.10&#x27;</span><br>/usr/bin/ld: /home/cvrain/下载/cos-cpp-sdk-v5-5.5.10/third_party/lib/linux/poco/libPocoNetSSL.so: undefined reference to `SSL_CTX_use_PrivateKey_file@libssl.so.10<span class="hljs-string">&#x27;</span><br><span class="hljs-string"># 还有一堆 undefined referenct to &#x27;</span>xxxx<span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p><strong>是因为现在的poco库默认已经使用c++14标准库，然而CMakeList.txt中设置仍然是c++11标准，于是修改为C++14</strong></p><p>将-std&#x3D;c11 修改为 -std&#x3D;c14或者17 </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><span class="hljs-keyword">CMAKE_policy</span>(<span class="hljs-keyword">SET</span> CMP0015 NEW)<br><span class="hljs-keyword">project</span>(cos-cpp-sdk)<br><br><span class="hljs-keyword">set</span>(CMAKE_VERBOSE_MAKEFILE  <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><br><span class="hljs-keyword">option</span>(BUILD_UNITTEST <span class="hljs-string">&quot;Build unittest&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span>(BUILD_DEMO <span class="hljs-string">&quot;Build demo&quot;</span> <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">option</span>(BUILD_SHARED_LIB <span class="hljs-string">&quot;Build shared library&quot;</span> <span class="hljs-keyword">OFF</span>)<br><span class="hljs-keyword">option</span>(ENABLE_COVERAGE <span class="hljs-string">&quot;Enable Coverage&quot;</span> <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-keyword">if</span>(APPLE)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;APPLE&quot;</span>)<br><span class="hljs-keyword">elseif</span>(UNIX)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;LINUX&quot;</span>)<br><span class="hljs-keyword">elseif</span>(WIN32)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;unkonwn os type&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;Android&quot;</span>)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;Android&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;SYSTEM_PROCESSOR: $&#123;CMAKE_SYSTEM_PROCESSOR&#125;&quot;</span>)<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;iOS&quot;</span>)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;iOS&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;SYSTEM_PROCESSOR: $&#123;CMAKE_SYSTEM_PROCESSOR&#125;&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;OS type: $&#123;OS_TYPE&#125;&quot;</span>)<br><br><span class="hljs-keyword">set</span>(POCO_INCLUDE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/<span class="hljs-keyword">include</span>/)<br><span class="hljs-keyword">set</span>(POCO_LIBS PocoNetSSL PocoNet PocoCrypto PocoUtil PocoJSON PocoXML PocoFoundation)<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17&quot;</span>)<br>    <span class="hljs-keyword">set</span>(BUILD_TARGET <span class="hljs-string">&quot;Win32&quot;</span>)<br>    <span class="hljs-keyword">if</span> (CMAKE_CL_64)<br>        <span class="hljs-keyword">set</span>(BUILD_TARGET <span class="hljs-string">&quot;x64&quot;</span>)<br>    <span class="hljs-keyword">endif</span>()<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build target: $&#123;BUILD_TARGET&#125;&quot;</span>)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DEFINED</span> <span class="hljs-variable">$&#123;CMAKE_BUILD_TYPE&#125;</span>)<br>        <span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Release&quot;</span>)<br>    <span class="hljs-keyword">endif</span>()<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build type: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)<br><br>    <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;BUILD_TARGET&#125;</span>/poco)<br><br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS <span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-comment">#需要加该参数，不然VS会报错</span><br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; /utf-8&quot;</span>)<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;iOS&quot;</span>)<br>    <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/poco/)<br>    <span class="hljs-keyword">set</span>(OPENSSL_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/openssl/)<br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS stdc++ pthread) <br>    <span class="hljs-keyword">set</span>(OPENSSL_LIBS ssl crypto)<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;Android&quot;</span>)<br>    <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/poco/)<br>    <span class="hljs-keyword">set</span>(OPENSSL_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_NAME&#125;</span>/<span class="hljs-variable">$&#123;CMAKE_SYSTEM_PROCESSOR&#125;</span>/openssl/)<br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS stdc++)<br>    <span class="hljs-keyword">set</span>(OPENSSL_LIBS ssl crypto)<br><span class="hljs-comment"># Linux or MacOs</span><br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;APPLE&quot;</span>)<br>        <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/macOS/poco/)<br>        <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">else</span>()<br>        <span class="hljs-keyword">set</span>(POCO_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/linux/poco/)<br>        <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -Wall -Wextra&quot;</span>)<br>    <span class="hljs-keyword">endif</span>()<br><br>    <span class="hljs-keyword">set</span>(SYSTEM_LIBS stdc++ pthread)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(ENABLE_COVERAGE)<br><span class="hljs-comment"># coverage option</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fprofile-arcs -ftest-coverage&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">add_subdirectory</span>(src)<br><br><span class="hljs-keyword">if</span>(BUILD_UNITTEST)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build unittest&quot;</span>)<br><br>    <span class="hljs-keyword">set</span>(GTEST_INCLUDE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/<span class="hljs-keyword">include</span>/gtest/)<br>    <span class="hljs-keyword">set</span>(GTEST_LINK_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/linux/gtest/)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$&#123;OS_TYPE&#125;</span> <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br>        <span class="hljs-keyword">set</span>(GTEST_LINK_DIR  <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/third_party/lib/<span class="hljs-variable">$&#123;BUILD_TARGET&#125;</span>/gtest)<br>    <span class="hljs-keyword">endif</span>()<br>    <span class="hljs-keyword">set</span>(GTEST_LIBS gtest gtest_main)<br><br>    <span class="hljs-keyword">set</span>(UT_INCLUDE_DIR <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/unittest/<span class="hljs-keyword">include</span>/)<br><br>    <span class="hljs-keyword">add_subdirectory</span>(unittest)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">if</span>(BUILD_DEMO)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build demo&quot;</span>)<br>    <span class="hljs-keyword">add_subdirectory</span>(demo)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p><strong>编译出来的文件存在于 build&#x2F;lib&#x2F;中</strong></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>如果仍然在编译中出现失败的问题，尝试将编译demo选项关闭<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">option</span>(BUILD_UNITTEST <span class="hljs-string">&quot;Build unittest&quot;</span> <span class="hljs-keyword">OFF</span>) <span class="hljs-comment">#配置编译单元测试</span><br><span class="hljs-comment"># option(BUILD_DEMO &quot;Build demo&quot; ON) #配置编译 demo 测试代码</span><br><span class="hljs-keyword">option</span>(BUILD_DEMO <span class="hljs-string">&quot;Build demo&quot;</span> <span class="hljs-keyword">OFF</span>) <span class="hljs-comment">#配置编译 demo 测试代码</span><br><span class="hljs-keyword">option</span>(BUILD_SHARED_LIB <span class="hljs-string">&quot;Build shared library&quot;</span> <span class="hljs-keyword">OFF</span>) <span class="hljs-comment">#配置编译动态库</span><br></code></pre></td></tr></table></figure></li><li>POCO链接问题<ol><li>尝试将源代码中third_party中poco的库替换和当前系统环境一样的库</li><li>重新编译poco代码</li></ol></li><li>小甜品<br>   CMakeLists.txt中的单词还有一个拼错了<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">if</span>(APPLE)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;APPLE&quot;</span>)<br><span class="hljs-keyword">elseif</span>(UNIX)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;LINUX&quot;</span>)<br><span class="hljs-keyword">elseif</span>(WIN32)<br>    <span class="hljs-keyword">set</span>(OS_TYPE <span class="hljs-string">&quot;WINDOWS&quot;</span>)<br><span class="hljs-keyword">else</span>()<br>    <span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;unkonwn os type&quot;</span>) <span class="hljs-comment"># 拼错了</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure></li></ol><h2 id="个人输出"><a href="#个人输出" class="headerlink" title="个人输出"></a>个人输出</h2><p>tmd这个cos sdk真的是依托答辩，用了那么多库，疯狂叠buff, 即使是我使用了vcpkg来配置依赖库仍然麻烦的一批，有一种就是在用poco封装了一层的感觉。里面的详细代码就不评价了。最后奉上我个人测试使用的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.26</span>)<br><span class="hljs-keyword">project</span>(TestCos)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-keyword">find_package</span>(GTest CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(fmt CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(loguru CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(OpenSSL REQUIRED)<br><span class="hljs-keyword">find_package</span>(Poco REQUIRED COMPONENTS Foundation Crypto XML JSON Util Net NetSSL)<br><br><span class="hljs-keyword">set</span>(COS_SDK_H src/cos-cpp-sdk-v5/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;COS_SDK_H&#125;</span>)<br><br><span class="hljs-keyword">if</span> (WIN32)<br>    <span class="hljs-keyword">link_directories</span>(libs/Win32)<br><span class="hljs-keyword">elseif</span> (UNIX)<br>    <span class="hljs-keyword">link_directories</span>(libs/linux)<br><span class="hljs-keyword">elseif</span> (APPLE)<br>    <span class="hljs-keyword">link_directories</span>(libs/macOS)<br><span class="hljs-keyword">else</span> ()<br>    <span class="hljs-keyword">link_directories</span>(libs/x64)<br><br><span class="hljs-keyword">endif</span> ()<br><br><span class="hljs-keyword">set</span>(SRC src/main.cpp)<br><br><span class="hljs-keyword">add_executable</span>(TestCos <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(TestCos PRIVATE fmt::fmt loguru<br>        GTest::gtest GTest::gtest_main GTest::gmock GTest::gmock_main<br>        OpenSSL::SSL OpenSSL::Crypto<br>        Poco::Foundation  Poco::Crypto Poco::XML Poco::JSON Poco::Util Poco::Net Poco::NetSSL<br>        libcossdk.a)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java小实验-封装一个类</title>
    <link href="/2023/11/29/Java/java-example-3/"/>
    <url>/2023/11/29/Java/java-example-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java小实验封装一个类"><a href="#Java小实验封装一个类" class="headerlink" title="Java小实验封装一个类"></a>Java小实验封装一个类</h1><p>设计一个基于控制台的购书系统。该系统主要有以下类完成</p><ol><li><p>设计一个图书类(Book)，该类处于shopping.book包中，该类具有以下成员变量和成员方法。</p><ol><li>成员变量：图书编号(bookid),图书名称(bookname),图书单价(bookprice),库存数量(bookstorage);其中图书单价和库存数量均被private修饰</li><li>成员方法：计算图书折扣率的方法getBookDiscount(),当库存数量&lt;50本时，原有价格打5折；当100&gt;库存数量&#x3D;&gt;50本时，原有价格打6折；当200&gt;库存数量&#x3D;&gt;100本时，原有价格打8折；当库存数量&gt;&#x3D;200时，不打折。</li><li>建议：由于同学们还未接触过数据库和文件存储数据，所以可以在Book类中直接为图书编号、图书名称、库存数量赋初值。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String bookname=<span class="hljs-string">&quot;Java程序设计&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">float</span> bookprice=<span class="hljs-number">28.2f</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookstorage=<span class="hljs-number">150</span>;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>设计一个图书管理类(BookManger),该类处于shopping.manager包中，该类的主要功能是接受控制台中来自用户的输入信息，并进行相应的处理，同时通过不同功能的成员方法将处理结果返回，如能够返回图书编号、价格、折扣价格和共支付总额的信息。建议每一个返回信息均通过不同的方法完成，如可在该类中创建getBookId()的方法，返回图书编号信息，其它依此类推。如当用户在命令行后输入：Java程序设计20BookManger类会将处理结果，图书编号：100123345，价格：28.2元，折扣价：20元，共支付：400元，分别通过getBookId()等4个不同的方法返回对应信息。</p></li><li><p>编写测试类AllUsers，当用户从命令行后输入书名和数量时，会显示该书图书编号、价格，以及用户需要支付的金额。</p><p>运行结果<br><img src="/img/java-example-3/sample.png" alt="运行结果" title="sample.png"></p></li></ol><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p><strong>shopping&#x2F;Manager.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> shopping;<br><br><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Book book;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String bookName, Double bookPrice, Integer bookStorage)</span> &#123;<br>        book = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>        <span class="hljs-type">var</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> Calendar.getInstance().getTimeInMillis();<br>        book.bookId = String.valueOf(date);<br>        book.SetStorage(bookStorage).SetPrice(bookPrice).SetBookName(bookName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">DisplayTotal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;图书编号: %s\t价格： %.2f\t折扣价：%.2f元\t共支付：%.2f元\n&quot;</span>,<br>                book.bookId,<br>                book.GetPrice(),<br>                book.GetBookDiscount(),<br>                book.GetStorage() * book.GetBookDiscount());<br><br>        <span class="hljs-comment">//var result = book.Id + book.GetPrice() + book.GetBookDiscount() +  ...</span><br>        System.out.println(result);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>shopping&#x2F;Book.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> shopping;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;  <br>    <span class="hljs-keyword">public</span> String bookId;  <br>    <span class="hljs-keyword">public</span> String bookName;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> bookPrice;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookStorage;  <br>  <br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">SetPrice</span><span class="hljs-params">(<span class="hljs-type">double</span> price)</span> &#123;  <br>        bookPrice = price;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">SetStorage</span><span class="hljs-params">(<span class="hljs-type">int</span> storage)</span> &#123;  <br>        bookStorage = storage;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">SetBookName</span><span class="hljs-params">(String name)</span> &#123;  <br>        bookName = name;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetPrice</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> bookPrice;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetStorage</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> bookStorage;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetBookDiscount</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (bookStorage &lt; <span class="hljs-number">50</span>) &#123;  <br>            <span class="hljs-keyword">return</span> calcDiscount(<span class="hljs-number">5</span>);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bookStorage &lt; <span class="hljs-number">100</span>) &#123;  <br>            <span class="hljs-keyword">return</span> calcDiscount(<span class="hljs-number">6</span>);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bookStorage &lt; <span class="hljs-number">200</span>) &#123;  <br>            <span class="hljs-keyword">return</span> calcDiscount(<span class="hljs-number">8</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> bookPrice;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calcDiscount</span><span class="hljs-params">(<span class="hljs-type">double</span> rate)</span> &#123;  <br>        <span class="hljs-keyword">return</span> bookStorage * rate * <span class="hljs-number">0.1</span>;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> shopping.Manager;  <br><span class="hljs-keyword">import</span> shopping.Book;  <br><span class="hljs-keyword">import</span> java.util.Scanner;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        Manager manager;  <br>        <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">3</span>) &#123;  <br>            manager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(args[<span class="hljs-number">0</span>], Double.valueOf(args[<span class="hljs-number">1</span>]), Integer.valueOf(args[<span class="hljs-number">2</span>]));  <br>            manager.DisplayTotal();  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">3</span>) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Too few argument, at lest 4&quot;</span>);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Too many argument, 4 arguments at most&quot;</span>);  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;Too many argument, 4 arguments at most&quot;</span>);  <br>        &#125;  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.nextLine();  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> scanner.nextDouble();  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">storage</span> <span class="hljs-operator">=</span> scanner.nextInt();  <br>  <br>        manager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>(name, price, storage);  <br>        manager.DisplayTotal();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>当命令行参数小于4个时，提示警告并且正确执行<br><img src="/img/java-example-3/too-low.jpg" alt="too-low" title="too low"></p><p>当命令行参数大于需要的参数个，系统抛出异常<br><img src="/img/java-example-3/too-many.jpg" alt="too-many" title="too many"></p><p>正常输出<br><img src="/img/java-example-3/standard-out.png" alt="stardand" title="standard-out"></p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nim- 迭代器iterator</title>
    <link href="/2023/11/29/Nim/nim-iterator/"/>
    <url>/2023/11/29/Nim/nim-iterator/</url>
    
    <content type="html"><![CDATA[<h2 id="Nim-迭代器-Iterator"><a href="#Nim-迭代器-Iterator" class="headerlink" title="Nim - 迭代器 Iterator"></a>Nim - 迭代器 Iterator</h2><p>让我们回到之前的示例代码：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;Counting to ten: &quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> countup(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>echo i<br></code></pre></td></tr></table></figure><p>可以编写一个支持此循环的计数过程吗（迭代器计数函数）？咱们试试吧：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> countup(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">var</span> res = a<br>  <span class="hljs-keyword">while</span> res &lt;= b:<br>    <span class="hljs-keyword">return</span> res<br>    inc(res)<br></code></pre></td></tr></table></figure><p>然而这不能工作，这个问题是此过程不仅仅返回最后进行了返回，而且在返回之后继续做了迭代递增的操作（<code>inc(res)</code>）。这个<code>return</code>和<code>continue</code>被称做<code>yield</code>语句。现在我们要做的事情就是用<code>iterator</code>关键字代替<code>proc</code>关键字，这就是我们的第一个迭代器了。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">iterator</span> countup(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">var</span> res = a<br>  <span class="hljs-keyword">while</span> res &lt;= b:<br>    <span class="hljs-keyword">yield</span> res<br>    inc(res)<br></code></pre></td></tr></table></figure><p>迭代器看起来和<code>过程</code>非常相似，但是还是有记得重要的区别的：</p><ul><li>迭代器只能在循环中调用</li><li>迭代器不能包含返回<code>return</code>语句（过程也不能包含<code>yield</code>语句）</li><li>迭代器没有隐式的结果变量。</li><li>迭代器不支持递归。</li><li>迭代器不能前向声明，因为编译器必须能够内联迭代器。(此限制将在编译器的未来版本中删除。)</li></ul><p>但是，你可以使用闭包（匿名）迭代器来获得一组不同的约束，查看 <a href="https://nim-lang.org/docs/manual.html#iterators-and-the-for-statement-firstminusclass-iterators">first-class iterators</a> 获得更多的细节。迭代器可以具有与进程相同的名称和参数，因为本质上它们有自己的名称空间。因此，通常将迭代器包装在同名的进程中，这些进程累积迭代器的结果并将其作为序列返回，就像从<code>structils module</code>中<code>split</code>一样。</p><p>一个简单的例子</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">iterator</span> addOne(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">var</span> res = a<br>  <span class="hljs-keyword">while</span> res &lt;= b:<br>    <span class="hljs-keyword">yield</span> res<br>    inc(res)<br><br><span class="hljs-keyword">iterator</span> reverseOut(a, b: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> =<br>    <span class="hljs-keyword">var</span> res = b<br>    <span class="hljs-keyword">while</span> res &gt;= a:<br>        <span class="hljs-keyword">yield</span> res<br>        dec(res)<br><br><span class="hljs-keyword">when</span> isMainModule:<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> addOne(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    echo i<br><br><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reverseOut(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    echo i<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 链表结构</title>
    <link href="/2023/11/28/DataStructure/c-link-list/"/>
    <url>/2023/11/28/DataStructure/c-link-list/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C-example</tag>
      
      <tag>Data-Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 一些有用的函数</title>
    <link href="/2023/11/28/Haskell/haskell-useful-function/"/>
    <url>/2023/11/28/Haskell/haskell-useful-function/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-函数式程序员工具箱"><a href="#Haskell-函数式程序员工具箱" class="headerlink" title="Haskell - 函数式程序员工具箱"></a>Haskell - 函数式程序员工具箱</h1><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">map</span> :: ( a -&gt; b ) -&gt; [a] -&gt; [b]<br><span class="hljs-title">map</span> _ [] = []<br><span class="hljs-title">map</span> f (x:xs) = f x : map f xs<br></code></pre></td></tr></table></figure><p>接受两个参数，第一个参数是一个函数，第二个参数是一个列表，返回一个函数。看起来就是很简单的工具函数，实际使用中就可以玩出来很多花里胡哨的东西</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">map</span> (+<span class="hljs-number">3</span>) [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>]<br><span class="hljs-title">map</span> (++ <span class="hljs-string">&quot;!&quot;</span>) [<span class="hljs-string">&quot;BIFF&quot;</span>, <span class="hljs-string">&quot;BANG&quot;</span>, <span class="hljs-string">&quot;POW&quot;</span>]<br><span class="hljs-title">map</span> (replicate <span class="hljs-number">3</span>) [<span class="hljs-number">3</span>..<span class="hljs-number">6</span>]<br><span class="hljs-title">map</span> (map (^<span class="hljs-number">2</span>)) [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>取一个谓词和一个列表，返回由列表中所有符合该条件的元素组成的列表。很像C#中的linq （可恶，为什么C++没有linq）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">filter</span> :: (a -&gt; <span class="hljs-type">Bool</span>) -&gt; [a] -&gt; [a]<br><span class="hljs-title">filter</span> _ [] = []<br><span class="hljs-title">filter</span> p (x:xs)<br>| p x       = x : filter p xs<br>| otherwise = filter p xs<br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">filter</span> (&gt;<span class="hljs-number">3</span>) [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-title">filter</span> (==<span class="hljs-number">3</span>) [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-title">filter</span> even [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 一些高级函数</title>
    <link href="/2023/11/27/Haskell/haskell-hyper-function/"/>
    <url>/2023/11/27/Haskell/haskell-hyper-function/</url>
    
    <content type="html"><![CDATA[<h2 id="Haskell-一些高级函数"><a href="#Haskell-一些高级函数" class="headerlink" title="Haskell - 一些高级函数"></a>Haskell - 一些高级函数</h2><p>在haskell中的函数可以将一个函数作为参数传入，也可以返回一个参数。这样的玩法就非常丰富了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a<br><span class="hljs-title">applyTwice</span> f x = f (f x)<br></code></pre></td></tr></table></figure><p>如何使用它</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print $ applyTwice (+<span class="hljs-number">3</span>) <span class="hljs-number">10</span><br>    print $ applyTwice (*<span class="hljs-number">2</span>) <span class="hljs-number">10</span><br>    print $ applyTwice (++ <span class="hljs-string">&quot;lol&quot;</span>) <span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">&gt; 16<br>&gt; 40<br>&gt; <span class="hljs-string">&quot;hellolollol&quot;</span><br></code></pre></td></tr></table></figure><p>定义了一个名为<code>applyTwice</code>的函数，它接受两个参数：一个是要应用两次的函数<code>f</code>，另一个是要应用<code>f</code>的参数<code>x</code>。<code>applyTwice</code>函数的返回值是<code>f</code> applied to <code>f(x)</code>，即<code>f</code> applied twice to <code>x</code>。</p><p>这个函数的实现非常简单，它的表达式式<code>f (f x)</code>表示先对<code>x</code>应用<code>f</code>，然后对结果再应用<code>f</code>。这个表达式的意思是：<code>applyTwice f x</code>等于<code>f</code> applied to <code>f(x)</code>。</p><p>因为这里使用的类型和返回类型都是<code>a</code>， 所以不用在意到底传的是什么类型，也就是什么类型都可以传入进去。比如传入 (+3) 10，首先是括号内部，执行了 10 + 3的操作，得到一个一元函数后再对括号外面的<code>f</code>再进行操作一次，最终得到了结果是16。<br>函数签名也可以理解，先做括号里的a, 这里标明了第一个参数是第一个参数与返回值都是a的函数，第二个参数与返回值的类型也都是a。</p><h2 id="实现zipWith"><a href="#实现zipWith" class="headerlink" title="实现zipWith"></a>实现zipWith</h2><p>为了帮助理解高阶函数，书上给了一个例子，复刻标准库中的zipWith函数。他取一个函数和两个列表作为参数，然后使用两个列表中对应的元素去调用该函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">zipWith&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]<br><span class="hljs-title">zipWith&#x27;</span> _ [] _ = []<br><span class="hljs-title">zipWith&#x27;</span> _ _ [] = []<br><span class="hljs-title">zipWith&#x27;</span> f (x:xs) (y:ys) = f x y: zipWith&#x27; f xs ys<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ zipWith&#x27; (+) [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>    print $ zipWith&#x27; (*) [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>其中，<code>a</code>、<code>b</code>和<code>c</code>是表示输入数据类型的参数，<code>[a]</code>和<code>[b]</code>是表示输入数据的列表，<code>[c]</code>是表示输出数据的列表。</p><p><code>zipWith&#39;</code>函数的实现依赖于一个名为<code>_</code>的匿名函数，它表示一个忽略输入参数的函数。这个匿名函数被传递给<code>zipWith&#39;</code>函数，用于处理输入数据。</p><p><code>zipWith&#39;</code>函数的实现首先检查两个输入列表是否都为空，如果是，则返回一个空列表。接下来，它检查第一个输入列表是否为空，如果是，则返回第二个输入列表的元素组成的列表。然后，它使用给定的函数处理第一个输入列表的第一个元素和第二个输入列表的第一个元素，并将结果添加到输出列表中。最后，它递归地调用<code>zipWith&#39;</code>函数，并将输出列表传递给下一个递归调用。</p><p><code>zipWith&#39;</code>函数的参数分为两部分：</p><ol><li>函数参数：这个参数是一个函数，它定义了如何将两个输入数据（如列表中的元素）组合成输出数据。这个函数的参数有两个，分别是<code>a</code>和<code>b</code>，它们表示输入数据和输出数据的类型。在<code>zipWith&#39;</code>函数中，这个函数被传递给<code>_</code>匿名函数，用于处理输入数据。</li><li>列表参数：这个参数是一个列表，它包含了两个子列表，分别表示输入数据和输出数据。在<code>zipWith&#39;</code>函数中，这两个子列表分别是<code>[a]</code>和<code>[b]</code>，它们表示输入数据的列表和输出数据的列表。在<code>zipWith&#39;</code>函数的实现中，这两个子列表被传递给<code>_</code>匿名函数，用于处理输入数据。</li></ol><p><code>zipWith&#39;</code>函数的签名中的三个参数分别表示输入数据的类型、输入数据的列表和输出数据的列表。在<code>zipWith&#39;</code>函数的实现中，这三个参数被传递给<code>_</code>匿名函数，用于处理输入数据。</p><p>重新来看函数签名<code>zipWith&#39; :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code><br>函数接收了三个参数 <code>( a -&gt; b -&gt; c )</code>、<code>[a]</code>、<code>[b]</code> 结果返回<code>[c]</code><br>前面两个函数没有什么多说的必要，就是如果有一个列表是空的就返回一个空列表，事情到了第三个列表就有意思了起来，f 匹配的是<code>(a -&gt; b -&gt; c)</code>， <code>(x:xs)</code>取了 <code>[a]</code>， <code>(y:ys)</code>取<code>[b]</code>。然后再做了一个递归运算，将列表的每一个元素拿出来，进行函数操作，十分的巧妙。</p><h2 id="实现-flip"><a href="#实现-flip" class="headerlink" title="实现 flip"></a>实现 flip</h2><p>取一个函数作为参数，返回一个效果相同的新参数，两个函数的唯一区别是，新函数的前两个参数的顺序和原来的函数前个参数的顺序正好颠倒。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">flip&#x27;</span> :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)<br><span class="hljs-title">flip&#x27;</span> f = g<br>    <span class="hljs-keyword">where</span> g x y = f y x<br></code></pre></td></tr></table></figure><p>这个函数 <code>flip&#39;</code> 接受一个二元函数 <code>f</code> 作为参数，并返回一个新的二元函数 <code>g</code>。<code>g</code> 函数的参数顺序与 <code>f</code> 函数的参数顺序相反。</p><p>具体来说，<code>g</code> 函数接受两个参数 <code>x</code> 和 <code>y</code>，并将它们传递给 <code>f</code> 函数，但将参数顺序反转。也就是说，如果 <code>f</code> 函数接受 <code>x</code> 和 <code>y</code> 作为参数，那么 <code>g</code> 函数将接受 <code>y</code> 和 <code>x</code> 作为参数。</p><p>这个 <code>flip&#39;</code> 函数的主要目的是将一个二元函数的参数顺序反转，使得在调用这个函数时，参数顺序与函数定义时相反。这在某些编程任务中非常有用，例如在编写接受和返回参数的函数时，将参数顺序反转可以使得函数更易于使用。</p><p>下面是一个使用 <code>flip&#39;</code> 函数的例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-comment">-- 定义一个二元函数</span><br><span class="hljs-title">double</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">double</span> x = x * <span class="hljs-number">2</span><br><br><span class="hljs-comment">-- 使用 flip&#x27; 函数将参数顺序反转</span><br><span class="hljs-title">triple</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">triple</span> x = double x x<br><br><span class="hljs-comment">-- 调用 triple 函数</span><br><span class="hljs-title">print</span> triple <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">15<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个 <code>double</code> 函数，它接受一个整数参数并返回它的两倍。然后我们使用 <code>flip&#39;</code> 函数将 <code>double</code> 函数的参数顺序反转，得到了 <code>triple</code> 函数，它接受两个整数参数并返回它们的和。最后我们调用 <code>triple</code> 函数并打印结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-过程(procedure)</title>
    <link href="/2023/11/25/Nim/nim-procedure/"/>
    <url>/2023/11/25/Nim/nim-procedure/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim-procedure"><a href="#Nim-procedure" class="headerlink" title="Nim - procedure"></a>Nim - procedure</h1><p>要定义示例中的echo和readLine等新命令，需要<code>过程</code>的概念。您可能习惯了它们在其他语言中被称为方法或函数，但是Nim区分了这些概念。在Nim中，新过程是用proc关键字定义的:</p><p>其实函数叫做过程这个名字还是很贴切的，我们平时一直区分一个语言是面向过程的还是面向对象的，比如说C语言是一个面向对象的语言。在C语言中内存被分为四大类：全局区、静态区、堆区和栈区。而栈区主要依赖于函数，而有些翻译就会将栈区翻译为存储过程。从C语言的角度来看，每一个程序就是一个过程，这个过程在执行的途中会有很多其他的子过程也就是其他的函数。一个程序就是若干个过程嵌套凭借组合的结果。</p><p>所以在这里叫做过程没有丝毫的问题，而且很直观。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> yes(question: <span class="hljs-type">string</span>): <span class="hljs-type">bool</span> =<br>  echo question, <span class="hljs-string">&quot; (y/n)&quot;</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:<br>    <span class="hljs-keyword">case</span> readLine(<span class="hljs-built_in">stdin</span>)<br>    <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>, <span class="hljs-string">&quot;Yes&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>, <span class="hljs-string">&quot;No&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">else</span>: echo <span class="hljs-string">&quot;Please be clear: yes or no&quot;</span><br><br><span class="hljs-keyword">if</span> yes(<span class="hljs-string">&quot;Should I delete all your important files?&quot;</span>):<br>  echo <span class="hljs-string">&quot;I&#x27;m sorry Dave, I&#x27;m afraid I can&#x27;t do that.&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;I think you know what the problem is just as well as I do.&quot;</span><br></code></pre></td></tr></table></figure><p>这个例子展示了一个叫做<code>yes</code>的过程，他接受一个叫做<code>question</code>类型为<code>string</code>的形式参数，返回一个布尔类型。</p><p>过程的第一句<code>echo</code>输出 question的内容以及 (y&#x2F;n) 然后进入一个”死循环“中，然后使用<code>case</code>判断用户输入的内容，匹配到”y”, “Y”, “yes”, “Yes” 就返回 <code>true</code>， 匹配到”n”, “N”, “no”, “No” 将返回<code>false</code>。如果不是上述两种情况就进入else兜底，输出”Please be clear: yes or no” 之后进入下一次循环。</p><p>之后的if就不再是yes过程的内容了，则是调用yes后对其返回值进行一些处理。<strong>下面是原文的翻译</strong></p><blockquote><p>这个例子展示了一个名为yes的过程，它向用户询问一个问题，如果他们回答“是”(或类似的东西)就返回true，如果他们回答“否”(或类似的东西)就返回false。return语句立即离开过程(因此也离开while循环)。(question: string): bool语法描述了过程期望一个名为question的字符串类型的参数，并返回bool类型的值。bool类型是内置的:bool的唯一有效值是true和false。if或while语句中的条件必须是bool类型。</p><p>一些术语:在示例中，问题被称为(形式)参数，“我应该…”被称为传递给该参数的实参。</p></blockquote><h2 id="结果变量"><a href="#结果变量" class="headerlink" title="结果变量"></a>结果变量</h2><p>返回值的过程声明了一个表示返回值的隐式结果变量。没有表达式的返回语句是返回结果的简写。如果在退出处没有返回语句，则总是在过程结束时自动返回结果值。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> sumTillNegative(x: <span class="hljs-type">varargs</span>[<span class="hljs-type">int</span>]): <span class="hljs-type">int</span> =<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span>:<br>      <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">result</span> = <span class="hljs-built_in">result</span> + i<br><br>echo sumTillNegative() <span class="hljs-comment"># echoes 0</span><br>echo sumTillNegative(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) <span class="hljs-comment"># echoes 12</span><br>echo sumTillNegative(<span class="hljs-number">3</span>, <span class="hljs-number">4</span> , -<span class="hljs-number">1</span> , <span class="hljs-number">6</span>) <span class="hljs-comment"># echoes 7</span><br></code></pre></td></tr></table></figure><p>结果变量已经在函数的开头隐式地声明了，因此再次用’var result’声明它，例如，将使用同名的普通变量来遮蔽它。结果变量也已经用类型的默认值初始化了。注意，在过程开始时，引用数据类型将为nil，因此可能需要手动初始化。</p><p>没有任何返回语句且不使用特殊结果变量的过程返回其最后一个表达式的值。例如，这个程序</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> helloWorld(): <span class="hljs-type">string</span> =<br>  <span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><p>结果就是返回一个”Hello, World”。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>过程体中的参数是不可变的。默认情况下，它们的值不能更改，因为这允许编译器以最有效的方式实现参数传递。如果过程中需要一个可变变量，则必须在过程体中使用var声明它。隐藏参数名是可能的，这实际上是一种习惯用法:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> printSeq(s: <span class="hljs-type">seq</span>, nprinted: <span class="hljs-type">int</span> = -<span class="hljs-number">1</span>) =<br>  <span class="hljs-keyword">var</span> nprinted = <span class="hljs-keyword">if</span> nprinted == -<span class="hljs-number">1</span>: s.len <span class="hljs-keyword">else</span>: min(nprinted, s.len)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; nprinted:<br>    echo s[i]<br></code></pre></td></tr></table></figure><p>如果过程需要修改调用者的参数，可以使用 var 参数（又是一个小细节）：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> divmod(a, b: <span class="hljs-type">int</span>; res, remainder: <span class="hljs-keyword">var</span> <span class="hljs-type">int</span>) =<br>  res = a <span class="hljs-keyword">div</span> b        <span class="hljs-comment"># integer division</span><br>  remainder = a <span class="hljs-keyword">mod</span> b  <span class="hljs-comment"># integer modulo operation</span><br><br><span class="hljs-keyword">var</span><br>  x, y: <span class="hljs-type">int</span><br>divmod(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, x, y) <span class="hljs-comment"># modifies x and y</span><br>echo x<br>echo y<br></code></pre></td></tr></table></figure><p>在示例中，<code>res</code> 和<code>remainder</code>是 <code>var</code> 参数。过程可以修改 <code>var</code> 参数，并且调用者可以看到更改。请注意，上面的示例最好使用元组作为返回值，而不是使用 var 参数。</p><h2 id="忽略语句"><a href="#忽略语句" class="headerlink" title="忽略语句"></a>忽略语句</h2><p>若要调用仅为其副作用返回值而忽略其返回值的过程，则必须使用discard语句。Nim不允许静默地丢弃返回值:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">discard</span> yes(<span class="hljs-string">&quot;May I ask a pointless question?&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果调用的proc&#x2F;迭代器已经被声明为可丢弃的pragma，则返回值可以被隐式忽略:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> p(x, y: <span class="hljs-type">int</span>): <span class="hljs-type">int</span> <span class="hljs-meta">&#123;.discardable.&#125;</span> =<br>  <span class="hljs-keyword">return</span> x + y<br><br>p(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment"># now valid</span><br></code></pre></td></tr></table></figure><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>通常一个过程有许多参数，但并不清楚参数出现的顺序。对于构造复杂数据类型的过程尤其如此。因此，可以为过程的参数命名，以便清楚哪个参数属于哪个形参:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> createWindow(x, y, width, height: <span class="hljs-type">int</span>; title: <span class="hljs-type">string</span>;<br>                  show: <span class="hljs-type">bool</span>): <span class="hljs-type">Window</span> =<br>   <span class="hljs-comment"># ...</span><br><br><span class="hljs-keyword">var</span> w = createWindow(show = <span class="hljs-literal">true</span>, title = <span class="hljs-string">&quot;My Application&quot;</span>,<br>                     x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, height = <span class="hljs-number">600</span>, width = <span class="hljs-number">800</span>)<br></code></pre></td></tr></table></figure><p>简单来说就是在调用过程传参数时候，可以加上参数名字来指定参数到底传给谁。很直接。</p><p>现在我们使用命名参数来调用createWindow，参数顺序不再重要了。将命名参数与有序参数混合也是可能的，但不是很好读:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> w = createWindow(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, title = <span class="hljs-string">&quot;My Application&quot;</span>,<br>                     height = <span class="hljs-number">600</span>, width = <span class="hljs-number">800</span>, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><p>编译器检查每个形参是否只接收一个实参。</p><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><p>为了使createWindow过程更容易使用，它应该提供默认值;如果调用者没有指定这些值，则将它们用作参数:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> createWindow(x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, width = <span class="hljs-number">500</span>, height = <span class="hljs-number">700</span>,<br>                  title = <span class="hljs-string">&quot;unknown&quot;</span>,<br>                  show = <span class="hljs-literal">true</span>): <span class="hljs-type">Window</span> =<br>   <br><br><span class="hljs-keyword">var</span> w = createWindow(title = <span class="hljs-string">&quot;My Application&quot;</span>, height = <span class="hljs-number">600</span>, width = <span class="hljs-number">800</span>)<br></code></pre></td></tr></table></figure><p>现在，对createWindow的调用只需要设置与默认值不同的值。</p><p>请注意，类型推断适用于具有默认值的参数;例如，不需要写title: string &#x3D; “unknown”。</p><h2 id="重载过程"><a href="#重载过程" class="headerlink" title="重载过程"></a>重载过程</h2><p>Nim的过程重载和C++的函数重载很相似</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> toString(x: <span class="hljs-type">int</span>): <span class="hljs-type">string</span> =<br>  <span class="hljs-built_in">result</span> =<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>: <span class="hljs-string">&quot;negative&quot;</span><br>    <span class="hljs-keyword">elif</span> x &gt; <span class="hljs-number">0</span>: <span class="hljs-string">&quot;positive&quot;</span><br>    <span class="hljs-keyword">else</span>: <span class="hljs-string">&quot;zero&quot;</span><br><br><span class="hljs-keyword">proc</span> toString(x: <span class="hljs-type">bool</span>): <span class="hljs-type">string</span> =<br>  <span class="hljs-built_in">result</span> =<br>    <span class="hljs-keyword">if</span> x: <span class="hljs-string">&quot;yep&quot;</span><br>    <span class="hljs-keyword">else</span>: <span class="hljs-string">&quot;nope&quot;</span><br><br>assert toString(<span class="hljs-number">13</span>) == <span class="hljs-string">&quot;positive&quot;</span> <span class="hljs-comment"># calls the toString(x: int) proc</span><br>assert toString(<span class="hljs-literal">true</span>) == <span class="hljs-string">&quot;yep&quot;</span>    <span class="hljs-comment"># calls the toString(x: bool) proc</span><br></code></pre></td></tr></table></figure><p>(注意，toString通常是Nim中的$操作符。)编译器为toString调用选择最合适的过程。这里不讨论重载解析算法是如何工作的——详细信息请参阅手册。歧义调用被报告为错误。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Nim标准库大量使用了重载——其中一个原因是像+这样的每个操作符都只是一个重载的过程。解析器允许您以中缀符号(a + b)或前缀符号(+ a)使用操作符。中缀操作符总是接收两个参数，前缀操作符总是接收一个参数。(后缀操作符是不可能的，因为这将是模棱两可的:a@ @b是表示(a) @ (@b)还是(a@) @ (b)?它总是表示(a) @ (@b)，因为在Nim中没有后缀操作符。</p><p>除了一些内置的关键字操作符，如and, or, not，操作符总是由以下字符组成:+ - * \ &#x2F; &lt; &gt; &#x3D; @ $ ~ &amp; % !？ ^。|</p><p>允许使用用户定义的操作符。没有什么能阻止你定义自己的@!?+~操作符，但这样做可能会降低可读性。</p><p>操作符的优先级由它的第一个字符决定。详细信息可在手册中找到。</p><p>定义new操作符时，将操作符用反引号” ‘ “括起来:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> `$` (x: myDataType): <span class="hljs-type">string</span> = <br><span class="hljs-comment"># now the $ operator also works with myDataType, overloading resolution</span><br><span class="hljs-comment"># ensures that $ works for built-in types just like before</span><br></code></pre></td></tr></table></figure><h2 id="前置申明"><a href="#前置申明" class="headerlink" title="前置申明"></a>前置申明</h2><p>每个变量、过程等在使用之前都需要声明。(这样做的原因是，在像Nim这样广泛支持元编程的语言中避免这种需求是很重要的。)然而，对于相互递归的过程不能这样做:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># forward declaration:</span><br><span class="hljs-keyword">proc</span> even(n: <span class="hljs-type">int</span>): <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">proc</span> odd(n: <span class="hljs-type">int</span>): <span class="hljs-type">bool</span> =<br>  assert(n &gt;= <span class="hljs-number">0</span>) <span class="hljs-comment"># makes sure we don&#x27;t run into negative recursion</span><br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">else</span>:<br>    n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> even(n-<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">proc</span> even(n: <span class="hljs-type">int</span>): <span class="hljs-type">bool</span> =<br>  assert(n &gt;= <span class="hljs-number">0</span>) <span class="hljs-comment"># makes sure we don&#x27;t run into negative recursion</span><br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">else</span>:<br>    n == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> odd(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里奇数取决于偶数，反之亦然。因此，甚至需要在编译器完全定义它之前引入它。这种前向声明的语法很简单:只需省略&#x3D;和过程体即可。assert只是添加边界条件，稍后将在模块一节中介绍。</p><p>该语言的后续版本将削弱对前向声明的要求。</p><p>该示例还显示了进程的主体可以由单个表达式组成，然后隐式返回该表达式的值。</p><h2 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h2><p>正如在介绍中提到的，Nim区分了过程、函数和方法，它们分别由proc、func和method关键字定义。在某些方面，Nim的定义比其他语言更迂腐。</p><p>函数更接近于纯数学函数的概念，如果你曾经做过函数式编程，你可能会对它很熟悉。本质上，它们是带有附加限制的过程:它们不能访问全局状态(除了const)，也不能产生副作用。func关键字基本上是带有{. nosideeffects .}标记的proc的别名。然而，函数仍然可以更改其可变参数，即那些标记为var的参数，以及任何ref对象。</p><p>与过程不同，方法是动态分派的。这听起来有点复杂，但它是一个与继承和面向对象编程密切相关的概念。如果您重载一个过程(两个具有相同名称但不同类型或具有不同参数集的过程被称为重载)，要使用的过程将在编译时确定。另一方面，方法依赖于从RootObj继承的对象。这将在本教程的第二部分进行更深入的讨论。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-控制流</title>
    <link href="/2023/11/23/Nim/nim-control-flow/"/>
    <url>/2023/11/23/Nim/nim-control-flow/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim-控制流"><a href="#Nim-控制流" class="headerlink" title="Nim 控制流"></a>Nim 控制流</h1><p>一个基本的程序拥有循环和分支是一件毫无争议的事情。修改以下之前最初始的代码，让我们一起看看新的东西。</p><h2 id="if-分支选择语句"><a href="#if-分支选择语句" class="headerlink" title="if 分支选择语句"></a>if 分支选择语句</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">let</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br><span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span>:<br>  echo <span class="hljs-string">&quot;Poor soul, you lost your name?&quot;</span><br><span class="hljs-keyword">elif</span> name == <span class="hljs-string">&quot;name&quot;</span>:<br>  echo <span class="hljs-string">&quot;Very funny, your name is name.&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;Hi, &quot;</span>, name, <span class="hljs-string">&quot;!&quot;</span><br></code></pre></td></tr></table></figure><p>程序中可以存在零个或者多个<code>elif</code>片段，<code>else</code>也是可选的。关键字<code>elif</code>相比其他语言中的<code>else if</code>更加简短，他也是<code>else if</code>的缩写，这可以避免产生过多的缩进。<br>上端代码首先从键盘中接受一串字符串，如果名字是空字符串（用户直接打了一个回车），则输出“Poor soul, you lost your name?” 如果用户输入的是”name”， 输入就是”Very funny, your name is name”。其他的情况就认为属于合理情况全部放到了else， 都输出 “hi + name + !”</p><h2 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h2><p>case 语句提供了另一种分支方式。 case 语句允许多个分支：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">let</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br><span class="hljs-keyword">case</span> name<br><span class="hljs-keyword">of</span> <span class="hljs-string">&quot;&quot;</span>:<br>  echo <span class="hljs-string">&quot;Poor soul, you lost your name?&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-string">&quot;name&quot;</span>:<br>  echo <span class="hljs-string">&quot;Very funny, your name is name.&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-string">&quot;Dave&quot;</span>, <span class="hljs-string">&quot;Frank&quot;</span>:<br>  echo <span class="hljs-string">&quot;Cool name!&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;Hi, &quot;</span>, name, <span class="hljs-string">&quot;!&quot;</span><br></code></pre></td></tr></table></figure><p>可以看出，对于 of 分支，还允许使用逗号分隔的值列表。</p><p>case中放置需要进行比较的值，每一个of 就是每个条件分支。 粗略看一眼感觉和<code>switch...case</code>差不多，不过这里的case 语句可以处理整数、其他序数类型和字符串。 （很快就会解释什么是序数类型。）对于整数或其他序数类型，值范围也是可能的：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">from</span> std/strutils <span class="hljs-keyword">import</span> parseInt<br><br><span class="hljs-keyword">let</span> score = parseInt(readLine(<span class="hljs-built_in">stdin</span>))<br><span class="hljs-keyword">case</span> score<br><span class="hljs-keyword">of</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span>:<br>    echo <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">8</span>:<br>    echo <span class="hljs-string">&quot;B&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">7</span>:<br>    echo <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">6</span>:<br>    echo <span class="hljs-string">&quot;D&quot;</span><br><span class="hljs-keyword">else</span>:<br>    echo <span class="hljs-string">&quot;F&quot;</span><br></code></pre></td></tr></table></figure><p>因为使用readLine()函数读取到的是一个字符串，然后我们这里需要用到一个<code>int</code>, 那么就需要做一个转换来完成这个事情，这就用到了<code>parseInt()</code>， 然后此函数需要导入一个包才能够使用，这就用到了第一句话<code>from std/strutils import parseInt</code></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># this statement will be explained later:</span><br><span class="hljs-keyword">from</span> std/strutils <span class="hljs-keyword">import</span> parseInt<br><br>echo <span class="hljs-string">&quot;A number please: &quot;</span><br><span class="hljs-keyword">let</span> n = parseInt(readLine(<span class="hljs-built_in">stdin</span>))<br><span class="hljs-keyword">case</span> n<br><span class="hljs-keyword">of</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span>, <span class="hljs-number">4</span>..<span class="hljs-number">7</span>: echo <span class="hljs-string">&quot;The number is in the set: &#123;0, 1, 2, 4, 5, 6, 7&#125;&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">3</span>, <span class="hljs-number">8</span>: echo <span class="hljs-string">&quot;The number is 3 or 8&quot;</span><br></code></pre></td></tr></table></figure><p>这段代码看起来不错，用来分辨一个数字，但是实际上这段代码无法通过编译。因为case语句并没有覆盖所有的情况，列出所有的情况也不是一个很实际的动作，更倾向于忽略掉剩下的情况。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">case</span> n<br><span class="hljs-keyword">of</span> <span class="hljs-number">0</span>..<span class="hljs-number">2</span>, <span class="hljs-number">4</span>..<span class="hljs-number">7</span>: echo <span class="hljs-string">&quot;The number is in the set: &#123;0, 1, 2, 4, 5, 6, 7&#125;&quot;</span><br><span class="hljs-keyword">of</span> <span class="hljs-number">3</span>, <span class="hljs-number">8</span>: echo <span class="hljs-string">&quot;The number is 3 or 8&quot;</span><br><span class="hljs-keyword">else</span>: <span class="hljs-keyword">discard</span><br></code></pre></td></tr></table></figure><p>这个空的<code>discard</code>语句会告诉编译器这里什么也不做，编译器知道else部分的语句不会判断失败，因此错误会消失。注意，不可能涵盖所有可能的字符串值:这就是为什么字符串情况总是需要一个else分支。</p><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;What&#x27;s your name? &quot;</span><br><span class="hljs-keyword">var</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br><span class="hljs-keyword">while</span> name == <span class="hljs-string">&quot;&quot;</span>:<br>  echo <span class="hljs-string">&quot;Please tell me your name: &quot;</span><br>  name = readLine(<span class="hljs-built_in">stdin</span>) <span class="hljs-comment"># no `var`, because we do not declare a new variable here</span><br></code></pre></td></tr></table></figure><p>这里给的案例比较简单，使用<code>while</code>判断name是不是一个空字符串，如果是空字符串就执行<code>while</code>里面的内容，就是输出”Please tell me your name” 然后让用户再输入一次。当然，如果输入的字符串不是空的，那就跳出了循环。</p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>for语句是循环遍历迭代器提供的任何元素的构造。该示例使用内置计数迭代器:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;Counting to ten: &quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> countup(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>  echo i<br><span class="hljs-comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span><br></code></pre></td></tr></table></figure><p>变量I在 for循环中隐式的被定义为int 类型，这取决于<code>countup()</code>返回了的类型。在循环中i会从1开始经过每次循环最后成为10。使用<code>while</code>也能完成此操作。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim">echo <span class="hljs-string">&quot;Counting to 10: &quot;</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">10</span>:<br>  echo i<br>  inc i <span class="hljs-comment"># increment i by 1</span><br><span class="hljs-comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span><br></code></pre></td></tr></table></figure><p>上面的代码中，通过<code>inc i</code>的方式让<code>i</code>每次循环都自身+1，他的效果和其他语言中使用到的<code>++i</code>是一样的。</p><p>由于计算时常在程序中发生，所以还有一个做同样事情的迭代器</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">10</span>:<br>  ...<br></code></pre></td></tr></table></figure><p>这样会从100一直递减到1</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> countdown(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>):<br>  sum += i<br>echo sum<br></code></pre></td></tr></table></figure><p>默认情况下，数的左右都是闭区间， 可以用<code>..&lt;</code>表示不到这个数</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; <span class="hljs-number">10</span>:<br>    <span class="hljs-comment"># the same as 0 .. 9</span><br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;some string&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; s.len:<br><span class="hljs-comment"># do something</span><br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;some string&quot;</span><br><span class="hljs-keyword">for</span> idx, c <span class="hljs-keyword">in</span> s[<span class="hljs-number">0</span> .. ^<span class="hljs-number">1</span>]:<br>   <span class="hljs-comment"># ^1 is the last element, ^2 would be one before it, and so on</span><br>   <span class="hljs-comment"># ^1是最后一个元素， ^2是倒数第二个元素</span><br></code></pre></td></tr></table></figure><p>还有一些其他有用的迭代器:</p><ul><li>Items和mitems，分别提供不可变元素和可变元素</li><li>Pairs和mpairs，提供元素和索引号(分别是不可变的和可变的)<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> index, item <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>].pairs:<br>  echo item, <span class="hljs-string">&quot; at index &quot;</span>, index<br><span class="hljs-comment"># =&gt; a at index 0</span><br><span class="hljs-comment"># =&gt; b at index 1</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="作用域和块语句"><a href="#作用域和块语句" class="headerlink" title="作用域和块语句"></a>作用域和块语句</h2><p>控制流语句有一个尚未涉及的特性:它们打开一个新的作用域。这意味着在下面的例子中，x在循环之外是不可访问的:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">while</span> <span class="hljs-literal">false</span>:<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;hi&quot;</span><br>echo x <span class="hljs-comment"># x在这里不工作</span><br></code></pre></td></tr></table></figure><p>while (for)语句引入了一个隐式块。标识符只在声明它们的块中可见。block语句可用于显式地打开一个新块:<br>这个效果类似在C#或者C++中用花括号开了一个block</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">block</span> myblock:<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;hi&quot;</span><br>echo x <span class="hljs-comment"># does not work either</span><br></code></pre></td></tr></table></figure><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>可以使用break语句提前离开块。break语句可以留下while语句、for语句或block语句。它离开最里面的构造，除非给出了块的标签:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">block</span> myblock:<br>  echo <span class="hljs-string">&quot;entering block&quot;</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:<br>    echo <span class="hljs-string">&quot;looping&quot;</span><br>    <span class="hljs-keyword">break</span> <span class="hljs-comment"># 离开了循环但是还在myblock块之中</span><br>  echo <span class="hljs-string">&quot;still in block&quot;</span><br>echo <span class="hljs-string">&quot;outside the block&quot;</span><br><br><span class="hljs-keyword">block</span> myblock2:<br>  echo <span class="hljs-string">&quot;entering block&quot;</span><br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:<br>    echo <span class="hljs-string">&quot;looping&quot;</span><br>    <span class="hljs-keyword">break</span> myblock2 <span class="hljs-comment"># 离开了block,当然也离开了循环</span><br>  echo <span class="hljs-string">&quot;still in block&quot;</span> <span class="hljs-comment"># it won&#x27;t be printed</span><br>echo <span class="hljs-string">&quot;outside the block&quot;</span><br></code></pre></td></tr></table></figure><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p>和其他语言一样,continue会结束本次循环进入下一个循环中</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> .. <span class="hljs-number">5</span>:<br>  <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">3</span>: <span class="hljs-keyword">continue</span><br>  echo i <span class="hljs-comment"># will only print 4 and 5</span><br></code></pre></td></tr></table></figure><h2 id="when-语句"><a href="#when-语句" class="headerlink" title="when 语句"></a>when 语句</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">when</span> system.hostOS == <span class="hljs-string">&quot;windows&quot;</span>:<br>  echo <span class="hljs-string">&quot;running on Windows!&quot;</span><br><span class="hljs-keyword">elif</span> system.hostOS == <span class="hljs-string">&quot;linux&quot;</span>:<br>  echo <span class="hljs-string">&quot;running on Linux!&quot;</span><br><span class="hljs-keyword">elif</span> system.hostOS == <span class="hljs-string">&quot;macosx&quot;</span>:<br>  echo <span class="hljs-string">&quot;running on Mac OS X!&quot;</span><br><span class="hljs-keyword">else</span>:<br>  echo <span class="hljs-string">&quot;unknown operating system&quot;</span><br></code></pre></td></tr></table></figure><p>when语句与if语句几乎相同，但有以下区别:</p><ul><li>每个条件必须是一个常量表达式，因为它是由编译器求值的。</li><li>分支中的语句不会打开新的作用域。</li><li>编译器检查语义，并仅为属于第一个条件且计算结果为true的语句生成代码。</li></ul><p>when语句对于编写特定于平台的代码很有用，类似于C编程语言中的#ifdef构造。</p><h2 id="语句和缩进"><a href="#语句和缩进" class="headerlink" title="语句和缩进"></a>语句和缩进</h2><p>现在我们已经介绍了基本的控制流语句，让我们回到Nim缩进规则。</p><p>在Nim中，简单语句和复杂语句是有区别的。简单语句不能包含其他语句:赋值、过程调用或返回语句都是简单语句。if、when、for、while等复杂语句可以包含其他语句。为了避免歧义，复杂语句必须总是缩进，但单个简单语句不需要:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># no indentation needed for single-assignment statement:</span><br><span class="hljs-keyword">if</span> x: x = <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># indentation needed for nested if statement:</span><br><span class="hljs-keyword">if</span> x:<br>  <span class="hljs-keyword">if</span> y:<br>    y = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">else</span>:<br>    y = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># indentation needed, because two statements follow the condition:</span><br><span class="hljs-keyword">if</span> x:<br>  x = <span class="hljs-literal">false</span><br>  y = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>表达式是语句的一部分，通常会产生一个值。if语句中的条件是表达式的一个例子。表达式可以在某些地方包含缩进以获得更好的可读性:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">if</span> thisIsaLongCondition() <span class="hljs-keyword">and</span><br>    thisIsAnotherLongCondition(<span class="hljs-number">1</span>,<br>       <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>):<br>  x = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>根据经验，表达式中的缩进可以在操作符、开括号和逗号之后进行。</p><p>使用括号和分号(;)可以使用只允许表达式的语句:</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># computes fac(4) at compile time:</span><br><span class="hljs-keyword">const</span> fac4 = (<span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span>: x *= i; x)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-常量和变量</title>
    <link href="/2023/11/23/Nim/nim-constant-value/"/>
    <url>/2023/11/23/Nim/nim-constant-value/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim中的常量和变量"><a href="#Nim中的常量和变量" class="headerlink" title="Nim中的常量和变量"></a>Nim中的常量和变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量在创建的是否就需要明确的绑定一个值，编译器必须能够在编译时计算常量声明中的表达式。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&quot;abc&quot;</span>  <span class="hljs-comment"># 定一个一个值为&quot;abc&quot;的常量字符串:x</span><br></code></pre></td></tr></table></figure><p>如果要定义多个常量, 可以把const写在前面（ 让我感受到了go语言导包的味道）</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">const</span><br>x = <span class="hljs-number">1</span><br>y = <span class="hljs-number">2</span><br>z = y + <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a>let 语句</h2><p><code>let</code>语句的行为和<code>var</code>看起来差不多，都可以用来定义变量，但是<code>let</code>语句定义的变量在初始化完成之后就无法再次修改。可以理解是一个不可变变量。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">let</span> x = <span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-comment"># 没毛病，申明一个新变量x并给他赋值为&quot;abc&quot;</span><br>x = <span class="hljs-string">&quot;xyz&quot;</span> <span class="hljs-comment"># 非法的，不可以再修改x的值</span><br></code></pre></td></tr></table></figure><p>let 和 const 的区别在于：let 引入了一个不能重新赋值的变量，const 的意思是“强制编译时评估并将其放入数据段”：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">const</span> input = readLine(<span class="hljs-built_in">stdin</span>) <span class="hljs-comment">#错误的，编译是无法明确input是什么</span><br><span class="hljs-keyword">let</span> input = readLine(<span class="hljs-built_in">stdin</span>) <span class="hljs-comment"># 正确的，他活了</span><br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>通过<code>var</code>声明的变量可进行多次赋值</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;abc&quot;</span><br>x = <span class="hljs-string">&quot;xyz&quot;</span><br></code></pre></td></tr></table></figure><p>&#x3D; 是赋值运算符。赋值运算符可以重载。您可以使用单个赋值语句声明多个变量，并且所有变量将具有相同的值：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> x, y = <span class="hljs-number">3</span>  <span class="hljs-comment"># assigns 3 to the variables `x` and `y`</span><br>echo <span class="hljs-string">&quot;x &quot;</span>, x  <span class="hljs-comment"># outputs &quot;x 3&quot;</span><br>echo <span class="hljs-string">&quot;y &quot;</span>, y  <span class="hljs-comment"># outputs &quot;y 3&quot;</span><br>x = <span class="hljs-number">42</span>        <span class="hljs-comment"># changes `x` to 42 without changing `y`</span><br>echo <span class="hljs-string">&quot;x &quot;</span>, x  <span class="hljs-comment"># outputs &quot;x 42&quot;</span><br>echo <span class="hljs-string">&quot;y &quot;</span>, y  <span class="hljs-comment"># outputs &quot;y 3&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nim-hello world</title>
    <link href="/2023/11/23/Nim/nim-hello/"/>
    <url>/2023/11/23/Nim/nim-hello/</url>
    
    <content type="html"><![CDATA[<h1 id="Nim-Hello-world"><a href="#Nim-Hello-world" class="headerlink" title="Nim - Hello world!"></a>Nim - Hello world!</h1><p>这段时间一直在玩Haskell, 有点小腻。换个编程语言看看调节一下口味，本系列是对官方文档《 <a href="https://nim-lang.org/docs/tut1.html">Tutorial, part 1</a>》《  <a href="https://nim-lang.org/docs/tut2.html">Tutorial, part 2</a>》和《<a href="https://nim-lang.org/docs/tut3.html">Tutorial, part 3</a>》三部曲进行学习，然后增加了本人的一些思索过程，可全当作是官方学习手册的汉化版本。<br>话不多说，我们直接开始吧。上手，先来一个基本的小程序，问你的名字是什么，然后输出 “hi” + name + “!”。 </p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># This is a comment</span><br>echo <span class="hljs-string">&quot;What&#x27;s your name? &quot;</span><br><span class="hljs-keyword">var</span> name: <span class="hljs-type">string</span> = readLine(<span class="hljs-built_in">stdin</span>)<br>echo <span class="hljs-string">&quot;Hi, &quot;</span>, name, <span class="hljs-string">&quot;!&quot;</span><br></code></pre></td></tr></table></figure><p>将文件保存叫做greetings.nim， 之后就是编译运行他。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim compile --run greetings.nim<br></code></pre></td></tr></table></figure><p>添加上<code>--run</code>参数后便可以让nim编译文件通过后运行他，在文件名之后也可以添加运行参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim compile --run greetings.nim arg1 arg2<br></code></pre></td></tr></table></figure><p>常用的命令和开关都有缩写，因此您还可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim c -r greetings.nim<br></code></pre></td></tr></table></figure><p>在默认情况下编译采用的是<code>Debug</code>模式，如果想要以<code>Release</code>模式进行编译，需要显式添加参数<code>-d:release</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">nim c -d:release greetings.nim<br></code></pre></td></tr></table></figure><p>默认情况下，Nim 编译器会生成大量运行时检查，旨在满足您的调试乐趣。使用 -d:release 会关闭一些检查并打开优化。<br>对于基准测试或生产代码，请使用 -d:release 开关。要将性能与 C 等不安全语言进行比较，请使用 -d:danger 开关以获得有意义的、可比较的结果。否则，Nim 可能会受到 C 无法使用的检查的阻碍。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在使用到在字符串时，需要用双引号将字符串包起来，这样编译器才会认为这是一个字符串。 var 语句声明一个名为 name 的字符串类型的新变量，其值由 readLine 过程返回。由于编译器知道 readLine 返回一个字符串，因此您可以在声明中省略类型（这称为本地类型推断）。所以这也可以工作：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-keyword">var</span> name = readLine(<span class="hljs-built_in">stdin</span>)<br></code></pre></td></tr></table></figure><p>请注意，这基本上是 Nim 中存在的唯一类型推断形式：它是简洁性和可读性之间的良好折衷。  </p><p>“hello world”程序包含编译器已知的几个标识符：echo、readLine 等。这些内置函数在系统模块中声明，并由任何其他模块隐式导入。</p><h2 id="词汇元素"><a href="#词汇元素" class="headerlink" title="词汇元素"></a>词汇元素</h2><p>让我们更详细地看看 Nim 的词汇元素：与其他编程语言一样，Nim 由（字符串）文字、标识符、关键字、注释、运算符和其他标点符号组成。</p><h3 id="字符串和符号字面量"><a href="#字符串和符号字面量" class="headerlink" title="字符串和符号字面量"></a>字符串和符号字面量</h3><p>字符串需要被一对双引号包裹在里面，特殊的字符（转义字符）使用<code>\</code> 转义符号进行修饰，<code>\n</code>表示换行，<code>\t</code>表示制表符缩进，还有很多别的符号。如果我们不需要转义的字符串，而是一个原始文本，那么在字符串前添加一个<code>r</code>即可。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-string">r&quot;C:\program files\nim&quot;</span><br></code></pre></td></tr></table></figure><p>在原始文字中，反斜杠不是转义字符。<br>编写字符串文字的第三种也是最后一种方法是长字符串文字。它们用三个引号写成：“”“…”“”；它们可以跨越多行，并且 \ 也不是转义字符。例如，它们对于嵌入 HTML 代码模板非常有用。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释以字符串或字符文字之外的任意位置开始，并以井号字符 # 开头。文档注释以##开头：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment"># A comment.</span><br><br><span class="hljs-keyword">var</span> myVariable: <span class="hljs-type">int</span> <span class="hljs-comment">## a documentation comment</span><br></code></pre></td></tr></table></figure><p>文档注释是标记;它们只允许出现在输入文件的特定位置，因为它们属于语法树!该特性支持更简单的文档生成器。<br>多行注释以#[ 开始，以]# 结束。多行注释也可以嵌套。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Nim"><span class="hljs-comment">#[</span><br><span class="hljs-type">You</span> can have <span class="hljs-type">any</span> <span class="hljs-type">Nim</span> code text commented<br><span class="hljs-keyword">out</span> inside this <span class="hljs-keyword">with</span> no indentation restrictions.<br>      yes(<span class="hljs-string">&quot;May I ask a pointless question?&quot;</span>)<br>  <span class="hljs-comment">#[</span><br>     <span class="hljs-type">Note</span>: these can be nested!!<br>  ]<span class="hljs-comment">#</span><br>]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>数字文字的书写方式与大多数其他语言一样。作为一个特殊的变化，允许使用下划线以获得更好的可读性:1_000_000(一百万)。包含点(或’e’或’e’)的数字是浮点文字:10.e9(十亿)。十六进制字面值以0x为前缀，二进制字面值以0b为前缀，八进制字面值以0为前缀。单独的前导零不能产生八进制数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell-柯里函数</title>
    <link href="/2023/11/21/Haskell/haskell-currying/"/>
    <url>/2023/11/21/Haskell/haskell-currying/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-柯里函数"><a href="#Haskell-柯里函数" class="headerlink" title="Haskell - 柯里函数"></a>Haskell - 柯里函数</h1><p>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。核心思想是把多参数传入的函数拆成单参数（或部分）函数，内部再返回调用下一个单参数（或部分）函数，依次处理剩余的参数。<br>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//传统写法</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> result2 = <span class="hljs-built_in">get_sum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>);  <span class="hljs-comment">//柯里化</span><br></code></pre></td></tr></table></figure><p>在Haskell中所有的函数其实都只有一个参数，我们事实上编辑的所有多参数的函数都是柯里函数。柯里函数不会一次性读完所有参数，而是在每次调用时只取一个参数，并返回一个一元函数来取下一个函数。<br>所以说在Haskell中这两种调用方法是一样的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">max</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>(max <span class="hljs-number">4</span>) <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这是怎么实现的呢？先看一下函数原型是啥样子的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; :t max<br>max :: Ord a =&gt; a -&gt; a -&gt; a<br></code></pre></td></tr></table></figure><p>上面的申明也可以写成下面的样子：<code>max :: Ord a =&gt; a -&gt; (a -&gt; a)</code><br>只要在类型签名中看到 <code>-&gt;</code>，就一律意味着它是一个将箭头左侧是为参数类型并将箭头右侧的部分视作返回类型的函数。如果遇到<code>a -&gt; (a -&gt; a)</code>这样的类型签名，就是说它是一个函数，会接受一个a作为参数，然后返回一个函数，然后这个函数也是取a作为参数，返回一个类型为a的值。</p><p>这有什么好处呢？只要用部分参数来调用某个函数，就可以得到一个部分应用函数，此函数接受的参数的数量和之前少传入的参数数量一致。因此可以通过初始的一个简单函数来构造出更复杂的函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">multThree</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">multThree</span> x y z = x * y * z<br></code></pre></td></tr></table></figure><p>使用<code>((multThree 3) 5 ) 9</code> 的方式调用他，一开始接受一个参数3， 那么返回一个函数的一元函数，之后再给一个5， 就会得到3 * 5 的函数， 然后再传一个9， 最后返回135。</p><p>其实可以理解将一部分参数丢给一个函数，函数会返回一个带着他一部分结果的小函数，然后这个小函数再接受一个参数，然后再返回一个函数。最后直到函数被灌满结束。<br>通过这个，我们可以玩一个好玩的</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">multTwoWithNine</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">multTwoWithNine</span> = multThree <span class="hljs-number">9</span><br><span class="hljs-comment">-- 等价于</span><br><span class="hljs-comment">-- multTwoWith x y = multTHree 9 x y</span><br><br><span class="hljs-title">multTwoWithNine</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-comment">-- 返回54</span><br></code></pre></td></tr></table></figure><h2 id="截断（section）"><a href="#截断（section）" class="headerlink" title="截断（section）"></a>截断（section）</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">divideByTen</span> :: (<span class="hljs-type">Floating</span> a) =&gt; a -&gt; a<br><span class="hljs-title">divideByTen</span> = (/<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>用括号将一个中缀函数包裹起来，得到一个一元函数，其参数代表函数的剩余参数。这个<code>/</code>函数本来需要左右都有一个参数才可以使用，然后用括号包裹他之后就宛如截断了一样，然后<code>/</code>本来需要两个参数，现在填充了一个参数，<code>divideByTen</code>再提供一个参数。<br>这样的写法<code>divideByTen 200</code> 和 直接调用 <code>(/10) 200</code> 或者 <code>200 / 10</code>的效果是一样的。</p><h2 id="打印函数"><a href="#打印函数" class="headerlink" title="打印函数"></a>打印函数</h2><p>如果直接将函数打印出来会怎么样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; multThree 3 4<br><br>&lt;interactive&gt;:4:1: error:<br>    • No instance <span class="hljs-keyword">for</span> (Show (Integer -&gt; Integer))<br>        arising from a use of ‘<span class="hljs-built_in">print</span>’<br>        (maybe you haven<span class="hljs-string">&#x27;t applied a function to enough arguments?)</span><br><span class="hljs-string">    • In a stmt of an interactive GHCi command: print it</span><br></code></pre></td></tr></table></figure><p>GHCI： 表达式返回一个类型为 a -&gt; a 函数，但是不知道如何将他显示到屏幕上。函数g并非Show类型类的实例。<br>为什么我们执行 1+1的时候可以得到2呢？因为它会首先计算得到2, 然后调用<code>show</code> 得到该数字的字符串表示，然后再输出到屏幕上。</p><p><strong>所以一定要理解柯里函数的工作原理，在Haskell中真的非常重要！</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 递归</title>
    <link href="/2023/11/21/Haskell/haskell-recursion/"/>
    <url>/2023/11/21/Haskell/haskell-recursion/</url>
    
    <content type="html"><![CDATA[<h1 id="你好，递归"><a href="#你好，递归" class="headerlink" title="你好，递归"></a>你好，递归</h1><p>递归是指在定义的应用自身的方式，将白了就是函数会自己调用自己。“从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，讲的是什么呢：从前有座山，山里有座庙……”<br>数学定义中存在的递归随处可见，比如斐波那契数列，杨辉三角形等。递归在函数式语言中能够发挥真正的威力，因为在函数式编程中，重要的不是给出求解的步骤，而是定义问题与解的描述。<br>在下文会使用Haskell和C++两种语言进行描述。</p><ol><li><p>求列表中元素的最大值</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">maximumNumber</span> :: (<span class="hljs-type">Ord</span> a) =&gt; [a] -&gt; a<br><span class="hljs-title">maximumNumber</span> [] = error <span class="hljs-string">&quot;maximumNumber of empty list&quot;</span><br><span class="hljs-title">maximumNumber</span> [oneElement] = oneElement<br><span class="hljs-title">maximumNumber</span> (element : elements) = max element (maximumNumber elements)<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print $ maximumNumber [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure></li><li><p>求斐波那契数列</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">fibonacci</span> :: (<span class="hljs-type">Num</span> a, <span class="hljs-type">Ord</span> a) =&gt; a -&gt; a<br><span class="hljs-title">fibonacci</span> <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-title">fibonacci</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br><span class="hljs-title">fibonacci</span> n = fibonacci (n - <span class="hljs-number">1</span>) + fibonacci (n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> N&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> fibonacci = fibonacci&lt;N<span class="hljs-number">-1</span>&gt; + fibonacci&lt;N<span class="hljs-number">-2</span>&gt;;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> fibonacci&lt;<span class="hljs-number">1</span>&gt; = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> fibonacci&lt;<span class="hljs-number">0</span>&gt; = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>实现replicate</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">replicate&#x27;</span> :: <span class="hljs-type">Int</span> -&gt; a -&gt; [a]<br><span class="hljs-title">repllicte&#x27;</span> n x<br>| n &lt;= <span class="hljs-number">0</span> = []<br>| otherwise = x:replicate&#x27; (n-<span class="hljs-number">1</span>) x<br></code></pre></td></tr></table></figure></li><li><p>实现take</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">take&#x27;</span> :: (<span class="hljs-type">Num</span> i, <span class="hljs-type">Ord</span> i) =&gt; i -&gt; [a] -&gt; a<br><span class="hljs-title">take&#x27;</span> n _        <br>| n &lt;= <span class="hljs-number">0</span>     = []<br><span class="hljs-title">take&#x27;</span> _ []       = []<br><span class="hljs-title">take&#x27;</span> n (x:xs)   = x : take&#x27; (n-<span class="hljs-number">1</span>) xs<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell-case</title>
    <link href="/2023/11/21/Haskell/haskell-case/"/>
    <url>/2023/11/21/Haskell/haskell-case/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-case"><a href="#Haskell-case" class="headerlink" title="Haskell - case"></a>Haskell - case</h1><p>函数中模板匹配的本质实际上就是case语句的语法糖。case语句在函数式编程中用途往往比命令式要大很多，因为这样可以很流畅的定义出一个没有指令流程的函数，使得函数的定义更加流畅。<br>举一个简单的例子</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetterV1</span> :: [a] -&gt; a<br><span class="hljs-title">firstLetterV1</span> [] = error <span class="hljs-string">&quot;Null list&quot;</span><br><span class="hljs-title">firstLetterV1</span> [x:_] = x<br></code></pre></td></tr></table></figure><p>完全等价于这段代码</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetterV2</span> :: [a] -&gt; a<br><span class="hljs-title">firstLetterV2</span> str = <span class="hljs-keyword">case</span> str <span class="hljs-keyword">of</span> [] -&gt; error <span class="hljs-string">&quot;Null list&quot;</span><br>                                (x:_) -&gt; x<br></code></pre></td></tr></table></figure><p>从中我们可以看到case表达式语法长这个样子<br> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">case</span> expression <span class="hljs-keyword">of</span> pattern -&gt; result<br> pattern -&gt; result<br> pattern -&gt; result<br> <span class="hljs-comment">-- ....</span><br></code></pre></td></tr></table></figure></p><p>于是乎就可以写出这样的代码</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">scoreValue</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Char</span><br><span class="hljs-title">scoreValue</span> value =<br>    <span class="hljs-keyword">let</span> range = div value <span class="hljs-number">10</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span> range <span class="hljs-keyword">of</span> <span class="hljs-number">6</span> -&gt; <span class="hljs-string">&#x27;D&#x27;</span><br>                     <span class="hljs-number">7</span> -&gt; <span class="hljs-string">&#x27;C&#x27;</span><br>                     <span class="hljs-number">8</span> -&gt; <span class="hljs-string">&#x27;B&#x27;</span><br>                     <span class="hljs-number">9</span> -&gt; <span class="hljs-string">&#x27;A&#x27;</span><br>                     <span class="hljs-number">10</span> -&gt; <span class="hljs-string">&#x27;S&#x27;</span><br>                     _ -&gt; <span class="hljs-string">&#x27;F&#x27;</span><br><br><span class="hljs-title">describeList</span> :: [a] -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">describeList</span> ls = <span class="hljs-string">&quot;The list is &quot;</span> ++ str ls<br>    <span class="hljs-keyword">where</span> str [] = <span class="hljs-string">&quot;empty&quot;</span><br>          str [x] = <span class="hljs-string">&quot;a singleton list&quot;</span><br>          str ls = <span class="hljs-string">&quot;a longer list&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - let</title>
    <link href="/2023/11/21/Haskell/haskell-let/"/>
    <url>/2023/11/21/Haskell/haskell-let/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-let"><a href="#Haskell-let" class="headerlink" title="Haskell - let"></a>Haskell - let</h1><p>我们可以在函数中使用<code>where</code>比较轻松的在函数底部绑定变量，他对包括所有<code>guard</code>在内的整个函数可见。可我们还想要更多的功能，比如函数处理过程中可能需要一些局部变量，或者做一些临时运算，那么<code>let</code>可以完成这个功能。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">cylinder</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span><br><span class="hljs-title">cylinder</span> r h = <br>    <span class="hljs-keyword">let</span> sideArea = h * r * <span class="hljs-number">2</span><br>        topArea = pi * r * r<br>    <span class="hljs-keyword">in</span> sideArea + topArea<br>    <br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print $ cylinder <span class="hljs-number">3</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><em>let &lt; bindings &gt; in &lt; expressions &gt;</em> let中绑定的名字只能在in中使用<br>let 和 where最大的区别就是 let是一个表达式，表达式一定是有一个返回值的，而where不是。所以let可以在几乎任何地方使用。</p><p>从一个元组中取值</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell">(<span class="hljs-keyword">let</span> (a, b, c) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> a + b + c) * <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这里让a,b,c分别匹配到了数字1, 2, 3， 之后再相加乘以100，最后结果是600</p><h2 id="列表推导式中的let"><a href="#列表推导式中的let" class="headerlink" title="列表推导式中的let"></a>列表推导式中的let</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="hljs-keyword">let</span> bmi = w / h ^ <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="hljs-keyword">let</span> bmi = w / h ^ <span class="hljs-number">2</span>, bmi &gt; <span class="hljs-number">25.0</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java小实验-初步使用类</title>
    <link href="/2023/11/18/Java/java-example-2/"/>
    <url>/2023/11/18/Java/java-example-2/</url>
    
    <content type="html"><![CDATA[<h1 id="java小实验-初步使用类"><a href="#java小实验-初步使用类" class="headerlink" title="java小实验-初步使用类"></a>java小实验-初步使用类</h1><p>定义一个学生类，包含的成员有：姓名，学号，绩优成绩，总人数，平均绩优成绩等数据成员，和数据的getter 和setter方法，以及toString 方法，合理使用 public, private, static,final等限定词。主函数中创建５个学生对象，输出每个学生的个性信息，以及全部学生对象的全局信息。</p><p><strong>Student.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> String id;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> score;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> total;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> average;  <br>  <br>    Student(String name, String id, <span class="hljs-type">double</span> score) &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>        <span class="hljs-built_in">this</span>.score = score;  <br>        average = (average * total++ + score) / total;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetName</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">GetId</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetScore</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.score;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetName</span><span class="hljs-params">(String name)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetId</span><span class="hljs-params">(String id)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.id = id;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SetScore</span><span class="hljs-params">(<span class="hljs-type">double</span> score)</span>&#123;  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">lastScore</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.score;  <br>        average =  (average * total - lastScore + score) / total;  <br>        <span class="hljs-built_in">this</span>.score = score;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetCount</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> total;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetAverage</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> average;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;学号%s 姓名%s 成绩%f&quot;</span>, GetId(), GetName(), GetScore());  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test1&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student1.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test2&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        student2.SetId(<span class="hljs-string">&quot;1919810&quot;</span>);  <br>        System.out.println(student2.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test3&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student3.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test4&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student4.toString());  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">student5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;test5&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>, <span class="hljs-number">60.1</span>);  <br>        System.out.println(student5.toString());  <br>  <br>        System.out.println(<span class="hljs-string">&quot;平均成绩 &quot;</span> + student1.GetAverage());  <br>        student3.SetScore(<span class="hljs-number">80.5</span>);  <br>        System.out.println(<span class="hljs-string">&quot;平均成绩 &quot;</span> + student1.GetAverage());  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - where</title>
    <link href="/2023/11/16/Haskell/haskell-where/"/>
    <url>/2023/11/16/Haskell/haskell-where/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-where"><a href="#Haskell-where" class="headerlink" title="Haskell - where"></a>Haskell - where</h1><p> 引入一个小案例<br> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTest</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTest</span> weight height<br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">18.5</span> = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">25</span> = <span class="hljs-string">&quot;Normal&quot;</span><br>    | weight / height ^ <span class="hljs-number">2</span> &lt;= <span class="hljs-number">30</span> = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br></code></pre></td></tr></table></figure><br>这是一个简单的bmi指数测试函数，使用了前一篇的guard完成，这样写挺好，但是还是不够完美。这里对bmi数值有三次重复的计算，如果输入的数据走到了otherwise就会算三次，血亏！<br>让我们稍加修改一下代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTestV2</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTestV2</span> weight height<br>    | bmi &lt;= underWeight = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | bmi &lt;= normal = <span class="hljs-string">&quot;Normal&quot;</span><br>    | bmi &lt;= overWeight = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span><br>          underWeight = <span class="hljs-number">18.5</span><br>          normal = <span class="hljs-number">25</span><br>          overWeight = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>看着代码应该就明白这个怎么回事了，但是有一点需要吐槽，就是这个缩进问题，他不是像python那样固定缩进到一个代码块就ok了，而是变量定义都必须对齐到同一列，如果不这样规范，Haskell就会搞不清楚他们各自位于哪个代码块中了。</p><h2 id="where的作用域"><a href="#where的作用域" class="headerlink" title="where的作用域"></a><code>where</code>的作用域</h2><p>函数where部分定义的名字只对本函数可见，所以不用担心存在大量的全局函数污染代码。当然如果想要一个全局变量，那么反而是要自己定义一下的。</p><h2 id="where中的模式模式匹配"><a href="#where中的模式模式匹配" class="headerlink" title="where中的模式模式匹配"></a><code>where</code>中的模式模式匹配</h2><p>在where中也可以使用到模式匹配，修改前面的BMI函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">bmiTestV2</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">bmiTestV2</span> weight height<br>    | bmi &lt;= underWeight = <span class="hljs-string">&quot;Underweight&quot;</span><br>    | bmi &lt;= normal = <span class="hljs-string">&quot;Normal&quot;</span><br>    | bmi &lt;= overWeight = <span class="hljs-string">&quot;Overweight&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Obese&quot;</span><br>    <span class="hljs-keyword">where</span> bmi = weight / height ^ <span class="hljs-number">2</span><br>          (underWright, normal, overHeight) = (<span class="hljs-number">18.5</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">30.0</span>)<br></code></pre></td></tr></table></figure><h2 id="where块中的函数"><a href="#where块中的函数" class="headerlink" title="where块中的函数"></a><code>where</code>块中的函数</h2><p>在where中也可以定义函数，美滋滋属于是了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">calcBmis</span> :: [(<span class="hljs-type">Double</span>. <span class="hljs-type">Double</span>)] -&gt; [<span class="hljs-type">Double</span>]<br><span class="hljs-title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs]<br><span class="hljs-keyword">where</span> bmi weight height = weight / height ^ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - guard</title>
    <link href="/2023/11/16/Haskell/haskell-guard/"/>
    <url>/2023/11/16/Haskell/haskell-guard/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-guard"><a href="#Haskell-guard" class="headerlink" title="Haskell - guard"></a>Haskell - guard</h1><p><strong>Haskell - guard</strong></p><p>在Haskell中，guard是一种编程技巧，用于在满足某个条件时执行一段代码，否则跳过该代码块。guard通常用于控制流语句（如if、elif和else）中，用于在满足某个条件时执行相应的代码。<br>除了使用其他语言基本都会存在的控制流语句之外，还可以使用**|** 来进行条件分支的处理，可读性更高而且与模式匹配契合的非常好</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">scoreLevel</span> :: <span class="hljs-type">Double</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">scoreLevel</span> score<br>    | score &lt; <span class="hljs-number">60</span> = <span class="hljs-string">&quot;Failed!&quot;</span><br>    | score &lt; <span class="hljs-number">70</span> = <span class="hljs-string">&quot;Passed!&quot;</span><br>    | score &lt; <span class="hljs-number">80</span> = <span class="hljs-string">&quot;Good!&quot;</span><br>    | score &lt; <span class="hljs-number">90</span> = <span class="hljs-string">&quot;Excellent!&quot;</span><br>    | otherwise = <span class="hljs-string">&quot;Perfect!&quot;</span><br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (scoreLevel <span class="hljs-number">60</span>)<br>    print (scoreLevel <span class="hljs-number">70</span>)<br>    print (scoreLevel <span class="hljs-number">80</span>)<br>    print (scoreLevel <span class="hljs-number">90</span>)<br></code></pre></td></tr></table></figure><p>这段代码定义了一个名为<code>scoreLevel</code>的函数，接受一个<code>Double</code>类型的参数<code>score</code>，并返回一个字符串。该函数根据<code>score</code>的值，返回不同的字符串。otherwise会捕获剩下的所有条件。<br>一个竖线就是一个布尔表达式，如果计算是True就会选择对应的函数进入，如果是False就会走下面的表达式。一句题外话， |  不像 switch..case一样，进入一个case后就会执行下面的case所有语句。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">myCompare</span> :: (<span class="hljs-type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="hljs-type">Ordering</span><br><span class="hljs-title">myCompare</span> x y<br>    | x &gt; y = <span class="hljs-type">GT</span><br>    | x == y = <span class="hljs-type">EQ</span><br>    | otherwise = <span class="hljs-type">LT</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 模式匹配</title>
    <link href="/2023/11/16/Haskell/haskell-pattern-matching/"/>
    <url>/2023/11/16/Haskell/haskell-pattern-matching/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell-模式匹配"><a href="#Haskell-模式匹配" class="headerlink" title="Haskell - 模式匹配"></a>Haskell - 模式匹配</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>引子：假设我们要一个函数，这个函数可以处理一个数是不是7。按照之前的思路，我们可以这样写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">isSevenV1</span> x = <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;Is seven&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Is not seven&quot;</span><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ isSevenV1<br></code></pre></td></tr></table></figure><p>那么如果是判断一个数的是0-10中的哪一个，是否这样写会稍微麻烦一点，不过可能想到使用列表<code>[(1,&quot;one&quot;),(2,&quot;two&quot;)]</code>这样来处理。 </p><p>那么或许有一个不错的方法——模式匹配</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">isSevenV1</span> x = <span class="hljs-keyword">if</span> x == <span class="hljs-number">7</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;Is seven&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Is not seven&quot;</span><br><br>  <br><br><span class="hljs-title">isSevenV2</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">isSevenV2</span> <span class="hljs-number">7</span> = <span class="hljs-string">&quot;Is seven&quot;</span><br><span class="hljs-title">isSevenV2</span> x = <span class="hljs-string">&quot;Is not seven&quot;</span><br><br>  <br><span class="hljs-title">sayNumber</span> ::<span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">1</span> = <span class="hljs-string">&quot;One&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">2</span> = <span class="hljs-string">&quot;Two&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">3</span> = <span class="hljs-string">&quot;Three&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">4</span> = <span class="hljs-string">&quot;Four&quot;</span><br><span class="hljs-title">sayNumber</span> <span class="hljs-number">5</span> = <span class="hljs-string">&quot;Five&quot;</span><br><span class="hljs-title">sayNumber</span> x = <span class="hljs-string">&quot;Not between 1 and 5&quot;</span><br><br>  <br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br><br><span class="hljs-title">print</span> $ isSevenV1 <span class="hljs-number">7</span><br><span class="hljs-title">print</span> $ isSevenV2 <span class="hljs-number">8</span><br><span class="hljs-title">print</span> $ isSevenV2 <span class="hljs-number">7</span><br><br>  <br><span class="hljs-title">print</span> $ sayNumber <span class="hljs-number">3</span><br><span class="hljs-title">print</span> $ sayNumber <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>在调用函数时，会将传入的参数从上往下顺序检查，一旦有匹配，对应的函数就会被调用。 如果给出一个x,y,z这样的参数，那么他就成为了一个万能模式，可以匹配到所有的参数， 一个好处就是可以处理最后情况之外的部分。<br>当然如果将万能模式丢到了函数最上面，那么很抱歉，万能模式函数之后的函数就永远都不会匹配到了。</p><p><em>使用模式匹配完成一个求阶乘</em></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">factorial</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">factorial</span> <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br><span class="hljs-title">factorial</span> n = n * factorial (n - <span class="hljs-number">1</span>)<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ factorial <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>不过有些函数看起来可以正常运行，但是实际上却会出发runtime error。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">charName</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;a&#x27;</span> = <span class="hljs-number">1</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;b&#x27;</span> = <span class="hljs-number">2</span><br><span class="hljs-title">charName</span> <span class="hljs-string">&#x27;c&#x27;</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果我们在调用函数的时候，使用<code>charName &#39;h&#39;</code>。 可以得到<code>Non-exhaustive</code>因为这套模板没有不够全面，没有考虑到’a’ ‘b’ ‘c’三者之外的情况。那么程序也就会发生不可预料的问题，这里其实也有一定的防御式编程思想。</p><h2 id="元组的模式匹配"><a href="#元组的模式匹配" class="headerlink" title="元组的模式匹配"></a>元组的模式匹配</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">addVectorsV1</span> :: (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)<br><span class="hljs-title">addVectorsV1</span> a b = (fst a + fst b, snd a + snd b)<br><br><span class="hljs-title">addVectorsV2</span> :: (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) -&gt; (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>)<br><span class="hljs-title">addVectorsV2</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)<br><br>  <br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ addVectorsV1 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>print $ addVectorsV2 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>虽然我们可以使用<code>addVectorV1</code>的方式去处理两个或者多个元组的之间的操作。针对于每一个元组用fst和snd取双元组的两个元素。可以运行,没有问题。但是有更加漂亮的做法<code>addVectorV2</code><br>参数直接上两个元组，还有了名字，用两个字来说：优雅。</p><p><strong>实现一个三元组</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">tupleFirst</span> :: (a,b,c) -&gt; a<br><span class="hljs-title">tupleFirst</span> (x,_,_) = x<br>  <br><span class="hljs-title">tupleSecond</span> :: (a,b,c) -&gt; b<br><span class="hljs-title">tupleSecond</span> (_,y,_) = y<br><br><span class="hljs-title">tuledThird</span> :: (a,b,c) -&gt; c<br><span class="hljs-title">tuledThird</span> (_,_,z) = z<br></code></pre></td></tr></table></figure><p>不用关心具体是什么类型，也不需要管具体的内容，给上一个泛变量就ok了。</p><h2 id="列表与列表推导式匹配"><a href="#列表与列表推导式匹配" class="headerlink" title="列表与列表推导式匹配"></a>列表与列表推导式匹配</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">xs</span> = [(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">5</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)]<br>[a + b | (a,b) &lt;- xs]<br></code></pre></td></tr></table></figure><p>可以得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ghci">[4,7,6,8,11] <br></code></pre></td></tr></table></figure><p><strong>做一个简单的head函数</strong><br><em>([1,2,3] 只是一个 1:2:3:[]的语法糖)</em></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">head</span>` :: [a] -&gt; a<br><span class="hljs-title">head</span>` [] = error &#x27;<span class="hljs-type">Can</span> not call head on a empty list&#x27;<br><span class="hljs-title">head</span>` (x:_) = x<br></code></pre></td></tr></table></figure><h2 id="As模式"><a href="#As模式" class="headerlink" title="As模式"></a>As模式</h2><p>允许按照模式将一个值分割成多个项，同时保留对其整体的引用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">firstLetter</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span><br><span class="hljs-title">firstLetter</span> <span class="hljs-string">&quot;&quot;</span> = <span class="hljs-string">&quot;Empty string&quot;</span><br><span class="hljs-title">firstLetter</span> all@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>print $ firstLetter <span class="hljs-string">&quot;&quot;</span><br>    print $ firstLetter <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>这个函数接受一个字符串参数，并返回一个字符串。<br><code>firstLetter :: String -&gt; String</code></p><p>函数的实现分为两种情况：</p><ol><li>如果输入的字符串为空字符串（””），则返回字符串 “Empty string”。</li><li>如果输入的字符串非空，则返回字符串 “The first letter of [all] is [first letter]”。其中 <code>[all]</code> 和 <code>[first letter]</code> 分别表示输入的字符串 <code>all</code> 和第一个字母 <code>first letter</code>。</li></ol><p>函数的实现使用了一个As模式<code>all@(x:xs)</code>，它表示一个字符串 <code>all</code>，其中 <code>x</code> 是字符串 <code>xs</code> 的第一个字符。这里或许会因为变量名字觉得理解，xs是否是x+s这种情况，实际上也可以命名为(firstLetter : exceptFirstLetter)也是一样的。这也是上面说的列表的语法糖。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">all</span>@(x:xs) = <span class="hljs-string">&quot;The first letter of &quot;</span> ++ all ++ <span class="hljs-string">&quot; is &quot;</span> ++ [x]<br></code></pre></td></tr></table></figure><p>这个匿名函数的目的是将字符串 <code>all</code> 的第一个字母替换为输入字符串 <code>all</code> 的第一个字母，并将结果与字符串 <code>[x]</code> 连接起来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 顺序表结构</title>
    <link href="/2023/11/15/DataStructure/c-seqlist/"/>
    <url>/2023/11/15/DataStructure/c-seqlist/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言顺序表结构"><a href="#C语言顺序表结构" class="headerlink" title="C语言顺序表结构"></a>C语言顺序表结构</h1><p>顺序表，也称作线性表，是数据结构的一种，由一系列数据元素组成，每个数据元素在内存中按顺序存放。顺序表中的数据元素可以是相同类型的数据，也可以是不同类型的数据。</p><p>在计算机科学中，顺序表通常用数组表示，数组是一个由相同类型的数据元素组成的集合。数组中的每个元素都存储在一个连续的内存地址中，并且可以通过它们的索引来访问。</p><p>例如，下面是一个用Python表示的顺序表，其中包含整数：<br><code>my_list = [1, 2, 3, 4, 5]</code></p><p>在这个例子中，<code>my_list</code>是一个包含五个整数的顺序表，它们的值分别为1、2、3、4、5。要访问其中某个元素的值，可以使用索引，例如：<br><code>first_element = my_list[0]  # first_element的值为1 second_element = my_list[1]  # second_element的值为2</code></p><p>顺序表可以用于存储各种类型的数据，如整数、浮点数、对象等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEQUENTIAL_LIST_H  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQUENTIAL_LIST_H  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];  <br>    <span class="hljs-type">int</span> age;  <br>&#125; Data;  <br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>    Data *list_data;  <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SEQUENTIAL_LIST_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEQUENTIAL_LIST_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125; Data;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Data *list_data;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> max_length;<br>&#125; sequential_list;<br><br><span class="hljs-comment">// initialize the list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_init</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-built_in">list</span>-&gt;list_data = (Data *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Data) * size);<br>    <span class="hljs-built_in">list</span>-&gt;max_length = size;<br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// return the length of the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_length</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// append a new element to the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_append</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, Data data)</span> &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;length &gt;= <span class="hljs-built_in">list</span>-&gt;max_length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">list</span>-&gt;list_data[<span class="hljs-built_in">list</span>-&gt;length++] = data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// insert a new element to the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_insert</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index, Data data)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;max_length || index &gt; <span class="hljs-built_in">list</span>-&gt;length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// shift the elements to the right</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">list</span>-&gt;length; i &gt; index; i--) &#123;<br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// insert the new element</span><br>    <span class="hljs-built_in">list</span>-&gt;list_data[index] = data;<br>    <span class="hljs-built_in">list</span>-&gt;length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-comment">// delete an element from the list</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_delete</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span>(index &lt;<span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// shift the elements to the left</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index; i&lt;<span class="hljs-built_in">list</span>-&gt;length; i--)&#123;<br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> --<span class="hljs-built_in">list</span>-&gt;length;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_get_index</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, Data data)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(data.age == <span class="hljs-built_in">list</span>-&gt;list_data[i].age &amp;&amp; <span class="hljs-built_in">strcmp</span>(data.name, <span class="hljs-built_in">list</span>-&gt;list_data[i].name) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>Data* <span class="hljs-title function_">set_get_element</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-built_in">list</span>-&gt;list_data[index];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_clean</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span>&#123;  <br>    <span class="hljs-built_in">free</span>(<span class="hljs-built_in">list</span>-&gt;list_data);  <br>    <span class="hljs-built_in">list</span>-&gt;max_length = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data = <span class="hljs-literal">NULL</span>;  <br>&#125;<br><br><span class="hljs-comment">// print the element in the list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_print_element</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;age);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//SEQUENTIAL_LIST_H</span></span><br>    <span class="hljs-type">int</span> length;  <br>    <span class="hljs-type">int</span> max_length;  <br>&#125; sequential_list;  <br>  <br><span class="hljs-comment">// initialize the list  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_init</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> size)</span> &#123;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data = (Data *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Data) * size);  <br>    <span class="hljs-built_in">list</span>-&gt;max_length = size;  <br>    <span class="hljs-built_in">list</span>-&gt;length = <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// return the length of the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_length</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// append a new element to the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_append</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, Data data)</span> &#123;  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span>-&gt;length &gt;= <span class="hljs-built_in">list</span>-&gt;max_length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">list</span>-&gt;list_data[<span class="hljs-built_in">list</span>-&gt;length++] = data;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// insert a new element to the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_insert</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index, Data data)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;max_length || index &gt; <span class="hljs-built_in">list</span>-&gt;length) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// shift the elements to the right  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">list</span>-&gt;length; i &gt; index; i--) &#123;  <br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i - <span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-comment">// insert the new element  </span><br>    <span class="hljs-built_in">list</span>-&gt;list_data[index] = data;  <br>    <span class="hljs-built_in">list</span>-&gt;length++;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-comment">// delete an element from the list  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_delete</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;  <br>    <span class="hljs-keyword">if</span>(index &lt;<span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// shift the elements to the left  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=index; i&lt;<span class="hljs-built_in">list</span>-&gt;length; i--)&#123;  <br>        <span class="hljs-built_in">list</span>-&gt;list_data[i] = <span class="hljs-built_in">list</span>-&gt;list_data[i+<span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> --<span class="hljs-built_in">list</span>-&gt;length;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">seq_get_index</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, Data data)</span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;length; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(data.age == <span class="hljs-built_in">list</span>-&gt;list_data[i].age &amp;&amp; <span class="hljs-built_in">strcmp</span>(data.name, <span class="hljs-built_in">list</span>-&gt;list_data[i].name) == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">return</span> i;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>  <br>Data* <span class="hljs-title function_">set_get_element</span><span class="hljs-params">(sequential_list* <span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">list</span>-&gt;length)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> &amp;<span class="hljs-built_in">list</span>-&gt;list_data[index];  <br>&#125;  <br>  <br><span class="hljs-comment">// print the element in the list  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">seq_print_element</span><span class="hljs-params">(sequential_list *<span class="hljs-built_in">list</span>, <span class="hljs-type">int</span> index)</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;name);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;age:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;list_data-&gt;age);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;index:%d\n&quot;</span>, <span class="hljs-built_in">list</span>-&gt;length - <span class="hljs-number">1</span>);  <br>&#125;  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//SEQUENTIAL_LIST_H</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>C-example</tag>
      
      <tag>Data-Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java小实验-多态的应用</title>
    <link href="/2023/11/14/Java/java-example-1/"/>
    <url>/2023/11/14/Java/java-example-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Java小实验-多态的应用"><a href="#Java小实验-多态的应用" class="headerlink" title="Java小实验-多态的应用"></a>Java小实验-多态的应用</h1><h2 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h2><p>通过包的创建，类的继承在程序中的具体应用，进一步掌握多态的特点、技巧及使用等。同时熟练使用Java异常处理机制，处理程序中可能出现的异常。</p><h2 id="二、实验环境及要求"><a href="#二、实验环境及要求" class="headerlink" title="二、实验环境及要求"></a>二、实验环境及要求</h2><p>Jdk1.8以上的开发环境，可使用任何编辑器。</p><h2 id="三、实验内容及相应程序"><a href="#三、实验内容及相应程序" class="headerlink" title="三、实验内容及相应程序"></a>三、实验内容及相应程序</h2><ol><li>设计一个圆类Circle，该类存在于mycircle包中，它具有以下的属性和方法：<br>私有属性：圆半径r，圆心坐标x和y，<br>方法：设置和获取所有私有属性r,x,y的方法，方法名自定；计算圆周长的方法perimeter()；计算圆面积的方法area(),<br>要求直接使用Math类中的PI；</li><li>设计一个圆柱体类Cylinder，该类存在于mycylinder包中，Cylinder继承Circle，它增加了以下属性和方法：<br> 私有属性：高度h，<br> 方法：设置和获取私有属性h的方法，方法名自定；计算表面积的方法area()；计算体积的方法volume()；</li><li>编写一个Java Application程序Compute.java，用来显示某一个圆柱体中心坐标位置(如图1中的k的位置)，高度h，以及它的表面积（不包括两个底的面积）、体积和底面积。要求圆半径r，圆心坐标x和y，以及高度h的值均从命令行输入。<br> <strong>提示及注意：</strong><br> 圆柱体的体积&#x3D;底面积<em>高；<br> 圆柱体的表面积&#x3D;底面周长</em>高；<br> 每一个圆柱体的生成，都是在原有的圆的基础上，添加高度生成的。</li><li>编写测试类Computer.java程序，该类能够处理程序中可能出现的所有的异常 ，并有相应的提示信息。如命令行没有输入，则程序会向控制台输出“命令行没有输入，请输入正确的数值”这样的提示信息；</li></ol><h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>MyCircle.Circle.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> MyCircle;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> r;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">this</span>.y = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">this</span>.r = <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = x;  <br>        <span class="hljs-built_in">this</span>.y = y;  <br>        <span class="hljs-built_in">this</span>.r = CheckRadiusFormat(r);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.x = x;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.y = y;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Circle <span class="hljs-title function_">SetR</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.r = CheckRadiusFormat(r);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetX</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> x;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetY</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> y;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">GetR</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> r;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Perimeter</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> Math.PI * <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">this</span>.r;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Area</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> Math.PI * Math.pow(r, <span class="hljs-number">2</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">CheckRadiusFormat</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;半径不能小于0&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> r;  <br>    &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyCylinder.Cylinder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> MyCylinder;  <br>  <br><span class="hljs-keyword">import</span> MyCircle.Circle;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Circle</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> h;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cylinder</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cylinder</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">double</span> r, <span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-built_in">super</span>(x, y, r);  <br>        <span class="hljs-built_in">this</span>.h = CheckHeightFormat(h);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Double <span class="hljs-title function_">GetH</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> Cylinder <span class="hljs-title function_">SetHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.h = CheckHeightFormat(h);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Area</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area() * <span class="hljs-number">2</span> + <span class="hljs-built_in">super</span>.GetR() * <span class="hljs-number">2</span> * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">SurfaceArea</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.GetR() * <span class="hljs-number">2</span> * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Volume</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area() * <span class="hljs-built_in">this</span>.h;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">BottomArea</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.Area();  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">private</span> Double <span class="hljs-title function_">CheckHeightFormat</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;高度不能为0&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> h;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Compute.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> MyCylinder.Cylinder;  <br>  <br><span class="hljs-comment">///程序入口类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Compute</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">vecArgs</span> <span class="hljs-operator">=</span> Computer.CheckArgs(args);  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">cylinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cylinder</span>(vecArgs.get(<span class="hljs-number">0</span>),vecArgs.get(<span class="hljs-number">1</span>),vecArgs.get(<span class="hljs-number">2</span>),vecArgs.get(<span class="hljs-number">3</span>));  <br>        System.out.printf(<span class="hljs-string">&quot;%s,高度为%f\n&quot;</span>, FormatCoordinate(cylinder), cylinder.GetH());  <br>        System.out.println(<span class="hljs-string">&quot;表面积是：&quot;</span> + cylinder.SurfaceArea());  <br>        System.out.println(<span class="hljs-string">&quot;体积是：&quot;</span> + cylinder.Volume());  <br>        System.out.println(<span class="hljs-string">&quot;底面积是：&quot;</span> + cylinder.BottomArea());  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">FormatCoordinate</span><span class="hljs-params">(Cylinder cylinder)</span>&#123;  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cylinder.GetX();  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> cylinder.GetY();  <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">var</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> cylinder.GetR();  <br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;(%f,%f,%f)&quot;</span>, x,y,r);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Computer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Vector;  <br>  <br><span class="hljs-comment">///测试类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector&lt;Integer&gt; <span class="hljs-title function_">CheckArgs</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        <span class="hljs-keyword">if</span>(args.length == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;命令行没有输入，请输入正确的数值&quot;</span>);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">4</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;太少的参数，需要至少四个&quot;</span>);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">4</span>)&#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;太多的参数，需要至多四个&quot;</span>);  <br>        &#125;  <br>  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">vec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;Integer&gt;();  <br>  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">for</span>(String element : args)&#123;  <br>                vec.add(Integer.parseInt(element));  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">return</span> vec;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p><strong>输入参数 5 6 3 7</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">(5.000000,6.000000,3.000000),高度为7.000000<br>表面积是：42.0<br>体积是：197.92033717615698<br>底面积是：28.274333882308138<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell类型类</title>
    <link href="/2023/11/14/Haskell/haskell-typeclas/"/>
    <url>/2023/11/14/Haskell/haskell-typeclas/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell的类型类"><a href="#Haskell的类型类" class="headerlink" title="Haskell的类型类"></a>Haskell的类型类</h1><p>类型类(<code>typeclass</code>)是定义行为的接口。类似于其他语言中的<code>interface</code>，比如C++的抽象接口类。如果一个类型是某类型类的实例(instance)，那么他必须实现该类型定义的行为。<strong>千万不要将Haskell的类型类与面向对象语言中的类Class搞混淆</strong></p><p>假设定义类一个类型类（接口）名字叫做吃饭，然后又定义了鸟、人、鱼作为吃饭类型类的实例，那么鸟、人、鱼类就需要实现怎么吃饭这个行为。如果用C++的语言表达，可能是需要创建一个类，在里面声明了一个抽象函数(<code>virtual void eat() = 0</code>), 其他的类继承了这个类，那么必须要实现它。<br><em><strong>不过个人觉得，这个思想的方法，Rust中的trait似乎更贴切一点。</strong></em></p><p>使用<code>:t (==)</code> 查看 &#x3D;&#x3D; 在Haskell中的函数原型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t (==)<br>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool<br><br>ghci&gt; :t (+)<br>(+) :: Num a =&gt; a -&gt; a -&gt; a<br></code></pre></td></tr></table></figure><p>这里出现了一个新的符号 &#x3D;&gt; (实际在上篇文章中使用到了)，它的左侧叫做类型约束，这里的 &#x3D;&#x3D; 和 + 分别约束了使用 Eq和Num两个类。</p><h2 id="Eq-类型类"><a href="#Eq-类型类" class="headerlink" title="Eq 类型类"></a>Eq 类型类</h2><p>用于判断相等性的类型，Eq类定义了等式(&#x3D;&#x3D;)和不等式(&#x2F;&#x3D;)。由Prelude导出的所有基本数据类型都是Eq的实例，并且Eq可以为其成分也是Eq实例的任何数据类型派生。 Haskell官方没有定义Eq一定要实现什么。 然而，&#x3D;&#x3D;通常期望实现等价关系，其中两个比较相等的值通过“公共”函数无法区分，“公共”函数是不允许查看实现细节的函数。 例如，对于表示非规范化自然数模100的类型，“公共”函数不会在1和201之间产生差异。</p><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell">(==) | (/=)<br></code></pre></td></tr></table></figure><h2 id="Ord-类型类"><a href="#Ord-类型类" class="headerlink" title="Ord 类型类"></a>Ord 类型类</h2><p>Ord 类用于可比较大小的类型。 Ord的实例可以为任何组成类型为Ord的用户定义数据类型派生。数据声明中构造函数的声明顺序决定派生Ord实例的顺序。Ordering数据类型允许一次比较来确定两个对象的精确排序。<br>和Eq类似，取两个参数，返回一个Bool类型的值，用来表示是否满足对应的比较关系</p><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">compare</span> | (&lt;=)<br></code></pre></td></tr></table></figure><h2 id="Show-类型类"><a href="#Show-类型类" class="headerlink" title="Show 类型类"></a>Show 类型类</h2><p>将值转换为可读字符串。</p><p>Show的派生实例具有以下属性，它们与Read的派生实例兼容:</p><ul><li>show的结果是一个语法正确的Haskell表达式，只包含常量，只要在声明类型时有效地声明了固定性。它只包含在数据类型、括号和空格中定义的构造函数名称。当使用带标签的构造函数字段时，还会使用大括号、逗号、字段名和等号。</li><li>如果构造函数被定义为中缀操作符，那么showsPrec将生成构造函数的中缀应用。</li><li>如果x中的顶级构造函数的优先级小于d(忽略结合性)，则表示将被括在括号中。因此，如果d为0，则结果永远不会被括号包围;如果d是11，则它总是用圆括号括起来，除非它是原子表达式。</li><li>如果构造函数是使用记录语法定义的，那么show将生成记录语法表单，其中字段的顺序与原始声明的顺序相同。</li></ul><p>除函数以外的所有类型都是SHow的实例，可以使用show函数将值转换为字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; <span class="hljs-built_in">read</span> 3<br><span class="hljs-string">&quot;3&quot;</span><br><br>ghci&gt; <span class="hljs-built_in">read</span> 5.334<br><span class="hljs-string">&quot;5.334&quot;</span><br><br>ghci&gt; <span class="hljs-built_in">read</span> True<br><span class="hljs-string">&quot;True&quot;</span><br></code></pre></td></tr></table></figure><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">showsPrec</span> | show<br></code></pre></td></tr></table></figure><h2 id="Read-类型类"><a href="#Read-类型类" class="headerlink" title="Read 类型类"></a>Read 类型类</h2><p>解析字符串，生成值。</p><p>Read的派生实例做出以下假设，这些假设派生了Show obey的实例:</p><ul><li>如果构造函数被定义为中缀操作符，那么派生的Read实例将只解析构造函数的中缀应用程序(而不是前缀形式)。</li><li>结合性不用于减少括号的出现，尽管可以使用优先级。</li><li>如果构造函数是使用记录语法定义的，则派生的Read将只解析记录语法形式，而且，字段必须按照与原始声明相同的顺序给出。</li><li>派生的Read实例允许在输入字符串的令牌之间使用任意的Haskell空白。还允许使用额外的括号。</li></ul><p>Read可以看做Show相反的类型类，之前提到的所有类都是Read类型，read函数可以去一个字符串作为参数并转为Read的某个实例的类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci &gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;True&quot;</span> || False<br>True<br><br>ghci &gt; <span class="hljs-built_in">read</span> <span class="hljs-string">&quot;8.2&quot;</span> + 3.8<br>12.0<br></code></pre></td></tr></table></figure><p>如果尝试使用<code>read &quot;4&quot;</code>来得到生成一个数字4的效果，那么这是不可能的，会得到一个大大的报错。因为GHCI并不能准确知道到底要个什么玩意来满足屏幕面前的你<br>所以如果在没有一个表达式的情况下，或者说最好给read转换增加一个显示的类型注解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; <span class="hljs-string">&quot;5&quot;</span> :: Int<br>5<br><br>ghci&gt; <span class="hljs-string">&quot;5&quot;</span> :: Float<br>5.0<br></code></pre></td></tr></table></figure><p><strong>最小完整定义</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">readsPrec</span> | readPrec<br></code></pre></td></tr></table></figure><h2 id="Enum-类型类"><a href="#Enum-类型类" class="headerlink" title="Enum 类型类"></a>Enum 类型类</h2><p>Enum的实例对象都是可连续的（枚举），每一个值都有相应的后继和前驱，分别可以通过<code>succ</code>和<code>pred</code>得到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;e&#x27;</span>]<br><span class="hljs-string">&quot;abcde&quot;</span><br><br>ghci&gt; succ <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-string">&#x27;C&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Bounded-类型类"><a href="#Bounded-类型类" class="headerlink" title="Bounded 类型类"></a>Bounded 类型类</h2><p>类型存在一个上限和下限，分别可以通过maxBound和minBound两个函数获得</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ghci&gt; minBound ::Int<br>-9223372036854775808<br><br>ghci&gt; maxBound ::Char<br><span class="hljs-string">&#x27;\1114111&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Num-类型类"><a href="#Num-类型类" class="headerlink" title="Num 类型类"></a>Num 类型类</h2><p>表示一个数值的类型类，它的实例都具有数的特征。<br>只有具有Show和Eq的实例类型，才可以成为Num类型类的实例</p><h2 id="Floating-类型类"><a href="#Floating-类型类" class="headerlink" title="Floating 类型类"></a>Floating 类型类</h2><p>包含Float和Double两种浮点类型，用于存储浮点数。<br>使用Floating类型类的实例类型作为参数或者返回类型的函数，一般需要用到浮点数进行某种计算</p><h2 id="Integral-类型类"><a href="#Integral-类型类" class="headerlink" title="Integral 类型类"></a>Integral 类型类</h2><p>另一种表示数值的类型类。Num类型类包含了实数和整数相关的所有类型，Integral只包含了整数。</p><p>详细的对于类型类的介绍可以参考以下官方文档链接：<br><a href="https://hackage.haskell.org/package/ghc-prim-0.7.0/docs/GHC-Classes.html">https://hackage.haskell.org/package/ghc-prim-0.7.0/docs/GHC-Classes.html</a><br><a href="https://hackage.haskell.org/package/base-4.15.1.0/docs/GHC-Show.html#t:Show">https://hackage.haskell.org/package/base-4.15.1.0/docs/GHC-Show.html#t:Show</a><br><a href="https://hackage.haskell.org/package/base-4.15.1.0/docs/Text-Read.html#v:Read">https://hackage.haskell.org/package/base-4.15.1.0/docs/Text-Read.html#v:Read</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell中的类型</title>
    <link href="/2023/11/13/Haskell/haskell-type/"/>
    <url>/2023/11/13/Haskell/haskell-type/</url>
    
    <content type="html"><![CDATA[<h1 id="Haskell中的类型"><a href="#Haskell中的类型" class="headerlink" title="Haskell中的类型"></a>Haskell中的类型</h1><p>在Haskell中，每个表达式都会在编译时得到明确的类型，从而提高代码的安全性。当然这样就会导致在输入不同的类型进行某些操作时候得到编译捕获错误<br>这自然好过在运行时出现崩溃，然后自己去逐个排查是什么问题。<strong>Haskell中一切皆有类型，因此编译器在编译期间可以得到更多的消息来检查错误</strong></p><p>在<code>ghci</code>中可以使用<code>:t</code>命令，后接任何合法表达式查阅其类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-string">&#x27;a&#x27;</span> :: Char<br><br>ghci&gt; :t <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-string">&quot;a&quot;</span> :: String<br><br>ghci&gt; :t True<br>True :: Bool<br><br>ghci&gt; :t <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-string">&quot;Hello&quot;</span> :: String<br><br>ghci&gt; :t (True,<span class="hljs-string">&#x27;a&#x27;</span>)<br>(True,<span class="hljs-string">&#x27;a&#x27;</span>) :: (Bool, Char)<br><br>ghci&gt; :t 123<br>123 :: Num p =&gt; p<br><br>ghci&gt; :t 5 == 3<br>5 == 3 :: Bool<br></code></pre></td></tr></table></figure><hr><p><strong>有一个好习惯是在编写函数时，显示写出函数的类型</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">removeNonUpperCase</span> :: [<span class="hljs-type">Char</span>] -&gt; [<span class="hljs-type">Char</span>]<br><span class="hljs-title">removeNonUpperCase</span> st = [ c | c &lt;- st, c `elem` [<span class="hljs-string">&#x27;A&#x27;</span>..<span class="hljs-string">&#x27;Z&#x27;</span>]]<br><br><span class="hljs-title">addThree</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">addThree</span> x y z = x + y + z<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Trust type&quot;</span><br>    print (removeNonUpperCase <span class="hljs-string">&quot;abcDEF&quot;</span>)<br>    print (addThree <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>在这里 :: 读作“它的类型为”，凡是确定的类型，首字母一定是大写的。在这里<code>removeNonUpperCase</code>的类型是<code>[Char] -&gt; [Char]</code>。<br>也就是说接受一个<code>[char]</code>类型作为输入参数，返回一个<code>[char]</code>类型作为输出。在《Haskell趣学指南》中，可能是因为年代原因还有版本原因，字符串输出的<br>结果是<code>[char]</code>而在本人目前这个版本(GHCI 9.0.2) 字符串的类型已经是 <code>String</code>了</p><blockquote><p>String :: *</p><p>Defined in ‘GHC.Base’ (base-4.15.1.0)</p><p>A String is a list of characters. String constants in Haskell are values of type String .</p><p>See Data.List for operations on lists.*</p></blockquote><h2 id="Haskell中常见的类型"><a href="#Haskell中常见的类型" class="headerlink" title="Haskell中常见的类型"></a>Haskell中常见的类型</h2><p>常见的基本类型用于表示数，字符，布尔值的类型</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><ul><li>Int: 整数类型， Int是有界的也可以称作是有符号类型，它的上下限取决于CPU。假设是64位的CPU，它的范围就是 -2^(64-1) ~ 2^(64-1)-1</li><li>Integer: 无符号整数类型， 可以存非常非常大的一个正整数，但是效率不如Int (详见计算机编码的内容)</li><li>Float: 单精度浮点类型</li><li>Double: 双精度浮点类型。精度是Float的两倍，这也意味着占用更大的空间。</li></ul><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ul><li>Char: 表示一个Unicode字符，一个字符由单引号括起</li><li>[Char]: 字符列表，可以当作字符串使用</li><li>String: 字符串类型</li></ul><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型:"></a>布尔类型:</h3><ul><li>Bool: 布尔类型，True和False</li></ul><hr><h2 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h2><p>有一些函数可能需要处理多个类型，或者说多个类型都需要用这个函数进行处理。如果用函数式编程的思想考虑，那么说一个函数的功能可以处理多个类型的参数，这<br>更为贴切一点。比如 head, tail, min, max他们都可以处理多种类型。好奇心一下子就上来了，那么这些函数的类型是什么呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">ghci&gt; :t <span class="hljs-built_in">head</span><br><span class="hljs-built_in">head</span> :: [a] -&gt; a<br><br>ghci&gt; :t min<br>min :: Ord a =&gt; a -&gt; a -&gt; a<br><br>ghci&gt; :t <span class="hljs-built_in">tail</span><br><span class="hljs-built_in">tail</span> :: [a] -&gt; [a]<br></code></pre></td></tr></table></figure><p>我们知道大写开头的才是一个类型，那么这个必不是一个类型，这其实是个类型变量(type variable)，也就会a可以是任何一个类型。作为一个C++老玩家，<br>这一刻觉得这个东西是真得强大，在类型安全的情况下可以简单实现处理多种类型的函数，容易写出通用的函数。</p><p><em>使用了类型变量的函数被称作多态函数(polymorphic function)</em> 我们可以写一个简单的针对于数字的加法函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">plusTwoNumber</span> :: <span class="hljs-type">Num</span> a =&gt; a -&gt; a -&gt; a<br><span class="hljs-title">plusTwoNumber</span> x y = x + y<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (plusTwoNumber <span class="hljs-number">1</span> <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>这里和C++的template模板以及auto比较一下（我个人还是非常喜欢C++的，现在新版的类型推导也是很好用，模板就有点小麻烦了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//类型推导方式</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a + b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//模板方式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Number = std::is_integral_v&lt;T&gt; || std::is_abstract_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;Number T&gt;<br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Haskell - 元组</title>
    <link href="/2023/11/12/Haskell/haskell-tuple/"/>
    <url>/2023/11/12/Haskell/haskell-tuple/</url>
    
    <content type="html"><![CDATA[<h1 id="简单玩一下元组"><a href="#简单玩一下元组" class="headerlink" title="简单玩一下元组"></a>简单玩一下元组</h1><p>有意思的是Haskell中的元组，不仅如同Python中一样可以随便放东西，而且可以当作结构体用<br>如果元组有里面只有两个元素，就可以当作键值对用，真不错啊真不错~</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Haskell"><span class="hljs-title">numberAndNumber</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br><span class="hljs-title">triples</span> = [(a,b,c) | a &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], b &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br><span class="hljs-title">rightTriangles</span> = [(a,b,c) | c &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], a &lt;- [<span class="hljs-number">1</span>..c], b &lt;- [<span class="hljs-number">1</span>..a], a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span> == c^<span class="hljs-number">2</span>]<br><span class="hljs-title">someItem</span> = (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&quot;HelloWorld&quot;</span>, <span class="hljs-type">True</span>)<br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    putStrLn <span class="hljs-string">&quot;Hello, tuple!&quot;</span><br>    print numberAndNumber<br>    print someItem<br>    <span class="hljs-comment">--对于序队可使用</span><br>    print (fst numberAndNumber)<br>    print (snd numberAndNumber)<br><br>    <span class="hljs-comment">--创建序对</span><br>    print (zip [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], odd x] [<span class="hljs-string">&#x27;a&#x27;</span>..<span class="hljs-string">&#x27;z&#x27;</span>])<br>    print (zip [<span class="hljs-number">1</span>..] [<span class="hljs-string">&quot;Python&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;C++&quot;</span>,<span class="hljs-string">&quot;Java&quot;</span>])<br><br>    <span class="hljs-comment">-- 打印0~10之类边长的三角形</span><br>    print rightTriangles<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅学一下Haskell中的列表</title>
    <link href="/2023/11/11/Haskell/haskell-list/"/>
    <url>/2023/11/11/Haskell/haskell-list/</url>
    
    <content type="html"><![CDATA[<h1 id="浅学一下Haskell中的列表"><a href="#浅学一下Haskell中的列表" class="headerlink" title="浅学一下Haskell中的列表"></a>浅学一下Haskell中的列表</h1><blockquote><p>在 Haskell 中，List 就像现实世界中的购物单一样重要。它是最常用的资料结构，并且十分强大，灵活地使用它可以解决很多问题。<br>Haskell中的列表是一种用来存储相同类型的元素的数据结构。列表可以用方括号和逗号来构造，例如[1, 2, 3]是一个包含三个整数的列表。<br>列表也可以用冒号操作符来构造，冒号操作符可以将一个元素添加到一个已有的列表的开头，例如1:[2, 3]等价于[1, 2, 3]。<br>列表还可以用范围来构造，<br>例如[1…10]是一个包含1到10的自然数的列表。列表的长度可以用length函数来计算，列表的元素可以用索引来访问，<br>例如[1, 2, 3] !! 0返回1，[1, 2, 3] !! 1返回2，以此类推。列表还有很多其他的操作，例如拼接，反转，排序，过滤，映射，折叠等。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">odd_numbers</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]<br><span class="hljs-title">even_numbers</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><span class="hljs-title">number_list</span> = [odd_numbers, even_numbers]<br><br><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span><br>    print (odd_numbers ++ even_numbers) <span class="hljs-comment">--拼接两个列表</span><br>    print (<span class="hljs-string">&quot;Hello&quot;</span> ++ <span class="hljs-string">&quot; &quot;</span> ++ <span class="hljs-string">&quot;world!&quot;</span>) <span class="hljs-comment">--拼接两个字符串</span><br>    print ([<span class="hljs-string">&#x27;H&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>] ++ [<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;!&#x27;</span>])<br>    print (number_list)<br>    <br>    <span class="hljs-comment">-- 不可以这样拼接，这是一个列表和一个数字</span><br>    <span class="hljs-comment">-- [1,2,3,4,5] ++ [5]    </span><br><br>    print ( <span class="hljs-number">0</span> : odd_numbers)<br>    print (even_numbers !! <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment">-- 比较列表（会从第一个元素开始比较， 如果相等则比较第二个，直到不同为止）</span><br>    putStrLn <span class="hljs-string">&quot;比较列表&quot;</span><br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &lt; [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])<br>    print ( [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>] == [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>])<br><br>    <span class="hljs-comment">-- 更多的列表操作</span><br>    putStrLn <span class="hljs-string">&quot;更多的列表操作&quot;</span><br>    print (head odd_numbers)<br>    print (init odd_numbers)<br>    print (last odd_numbers)<br>    print (tail even_numbers)<br>    <span class="hljs-comment">-- head [] 无法提取空列表</span><br>    print (length odd_numbers)<br>    print (null odd_numbers)<br>    print (reverse odd_numbers)<br>    print (take <span class="hljs-number">3</span> odd_numbers)<br>    print (drop <span class="hljs-number">0</span> odd_numbers)<br>    print (maximum odd_numbers)<br>    print (minimum even_numbers)<br>    print (sum odd_numbers)<br>    print (product odd_numbers)<br>    print (elem <span class="hljs-number">3</span> odd_numbers)<br>    print (elem <span class="hljs-number">3</span> even_numbers)<br><br>    <span class="hljs-comment">-- 列表区间</span><br>    putStrLn <span class="hljs-string">&quot;列表区间&quot;</span><br>    print [<span class="hljs-number">1</span>..<span class="hljs-number">20</span>]<br>    print [<span class="hljs-string">&#x27;a&#x27;</span> .. <span class="hljs-string">&#x27;z&#x27;</span>]<br>    print [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..<span class="hljs-number">20</span>]<br>    print (take <span class="hljs-number">10</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..])<br>    print (take <span class="hljs-number">10</span> (cycle [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br>    print (take <span class="hljs-number">10</span> (repeat <span class="hljs-number">2</span>))<br>    print (replicate <span class="hljs-number">3</span> <span class="hljs-number">10</span>)<br><br>    <span class="hljs-comment">-- 列表推导式</span><br>    putStrLn <span class="hljs-string">&quot;列表推导式&quot;</span><br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br>    print [x*<span class="hljs-number">10</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>], x*<span class="hljs-number">10</span> &lt;= <span class="hljs-number">50</span>, even x]<br>    <span class="hljs-comment">-- 取1～100中可以被3整出的数</span><br>    print [x | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">100</span>], x `mod` <span class="hljs-number">3</span> == <span class="hljs-number">0</span>]<br>    <span class="hljs-comment">-- 根据number_list中的数，返回是odd还是even</span><br>    print ([ <span class="hljs-keyword">if</span> ((x `mod` <span class="hljs-number">2</span>) == <span class="hljs-number">0</span> ) <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;even&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;odd&quot;</span> | x &lt;- [<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]])<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs bash">[2,4,6,8,10,1,3,5,7,9]<br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br><span class="hljs-string">&quot;Hello world!&quot;</span><br><br>[[2,4,6,8,10],[1,3,5,7,9]]<br><br>[0,2,4,6,8,10]<br><br>7<br><br>比较列表<br><br>True<br><br>True<br><br>True<br><br>True<br><br>True<br><br>更多的列表操作<br><br>2<br><br>[2,4,6,8]<br><br>10<br><br>[3,5,7,9]<br><br>5<br><br>False<br><br>[10,8,6,4,2]<br><br>[2,4,6]<br><br>[2,4,6,8,10]<br><br>10<br><br>1<br><br>30<br><br>3840<br><br>False<br><br>True<br><br>列表区间<br><br>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]<br><br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[2,4,6,8,10,12,14,16,18,20]<br><br>[1,2,3,1,2,3,1,2,3,1]<br><br>[2,2,2,2,2,2,2,2,2,2]<br><br>[10,10,10]<br><br>列表推导式<br><br>[10,20,30,40,50,60,70,80,90,100]<br><br>[20,40]<br><br>[3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99]<br><br>[<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>,<span class="hljs-string">&quot;odd&quot;</span>,<span class="hljs-string">&quot;even&quot;</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好呀 Haskell</title>
    <link href="/2023/11/10/Haskell/hello-haskell/"/>
    <url>/2023/11/10/Haskell/hello-haskell/</url>
    
    <content type="html"><![CDATA[<h1 id="你好呀Haskell"><a href="#你好呀Haskell" class="headerlink" title="你好呀Haskell"></a>你好呀Haskell</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>开始玩耍一个新的编程语言:Haskell, 其实很早就准备学习这个语言，而且也在官网上看了一小段教程，但是有一种云里雾里的感觉，不是没有学懂他的语法，而是还没有理解他的思想，所以一直拖到现在。</p><p>直到在上了大学物理这门课程。感谢岳老师的物理课，虽然我的物理学的并不好，但是对于看待事务本身多了一个新的角度。</p><p>对于之前学习C++,C#, Java…还有别的语言，在解决问题方面更像是在解释这个问题应该怎么做。即使是说使用了面向对象、多态、继承、封装、抽象、接口、泛型、多线程、异常等等，但依然更像是描述这个问题应该怎么做，所以这类语言也成为命令式语言。在命令式语言中执行操作需要给电脑安排一组指令, 随着命令的执行，状态会随之发生改变。</p><p>然而在纯函数式编程语言中，不再是像命令式语言那样描述要做什么，而是通过函数描述问题“是什么”。</p><p>有一个简单的例子说， 在函数式编程语言中，变量一旦赋值，就不能改了，比如  <code>x = 5</code> 这里已规定好了，x的值是5，那么在函数式编程语言中，变量x的值就是5，不能被改变。</p><h2 id="简单的运算"><a href="#简单的运算" class="headerlink" title="简单的运算"></a>简单的运算</h2><blockquote><p><strong>simple-calc.hs</strong></p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">plus</span> x y = x + y<br><span class="hljs-title">substract</span> x y = x - y<br><span class="hljs-title">multiply</span> x y = x * y<br><span class="hljs-title">divide</span> x y = x / y<br><br><span class="hljs-title">and_gate</span> x y = x &amp;&amp; y<br><span class="hljs-title">or_gate</span> x y = x || y<br><span class="hljs-title">not_gate</span> x = not x<br><br><span class="hljs-title">is_equal</span> x y = x == y<br><span class="hljs-title">is_bigger</span> x y = x &gt; y<br><span class="hljs-title">is_smaller</span> x y = x &lt; y<br><span class="hljs-title">is_odd</span> x = mod x <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-title">double_value</span> x = x * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>测试运行</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ghci simple-calc.hs<br><span class="hljs-comment">#GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help</span><br><span class="hljs-comment">#[1 of 1] Compiling Main             ( simple-calc.hs, interpreted )</span><br><span class="hljs-comment">#Ok, one module loaded.</span><br><br>ghci&gt; plus 2 4<br>6<br>ghci&gt; or_gate True False<br>True<br>ghci&gt; double_value 5<br>10<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>小小解释</strong></p></blockquote><p>定义函数: functionName args &#x3D; expression</p><p>执行函数: functionName args </p><p>如果一个函数有两个参数，也可以用这样的方法调用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-number">4</span> `mod` <span class="hljs-number">2</span><br><span class="hljs-title">mod</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> #两者相当<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视C++为一个语言联邦</title>
    <link href="/2023/11/09/Cpp/view-cpp-as-a-federation/"/>
    <url>/2023/11/09/Cpp/view-cpp-as-a-federation/</url>
    
    <content type="html"><![CDATA[<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><p><small>View C++ as a federation of languages</small></p><blockquote><p>一开始，C++只是C加上一些面向对象特性。 C++ 最初的名称 C with Classes 也反应来这个血缘关系 (Effective C++)</p></blockquote><hr><p>随着C++的不断发展，C++的特性越来越多，甚至有些特性是C++独有的。 学了有一段时间的C++， 向他人请教过C++的技巧，也教过人怎么学习C++。 语法以及技巧不是很难去教授的，但是有一段时间令我头疼的是，如何对新手做一个C++的介绍。 因为C++的特性太多， 而且C++的特性之间又存在一定的联系， 导致很难对一个新手进行一个系统的学习。</p><p>直到有一天我再次翻开《Effective C++ 改善程序的55个做法》， 而条款01就是”视C++为一个语言联邦“<br>可以说，C++其实是一个联邦， 联邦由若干个语言组成， 每个语言都具有自己的特性， 这些特性又相互关联。今天的C++是个多重范式的编程语言， 它同时具有面向过程、面向对象、泛型编程、模板、异常处理、标准库、标准模板库等特性。</p><h2 id="语言联邦"><a href="#语言联邦" class="headerlink" title="语言联邦"></a>语言联邦</h2><blockquote><ol><li>Base C language</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ol></blockquote><h3 id="Base-C-language"><a href="#Base-C-language" class="headerlink" title="Base C language"></a>Base C language</h3><p>说到底，C++可以理解是一个C语言的超集， 它包含了C语言的所有特性， 并且还增加了面向对象、泛型编程、异常处理、标准库、标准。许多时候一个问题的C++解法， 往往可以由C语言的解法推导而来，也可以说是较为高级、较为抽象的C语言的解法。</p><h3 id="Object-Oriented-C"><a href="#Object-Oriented-C" class="headerlink" title="Object-Oriented C++"></a>Object-Oriented C++</h3><p>C++语言是面向对象的， 它包含了一些面向对象的特性， 例如： 类、对象、继承、多态、虚函数。<br>这部分也就是C with classes所诉求的， 它也被称为OO C++： classes, inheritance, and polymorphism.</p><h3 id="Template-C"><a href="#Template-C" class="headerlink" title="Template C++"></a>Template C++</h3><p>C++的模板特性， 使得C++可以进行泛型编程， 它使得C++可以进行泛型编程。不严谨的说，模板能够批量生成大量功能相似，但是有些许不同的代码。</p><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>STL是C++标准模板库， 它提供了一组通用的、可复用的算法和数据结构， 例如： 容器、迭代器、算法、函数对象、适配器、分配器、流、字符串、数值等。然而STL有自己独特的办事方式，当你同STL一同工作，你必须遵守他的约定。</p><p>在编程时候， 这些语言联邦中的特性相互之间是相互独立的， 它们之间可以相互组合， 也可以相互分离。 例如，你可以只使用C语言特性完成某些事情，或者在一个类中自己封装一个STL容器， 或者使用STL容器完成一些C++特性。</p><blockquote><p>当你从某个次语言切换到另一个时，导致高效编程守则编程守则要求你改变策略时，不要感到惊讶。因此说C++并不是一个一组带有一组守则一体的语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。<br><strong>C++高效编程守则视状况而变化，取决于你使用C++的哪一个部分</strong></p></blockquote><h2 id="学习C-的流程"><a href="#学习C-的流程" class="headerlink" title="学习C++的流程"></a>学习C++的流程</h2><p>所以说，学习C++本体或许并不一定要掌握C语言，“不必是一个火箭科学家”， 只需要掌握C++的特性， 就可以写出一些有趣的代码。<br>之后在针对C++的特性进行学习， 例如： 模板、STL、异常处理等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>来做一个猜数游戏吧</title>
    <link href="/2023/11/09/Cpp/guessing-number/"/>
    <url>/2023/11/09/Cpp/guessing-number/</url>
    
    <content type="html"><![CDATA[<h1 id="一个猜数小游戏"><a href="#一个猜数小游戏" class="headerlink" title="一个猜数小游戏"></a>一个猜数小游戏</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>首先尝试接受用户的一个输入数字</li><li>生成一个随机数</li><li>进入游戏循环主体中<ol><li>输入数字大于随机数：输出大了，循环继续</li><li>输入数字小于随机数：输入小了，循环继续</li><li>输入数字等于随机数：猜对了，退出循环</li></ol></li><li>结束程序</li></ol><h2 id="程序源码"><a href="#程序源码" class="headerlink" title="程序源码"></a>程序源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// Create random number generator</span><br>    std::random_device random_device;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">generator</span><span class="hljs-params">(random_device())</span></span>;<br>    <span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distribution</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> random_number = <span class="hljs-built_in">distribution</span>(generator);<br>    std::cout &lt;&lt; random_number &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// Create variable to store user&#x27;s guess</span><br>    <span class="hljs-type">int</span> guessing_number&#123;&#125;;<br><br>    <span class="hljs-comment">// Create loop to allow user to guess the random number</span><br>    <span class="hljs-keyword">while</span>(guessing_number != random_number)&#123;<br>        std::cin &gt;&gt; guessing_number;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Guessing number: &quot;</span> &lt;&lt; guessing_number &lt;&lt; std::endl;<br>        <span class="hljs-keyword">if</span>(guessing_number &gt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too high&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(guessing_number &lt; random_number)&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Too low&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;You got it!&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="随机数引擎"><a href="#随机数引擎" class="headerlink" title="随机数引擎"></a>随机数引擎</h3><p><strong>要在C++中使用<random>库生成一个随机数，请按照以下步骤操作：</strong></p><ol><li><p>首先，确保已经包含了<code>&lt;random&gt;</code>头文件。在文件的开头添加以下代码：<code>#include &lt;random&gt;</code></p></li><li><p>接下来，创建一个<code>std::random_device</code>对象，用于生成随机种子。这可以确保每次运行程序时生成的随机数不同。<br><code>std::random_device rd;</code></p></li><li><p>使用<code>std::seed</code>函数，将random_device对象生成的随机种子用于初始化std::mt19937随机数生成器。<br><code>std::mt19937 gen(rd());</code></p></li><li><p>使用<code>std::uniform_int_distribution</code>对象，指定随机数的范围。例如，要生成0到100之间的随机数，可以使用以下代码：<br><code>std::uniform_int_distribution&lt;&gt; distrib(0, 100);</code></p></li><li><p>使用distrib对象生成随机数，并将其存储在变量中。<br><code>const auto random_number = distrib(gen);</code></p></li></ol><p><code>std::mt19937</code>是一个Mersenne Twister伪随机数生成器，它是C++标准库中的一个均匀分布随机数生成器。Mersenne Twister是一种广泛使用的随机数生成器，其性能和分布非常广泛，因此在许多应用中都被广泛使用。</p><p><code>std::mt19937</code>的构造函数接受一个random_device对象作为参数，该对象用于生成随机种子。通过使用random_device，可以确保每次运行程序时生成的随机数不同。</p><p><code>std::mt19937</code>生成的随机数服从均匀分布，即在指定的区间内等概率地取值。</p><h3 id="const-和-auto"><a href="#const-和-auto" class="headerlink" title="const 和 auto"></a>const 和 auto</h3><p>const 关键字用于声明常量，即在程序运行期间其值不能被修改的量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>a = <span class="hljs-number">6</span> <span class="hljs-comment">// 错误，不能修改常量的值</span><br></code></pre></td></tr></table></figure><p>auto 关键字用于声明自动类型变量，即编译器会根据初始值自动推断出变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-comment">//声明一个int类型的a,并且定义值为5</span><br><span class="hljs-keyword">auto</span> b = a; <span class="hljs-comment">// b的类型和a一样，都是int类型</span><br>b = <span class="hljs-number">7</span>;  <span class="hljs-comment">//正确，可以修改b的值</span><br></code></pre></td></tr></table></figure><h3 id="主体判断框架"><a href="#主体判断框架" class="headerlink" title="主体判断框架"></a>主体判断框架</h3><p>使用while循环，在循环体中判断条件是否成立，如果条件成立，则执行循环体，否则退出循环。<br>用户如果输入错误数值，那么就一直循环，直到输入正确为止。<br>用户输入正确，那么就会通过break跳出循环。</p><h3 id="整体解释"><a href="#整体解释" class="headerlink" title="整体解释"></a>整体解释</h3><ol><li>引入所需的头文件，包括<random>（用于随机数生成器）和<iostream>（用于输入输出）。</li><li>在main函数中，定义一个random_device对象，用于生成随机种子。</li><li>定义一个std::mt19937对象，作为随机数生成器，并将random_device对象作为参数传递。</li><li>定义一个std::uniform_int_distribution对象，用于生成1到100之间的随机整数。</li><li>使用distribution对象生成一个随机整数，并将其存储在random_number变量中。</li><li>使用std::cout输出随机数。</li><li>定义一个guessing_number变量，用于存储用户输入的数字。</li><li>使用一个while循环，直到用户猜对数字为止。</li><li>在循环中，使用std::cin从用户输入一个数字，并将其存储在guessing_number变量中。</li><li>使用std::cout输出用户输入的数字。</li><li>如果guessing_number大于random_number，则输出“Too high”。</li><li>如果guessing_number小于random_number，则输出“Too low”。</li><li>如果guessing_number等于random_number，则输出“You got it!”并跳出循环。</li><li>最后，return 0表示程序正常退出。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp-example</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows上mingw C/C++环境搭建</title>
    <link href="/2022/12/11/Cpp/Tips-mingw/"/>
    <url>/2022/12/11/Cpp/Tips-mingw/</url>
    
    <content type="html"><![CDATA[<h1 id="MSYS2和CMake搭建C-x2F-C-环境-参考指南"><a href="#MSYS2和CMake搭建C-x2F-C-环境-参考指南" class="headerlink" title="MSYS2和CMake搭建C&#x2F;C++环境 参考指南"></a>MSYS2和CMake搭建C&#x2F;C++环境 参考指南</h1><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a><strong>准备材料</strong></h2><ul><li>MSYS2 <a href="https://www.msys2.org/">msys2.org</a></li><li>CMake <a href="https://cmake.org/download/">cmake.org</a></li></ul><hr><h2 id="如何下载"><a href="#如何下载" class="headerlink" title="如何下载"></a>如何下载</h2><p><img src="/img/Tips-mingw/1.png" alt="1.png"></p><center><small>点击即可下载，之后莽点下一步即可安装</small></center><p><img src="/img/Tips-mingw/2.png" alt="2.png"></p><center><small>根据系统架构选择对应的版本下载，之后双击安装即可</small></center><hr><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ol><li>打开安装的MSYS2 MSYS， 更换软件源 (选择任意即可)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tuna mirror 清华软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br><span class="hljs-comment"># ustc mirror 中科大软件源</span><br>sed -i <span class="hljs-string">&quot;s#mirror.msys2.org/#mirrors.ustc.edu.cn/msys2/#g&quot;</span> /etc/pacman.d/mirrorlist*<br><br></code></pre></td></tr></table></figure></li></ol><p><img src="/img/Tips-mingw/3.png" alt="3.png"></p><p><img src="/img/Tips-mingw/4.png" alt="4.png"></p><ol start="2"><li>更新一下软件包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Syyu<br></code></pre></td></tr></table></figure>遇到 :: Proceed with installation? [Y&#x2F;n] 的类似问题时输入y即可</li></ol><p><img src="/img/Tips-mingw/5.png" alt="5.png"></p><ol start="3"><li>安装mingw<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S base-devel <br>pacman -S mingw-w64-x86_64-toolchain<br><br></code></pre></td></tr></table></figure>Enter a selection (default&#x3D;all): 输入回车即可<br><img src="/img/Tips-mingw/6.png" alt="6.png"></li></ol><p><strong>4. 配置系统环境</strong></p><p>找到安装目录的mingw64路径<br><img src="/img/Tips-mingw/7.png" alt="7.png"></p><p>计算机右键属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; path -&gt; 你的路径<br><img src="/img/Tips-mingw/8.png" alt="8.png"><br><img src="/img/Tips-mingw/9.png" alt="9.png"><br><img src="/img/Tips-mingw/10.png" alt="10.png"><br><img src="/img/Tips-mingw/11.png" alt="11.png"></p><h2 id="最后验证"><a href="#最后验证" class="headerlink" title="最后验证"></a>最后验证</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">cmake --version<br>gcc -v<br></code></pre></td></tr></table></figure><p><img src="/img/Tips-mingw/12.png" alt="12.png"></p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>MSYS2 是什么？<br><strong>MSYS2</strong> is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.</p><p>It consists of a command line terminal called <a href="https://mintty.github.io/">mintty</a>, bash, version control systems like git and subversion, tools like tar and awk and even build systems like autotools, all based on a modified version of <a href="https://cygwin.com/">Cygwin</a>. Despite some of these central parts being based on Cygwin, the main focus of MSYS2 is to provide a build environment for native Windows software and the Cygwin-using parts are kept at a minimum. MSYS2 provides up-to-date native builds for GCC, mingw-w64, CPython, CMake, Meson, OpenSSL, FFmpeg, Rust, Ruby, just to name a few.</p><p>To provide easy installation of packages and a way to keep them updated it features a package management system called <a href="https://wiki.archlinux.org/index.php/pacman">Pacman</a>, which should be familiar to Arch Linux users. It brings many powerful features such as dependency resolution and simple complete system upgrades, as well as straight-forward and reproducible package building. Our package repository contains <a href="https://packages.msys2.org/base">more than 2600 pre-built packages</a> ready to install.</p><p>For more details see <a href="https://www.msys2.org/docs/what-is-msys2/">‘What is MSYS2?’</a> which also compares MSYS2 to other software distributions and development environments like <a href="https://cygwin.com/">Cygwin</a>, <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>, <a href="https://chocolatey.org/">Chocolatey</a>, <a href="https://scoop.sh/">Scoop</a>, … and <a href="https://www.msys2.org/docs/who-is-using-msys2/">‘Who Is Using MSYS2?’</a> to see which projects are using MSYS2 and what for.</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">MSYSY2 MSYS</td><td align="left">用来管理和安装包的</td></tr><tr><td align="left">MSYSY2 MinGW 32-bit</td><td align="left">编译32位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MinGW 64-bit</td><td align="left">编译64位程序，库链接到msvcrt上</td></tr><tr><td align="left">MSYSY2 MSYS UCRT 64-bit</td><td align="left">编译64位程序，库链接到ucrt上</td></tr></tbody></table><p>CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>Tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/标记和字符集</title>
    <link href="/2022/08/10/Cpp/Tokens%20and%20character%20sets/"/>
    <url>/2022/08/10/Cpp/Tokens%20and%20character%20sets/</url>
    
    <content type="html"><![CDATA[<h1 id="标记和字符集"><a href="#标记和字符集" class="headerlink" title="标记和字符集"></a>标记和字符集</h1><p><small>Tokens and character sets</small></p><p>C++程序文本由Tokens(标记)和空格组成。标记是对编译器有用的 C++ 程序的最小元素。 C++ 分析器可识别以下类型的Token：</p><ul><li>Keywords （关键字）</li><li>Identifiers（标识符）</li><li>Numeric, Boolean and Pointer Literals（数字，布尔值，指针文本）</li><li>String and Character Literals（字符串和字符文本）</li><li>User-Defined Literals（用户定义的文本）</li><li>Operators（运算符&#x2F;操作符）</li><li>Punctuators（标点符号）<blockquote><p><strong>译注：</strong><br>词法分析是编译过程的第一步工作，将字符流转换为单词序列，输出到中间文件中，这个中间文件将会作为语法分析程序的输入，进行下一步工作。<br>token可翻译为标记，是构成源代码的最小单位，从输入字符流中生成标记的过程叫作标记化（ tokenization ），在这个过程中，词法分析器还会对标记进行分类。编译器会从左到右扫描我们的源代码，将其中的字符流分割成一个一个的 token。</p></blockquote></li></ul><h2 id="Token通常用空格进行切分，可以是一个或多个：-空白-水平或垂直制表符-新行-表单源-注释"><a href="#Token通常用空格进行切分，可以是一个或多个：-空白-水平或垂直制表符-新行-表单源-注释" class="headerlink" title="Token通常用空格进行切分，可以是一个或多个：-   空白-   水平或垂直制表符-   新行-   表单源-   注释"></a>Token通常用空格进行切分，可以是一个或多个：<br>-   空白<br>-   水平或垂直制表符<br>-   新行<br>-   表单源<br>-   注释</h2><h2 id="基本源字符集"><a href="#基本源字符集" class="headerlink" title="基本源字符集"></a>基本源字符集</h2><p>C++标准指定了基本源字符集用于源文件中，要表示此集合之外的字符，可以使用通用字符名称指定其他字符。MSVC编译器允许实现其他字符。要表示此集合之外的字符，可以使用通用字符名称指定其他字符。<br><code>a b c d e f g h i j k l m n o p q r s t u v w x y z</code><br><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code><br><code>0 1 2 3 4 5 6 7 8 9</code><br><code>_ &#123; &#125; [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ &quot; &#39;</code></p><p><strong>特用于Microsoft的内容</strong><br>MSVC 包含 $ 字符作为基本源字符集的成员。MSVC 还允许根据文件编码在源文件中使用一组额外的字符。在默认情况下，Visual Studio使用默认代码页存储资源文件。当资源文件使用特定区域或Unicode代码页保存时，MSVC允许你在源代码中使用该代码页的任何字符，但基本源字符集中不允许的控制代码除外。举个例子，您可以通过日文代码页在注释，标识符或字符串中使用日文。MSVC不允许无法转换成为多字节字符和Unicode位码的字符序列。根据编译器选项，并非所有允许的字符都可能出现在标识符中。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a>。</p><blockquote><p><strong>译注</strong><br>在使用visual studio时如果使用WinAPI例如&lt;Windows.h&gt;便可以遇到LPWSTR等字符类型，这是一种宽字符类型也可称作多字节字符。在MSVC中使用L”xxx”即表示用宽字符输出此字符串，也可在项目设置中设置相关配置，设置默认使用宽字符。</p></blockquote><hr><h2 id="通用字符名称"><a href="#通用字符名称" class="headerlink" title="通用字符名称"></a>通用字符名称</h2><p>由于C++程序可以使用比基础字符集更多的字符，您可以使用通用字符名称以可移植的方式指定这些字符。通用字符名称由表示 Unicode 码位的字符序列组成。可以使用两种类型进行表述，使用<code>UNNNNNNNN</code>来代表为 U+NNNNNNNN的unicode位码字符，NNNNNNNN 是八位的十六进制码位数字。使用四位的 <code>\uNNNN</code> 表示形式为 U+0000NNNN 的 Unicode 码位。<br>通用字符名称可用于标识符以及字符串和字符文字。通用字符名称不能被用于表示0xD800-0xDFFF之间之内的代理项码位，编译器会自动生成任何所需的代理项。其他限制适用于可在标识符中使用的通用字符名称。详细信息请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">Identifiers</a> 和 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">String and Character Literals</a>。</p><p><strong>特用于Microsoft的内容</strong><br>Microsoft C++ 编译器可互换地处理通用字符名称形式和文字形式的字符。例如，您可以使用通用字符名称形式声明标识符，并以文字形式使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> \u30AD = <span class="hljs-number">42</span>; <span class="hljs-comment">// \u30AD is &#x27;キ&#x27;</span><br><span class="hljs-keyword">if</span> (キ == <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// \u30AD and キ are the same to the compiler</span><br></code></pre></td></tr></table></figure><p>Windows 剪贴板上的扩展字符的格式特用于应用程序区域设置。 从另一个应用程序剪切这些字符并将其粘贴到你的代码中可能会引入意外的字符编码。 这可能会导致您的代码中出现不知原因的代码错误。我们建议在粘贴扩展的字符之前将源文件编码设置为 Unicode 代码页，以及使用 IME 或字符映射应用生成扩展的字符。</p><hr><h2 id="执行字符集"><a href="#执行字符集" class="headerlink" title="执行字符集"></a>执行字符集</h2><p><em>执行字符集</em> 表示可在编译的程序中显示的字符和字符串。 这些字符集包括源文件中允许的所有字符，以及表示警报、后空、回车符和 null 字符的控制字符。 执行字符集具有特定于区域设置的表示形式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/词法约定</title>
    <link href="/2022/08/10/Cpp/Lexical-conventions/"/>
    <url>/2022/08/10/Cpp/Lexical-conventions/</url>
    
    <content type="html"><![CDATA[<h1 id="词法约定"><a href="#词法约定" class="headerlink" title="词法约定"></a>词法约定</h1><p><small>Lexical conventions</small></p><p>本篇章介绍了C++程序中的基本元素。您会使用到称作“词法元素”或者说“标记”的元素构造完整程序的语句、定义和声明等。 本节将讨论以下词法元素：</p><ul><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/character-sets?view=msvc-170">标记和字符集</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/comments-cpp?view=msvc-170">注释</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/identifiers-cpp?view=msvc-170">标识符</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/keywords-cpp?view=msvc-170">关键字</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/punctuators-cpp?view=msvc-170">标点符号</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/numeric-boolean-and-pointer-literals-cpp?view=msvc-170">数值、布尔和指针文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/string-and-character-literals-cpp?view=msvc-170">字符串和字符文本</a></li><li><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/user-defined-literals-cpp?view=msvc-170">用户定义的文本</a></li></ul><p>有关如何分析 C++ 源文件的详细信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/preprocessor/phases-of-translation?view=msvc-170">转换阶段</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/欢迎回到C++ 现代C++</title>
    <link href="/2022/08/08/Cpp/Welcome%20back%20to%20C++/"/>
    <url>/2022/08/08/Cpp/Welcome%20back%20to%20C++/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎回到C-现代C"><a href="#欢迎回到C-现代C" class="headerlink" title="欢迎回到C++ -现代C++"></a>欢迎回到C++ -现代C++</h1><p><small>Welcome back to C++ - Modern C++</small></p><p>自从它被创建，C++逐渐成为世界上使用最广泛的语言之一。正确编写的 C++ 程序快速、高效。 相对于其他语言，该语言更加灵活：它可以在最高抽象级别上工作，也可以在芯片级（硅级别）上工作。C++ 提供高度优化的标准库。它允许访问低级硬件功能，以最大限度地提高速度并最大限度地减少内存需求。C++可以创建继续所有种类的应用：游戏、设备驱动、HPC、云、桌面、嵌入式和移动应用程序等等。甚至其他编程语言的库和编译器也是用 C++ 编写的。<br>C++的一个原始需求是向下兼容C语言。因此，C++总是允许以C风格编程，使用原始指针、数组、以空字符结尾的数组字符串<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class&#x3D;”hint–top hint–rounded” aria-label&#x3D;”及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code>“&gt;[1]</span></a></sup>以及其他功能。这或许能够拥有高效的表现，但也可以出现报错并让程序出现复杂性。C++的发展强调了一些特性，这些特性大大减少了对使用C风格语法的需要。当您需要他们时，旧式C编程工具仍然存在。但是，在现代 C++ 代码中，您应该越来越少地需要它们。现代 C++ 代码更简单、更安全、更优雅，并且仍然和以往一样快。<br>以下部分概述了现代 C++ 的主要特性。除非另有说明，此处列出的功能在 C++11 及更高版本中可用。在 Microsoft C++ 编译器中，您可以设置 &#x2F;std 编译器选项来指定要用于您的项目的标准版本。</p><h2 id="资源和智能指针"><a href="#资源和智能指针" class="headerlink" title="资源和智能指针"></a>资源和智能指针</h2><p><small>Resource and smart pointers</small><br>C风格编程中的一类主要bug是内存泄漏（确实如此，三天写代码，两天找bug）。泄漏通常是由于对使用 new 分配的内存调用 delete 失败引起的。现代 C++ 强调“资源获取即初始化”(RAII) <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="RAII，Resouce Acquisition Is Initialization:资源获取即初始化">[2]</span></a></sup>原则。 其理念很简单。 资源（堆内存、文件句柄、套接字等）应由对象“拥有”。 该对象在其构造函数中创建或接收新分配的资源，并在其析构函数中将此资源删除。 RAII 原则可确保当所属对象超出范围时，所有资源都能正确返回到操作系统。<br>为了支持对简单采用RAII的原则，C++基本库（STL）提供了三个智能指针类型: <code>std::unique_ptr</code>、<code>std::shared_ptr</code>以及<code>std::weak_ptr</code>。智能指针拥有申请和删除内存的控制句柄（智能指针处理它所拥有的内存的分配和删除）<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。">[3]</span></a></sup>。下面的示例演示了一个类，其中包含一个数组成员，该成员是在调用 <code>make_unique()</code> 时在堆上分配的。 对和的 <strong><code>new</code></strong> 调用 <strong><code>delete</code></strong> 由 <code>unique_ptr</code> 类封装。 当 <code>widget</code> 对象超出范围时，将调用 unique_ptr 析构函数，此函数将释放为数组分配的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">widget</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">widget</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> size) &#123; data = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(size); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionUsingWidget</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">widget <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;   <span class="hljs-comment">// lifetime automatically tied to enclosing scope</span><br>                <span class="hljs-comment">// constructs w, including the w.data gadget member</span><br>    <span class="hljs-comment">// ...</span><br>    w.<span class="hljs-built_in">do_something</span>();<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-comment">// automatic destruction and deallocation for w and w.data</span><br></code></pre></td></tr></table></figure><p>请尽可能使用智能指针管理堆内存（确实如此，如果没有追求极致效率的需求，使用智能指针是最方便且安全的）。 如果必须 <strong><code>new</code></strong> 显式使用和 <strong><code>delete</code></strong> 运算符，请遵循 RAII 原则。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170">对象生存期和资源管理 (RAII)</a>。</p><h2 id="std-string-和-std-string-view"><a href="#std-string-和-std-string-view" class="headerlink" title="std::string 和 std::string_view"></a>std::string 和 std::string_view</h2><p><small>std::string and std::string_view</small><br>C风格字符串是错误产生的另一个重要来源。通过使用<code>std::string</code> 和 <code>std::wstring</code>，您可以排除几乎所有和C风格字符串有联系的错误。此外，你还可以通过其成员方法获得更多字符串操作上的便利，例如搜索，追加，前缀等。两者都针对速度进行了高度优化<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》">[4]</span></a></sup>。将字符串传递给只需要只读访问权限的函数时，在 C++17 中，您可以使用 std::string_view 以获得更大的性能优势。</p><h2 id="std-vector向量和其他标准库容器"><a href="#std-vector向量和其他标准库容器" class="headerlink" title="std::vector向量和其他标准库容器"></a>std::vector向量和其他标准库容器</h2><p><small>std::string and other Standard Library containers</small><br>标准库容器都遵循 RAII 原则。 它们为安全遍历元素提供迭代器。 此外，它们对性能进行了高度优化，并且已充分测试正确性。 通过使用这些容器，可以消除自定义数据结构中可能引入的 bug 或低效问题。 使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/vector-class?view=msvc-170"><code>vector</code></a> 替代原始数组，来作为 C++ 中的序列容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;string&gt; apples;<br>apples.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Granny Smith&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用 map（而不是 unordered_map），作为默认关联容器。 对于退化和多案例，使用 set、multimap 和 multiset。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string, string&gt; apple_color;<br><span class="hljs-comment">// ...</span><br>apple_color[<span class="hljs-string">&quot;Granny Smith&quot;</span>] = <span class="hljs-string">&quot;Green&quot;</span>;<br></code></pre></td></tr></table></figure><p>需要进行性能优化时，请考虑以下用法：</p><ul><li>例如当重要的数据被嵌入时，将std::array类型作为类成员。</li><li>使用无序的关联容器，例如 unordered_map。 它们的每个元素的开销较低，并且具有固定时间查找功能，但正确高效地使用它们的难度更高。</li><li>使用std::vector时需要排序。有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/algorithms?view=msvc-170">算法</a>。<br>不要使用 C 风格的数组。对于需要直接访问数据的旧 API，请使用访问器方法，例如 <code>f(vec.data(), vec.size());</code> 有关容器的更多信息，请参阅 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/stl-containers?view=msvc-170">C++ 标准库容器</a>。</li></ul><h2 id="标准库算法"><a href="#标准库算法" class="headerlink" title="标准库算法"></a>标准库算法</h2><p>在假设需要为程序编写自定义算法之前，请首先查阅C++ 标准库中的算法。 标准库包含许多常见操作（如搜索、排序、筛选和随机化）的算法分类，且这些分类的算法库还在不断增加。 譬如&lt;math&gt;中的内容涵盖的很广泛。 自 C++17 起，变提供了许多算法的并行版本。<br>这里列举以下内容，比较重要。</p><ul><li><code>for_each</code>：默认遍历算法（基于范围的 for 循环）。</li><li><code>transform</code>：用于容器元素的非就地修改<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="`std::stransform` 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。">[5]</span></a></sup>。</li><li><code>find_if</code>：默认搜索算法。</li><li><code>sort</code>,<code>lower_bound</code>：排序、在一个范围内找到搜索元素的下标。以及其他排序和搜索算法。</li></ul><p>如果要写一个比较函数，可以使用lambda表达式以及’&lt;’符号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> comp = [](<span class="hljs-type">const</span> widget&amp; w1, <span class="hljs-type">const</span> widget&amp; w2)<br>     &#123; <span class="hljs-keyword">return</span> w1.<span class="hljs-built_in">weight</span>() &lt; w2.<span class="hljs-built_in">weight</span>(); &#125;<br><br><span class="hljs-built_in">sort</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), comp );<br><br><span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">lower_bound</span>( v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), widget&#123;<span class="hljs-number">0</span>&#125;, comp );<br></code></pre></td></tr></table></figure><h2 id="使用auto关键字代替显示类型名称"><a href="#使用auto关键字代替显示类型名称" class="headerlink" title="使用auto关键字代替显示类型名称"></a>使用auto关键字代替显示类型名称</h2><p><small>auto instread of explicit type names</small><br>C++11引入了auto关键字，以便在变量、函数和模板的声明。auto关键字会指示编译器推导对象的类型，这样您即可无需显示键入。当对象是嵌套模板时，使用auto进行声明尤其有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;<span class="hljs-type">int</span>,list&lt;string&gt;&gt;::iterator i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// C-style</span><br><span class="hljs-keyword">auto</span> i = m.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// modern C++</span><br></code></pre></td></tr></table></figure><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><p><small>Range-based for loops</small><br>对数组和容器的C风格迭代容易出现索引错误，且重复的键入过程单调乏味。要消除这些错误并使您的代码更具可读性，请使用基于范围的 for 循环以及标准库容器和原始数组。有关详细信息，请参阅请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170">基于范围的</a> (<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)%E8%AF%AD%E5%8F%A5%E3%80%82">https://docs.microsoft.com/zh-cn/cpp/cpp/range-based-for-statement-cpp?view=msvc-170)语句。</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br>    <span class="hljs-comment">// C-style</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>        std::cout &lt;&lt; v[i];<br>    &#125;<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : v)&#123;<br>        std::cout &lt;&lt; num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>译注：<br>使用for_each虽然可以极大的提高for效率，但是如果在处理极大数据时或极长文本时请谨慎使用。因为其会将内容复制一份进行遍历。</p><h2 id="用-constexpr-表达式替代宏"><a href="#用-constexpr-表达式替代宏" class="headerlink" title="用 constexpr 表达式替代宏"></a>用 <code>constexpr</code> 表达式替代宏</h2><p>C 和 C++ 中的宏是在编译前由预处理器处理的一种标记。在编译代码之前，编译器会将使用宏定义的地方替换成宏所定义的值。C 样式编程通常使用宏来定义编译时常量值。 但宏容易出错且难以调试。 在现代 C++ 中，应优先使用 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/constexpr-cpp?view=msvc-170"><code>constexpr</code></a> 变量定义编译时常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 10 <span class="hljs-comment">// C-style</span></span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> size = <span class="hljs-number">10</span>; <span class="hljs-comment">// modern C++</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> number = <span class="hljs-number">114514</span>;<br><br></code></pre></td></tr></table></figure><h2 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h2><p>在现代 C++ 中，可以使用任何类型的括号初始化。 在初始化数组、矢量或其他容器时，这种初始化形式会非常方便。在下面的这个例子中声明了一个类S，三个均为std::vetor(向量)类型的变量v1,v1,v3并用不同方式进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span><br>&#123;<br>    std::string name;<br>    <span class="hljs-type">float</span> num;<br>    <span class="hljs-built_in">S</span>(std::string s, <span class="hljs-type">float</span> f) : <span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">num</span>(f) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// C-style initialization</span><br>    std::vector&lt;S&gt; v;<br>    <span class="hljs-function">S <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>)</span></span>;<br>    <span class="hljs-function">S <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>)</span></span>;<br><br>    v.<span class="hljs-built_in">push_back</span>(s1);<br>    v.<span class="hljs-built_in">push_back</span>(s2);<br>    v.<span class="hljs-built_in">push_back</span>(s3);<br><br>    <span class="hljs-comment">// Modern C++:</span><br>    std::vector&lt;S&gt; v2 &#123;s1, s2, s3&#125;;<br><br>    <span class="hljs-comment">// or...</span><br>    std::vector&lt;S&gt; v3&#123; &#123;<span class="hljs-string">&quot;Norah&quot;</span>, <span class="hljs-number">2.7</span>&#125;, &#123;<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">3.5</span>&#125;, &#123;<span class="hljs-string">&quot;Jeri&quot;</span>, <span class="hljs-number">85.9</span>&#125; &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>若要了解详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/initializing-classes-and-structs-without-constructors-cpp?view=msvc-170">括号初始化</a>。</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>现代 C++ 提供了移动语义，此功能可以避免进行不必要的内存复制。 在此语言的早期版本中，在某些情况下无法避免复制。 移动操作会将资源的所有权从一个对象转移到下一个对象，而不必再进行复制。 一些类拥有堆内存、文件句柄等资源。 实现资源所属的类时，可以定义此类的移动构造函数和移动赋值运算符。 在解析重载期间，如果不需要进行复制，编译器会选择这些特殊成员。 如果定义了移动构造函数，则标准库容器类型会在对象中调用此函数。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">移动构造函数和移动赋值运算符 (C++)</a>。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>在使用C语法编程中，一个函数可以通过返回函数指针的方式传递给另一个函数，这不方便位于和理解。它们引用的函数可能在源代码的其他地方定义，而不是从调用它的位置定义的。而且他们不是类型安全的。现代C++提供了对函数对象、类的运算符重写，从而使它们可以像函数一样进行调用。创建函数对象的最简便方法是使用内联 <a href="https://docs.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">lambda 表达式</a>。 下面的示例演示如何使用 lambda 表达式传递函数对象，然后由 <code>for_each</code> 函数在vector的每个元素中调用此函数对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">find_if</span>(<span class="hljs-built_in">begin</span>(v), <span class="hljs-built_in">end</span>(v), [=](<span class="hljs-type">int</span> i) &#123; <br>    <span class="hljs-keyword">return</span> i &gt; x &amp;&amp; i &lt; y; <br>    &#125;<br>    );<br></code></pre></td></tr></table></figure><p>Lambda表达式的形式为<code>[]()&#123;&#125;</code>，这里的是<code>[=](int i) &#123; return i &gt; x &amp;&amp; i &lt; y; &#125;</code>。此函数有一个int类型的形参，并返回一个bool类型的值，指示该参数是否大于 <code>x</code> 且小于 <code>y</code>。这里使用的x,y是lambda之前声明的两个变量。行为上看似是[&#x3D;]接受了上文的变量，实际上是lambda接受了值的副本。有关更详细的内容请看相关专题。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><small>Exceptions</small><br>现代 c + + 强调异常，而不是错误代码，作为报告和处理错误条件的最佳方式。 有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-170">现代 C++ 处理异常和错误的最佳做法</a>。</p><h2 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h2><p>对线程间通信机制使用 C++ 标准库 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/atomic-structure?view=msvc-170"><code>std::atomic</code></a> 结构和相关类型。</p><h2 id="std-variant-C-17"><a href="#std-variant-C-17" class="headerlink" title="std::variant(C++17)"></a>std::variant(C++17)</h2><p>在以C风格编程程序时通过使用联合体（共用体）使不同类型的成员占据同一个内存位置而达到节约内存的目的。但这并不是安全的，并容易导致编译错误。 C++17 引入了更加安全可靠的 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-class?view=msvc-170"><code>std::variant</code></a> 类，来作为联合体（共用体）的替代项。可以使用 <a href="https://docs.microsoft.com/zh-cn/cpp/standard-library/variant-functions?view=msvc-170#visit"><code>std::visit</code></a> 函数以类型安全的方式访问 <code>variant</code> 类型的成员。</p><hr><p><strong>译者有话说</strong><br>本页的上述的示例代码为微软参考手册的简单案例，本人会在下方附上个人理解的完整代码。此部分代码也可以移步至<a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp: Code example of Microsoft modern C + + vs2022 translation (github.com)</a>进行阅览，请原谅本人代码水平不精，谢谢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>() = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string &amp;name, <span class="hljs-type">const</span> std::string &amp;id)<br>        : <span class="hljs-built_in">stu_name</span>(name), <span class="hljs-built_in">stu_id</span>(id)&#123;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_name;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_id;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">GetCollege</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu_college;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetCollage</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string college)</span> </span>&#123;<br>        stu_college = college;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> std::string stu_name;<br>    <span class="hljs-type">const</span> std::string stu_id;<br>    std::string stu_college&#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> student = std::<span class="hljs-built_in">make_unique</span>&lt;Student&gt;(<span class="hljs-string">&quot;田所浩二&quot;</span>, <span class="hljs-string">&quot;114514&quot;</span>);<br>    std::cout &lt;&lt; student-&gt;<span class="hljs-built_in">GetId</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; (*student).<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">auto</span> ptr_stu = student.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// if smart pointer is released, this raw pointer will be null</span><br>    ptr_stu-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;computr network&quot;</span>);<br>    std::cout &lt;&lt; ptr_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">auto</span> share_stu = std::<span class="hljs-built_in">make_shared</span>&lt;Student&gt;(<span class="hljs-string">&quot;114&quot;</span>, <span class="hljs-string">&quot;1919810&quot;</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">share_stu_1</span><span class="hljs-params">(share_stu)</span></span>;<br>    share_stu_1-&gt;<span class="hljs-built_in">SetCollage</span>(<span class="hljs-string">&quot;communication engineering&quot;</span>);<br>    std::cout &lt;&lt; share_stu-&gt;<span class="hljs-built_in">GetCollege</span>() &lt;&lt; std::endl;<br>&#125;<br><br>  <br><br><span class="hljs-comment">// make_unique (C++14) creates a unique poniter that manages a new object</span><br><span class="hljs-comment">// make_unique_for_overwrite (C++20)</span><br></code></pre></td></tr></table></figure><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>及用数组存储的字符串，以 <code>\0</code>结束。例<code>const char *str = &quot;Hello World\0&quot;;</code><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>RAII，Resouce Acquisition Is Initialization:资源获取即初始化<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>智能指针说白了就是一个模板类来控制一个原始指针的内存操作。此部分可以翻阅其他书籍。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>但实际上std::string 在某些方面使用性能并不优越，比如复制字符串。这里可参阅《C++性能优化指南》<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><code>std::stransform</code> 不保证按顺序适用unary_op或binary_op若要按顺序将函数应用于序列或应用修改序列元素的函数(在指定的范围内应用于给定的操作，并将结果存储在指定的另一个范围内)。<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModernC++/C++语言参考</title>
    <link href="/2022/08/07/Cpp/C++%20Language%20Reference/"/>
    <url>/2022/08/07/Cpp/C++%20Language%20Reference/</url>
    
    <content type="html"><![CDATA[<p><strong>前言赘叙</strong><br>本系列文档是对于微软文档《Modern C++ vs2022》进行学习的些许笔记以及简单翻译。个人之力翻译可能并不标准，还望海涵，也请多多指点。敝人也尝试通过这次机会向大家分享，也希望个人也能在代码造诣上得到提高。为了能够帮助理解，本人也创建了一个仓库，会在接下来使用代码的地方进行插入，当然也欢迎直接阅读示例demo</p><p>点击此处可浏览仓库 <a href="https://github.com/CvRain/oh-modern-cpp">CvRain&#x2F;oh-modern-cpp</a><br>点击此处可浏览原文 <a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-language-reference?view=msvc-170">C++ Language Reference | Microsoft Docs</a></p><hr><h1 id="C-语言参考"><a href="#C-语言参考" class="headerlink" title="C++语言参考"></a>C++语言参考</h1><p><em>C++ Language Reference</em></p><p>本参考说明了在 Microsoft C++ 编译器中实现的 C++ 编程语言。该组织基于 Margaret Ellis 和 Bjarne Stroustrup 的 The Annotated C++ Reference Manual 以及 ANSI&#x2F;ISO C++ 国际标准 (ISO&#x2F;IEC FDIS 14882)。包括 Microsoft 特定的 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果">[1]</span></a></sup>C++ 语言功能实现。<br>有关现代 C++ 编程实践的概述，请参阅《<a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>》<br>请参阅下表以快速找到关键字或运算符：</p><ul><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170">C++ Keywords</a> （C++关键字）</li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">C++ Operators</a>（C++操作符）</li></ul><h1 id="在这个部分"><a href="#在这个部分" class="headerlink" title="在这个部分"></a>在这个部分</h1><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lexical-conventions?view=msvc-170">Lexical Conventions</a>  词汇约定<br>C++程序的基本词法元素：预定义字符（标记）、注释、操作符、关键字、标点符号、字符串。此外还有：文件转译（文件操作）、运算符优先级&#x2F;关联性。</p><blockquote><p>Fundamental lexical elements of a C++ program: tokens, comments, operators, keywords, punctuators, literals. Also, file translation, operator precedence&#x2F;associativity.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/basic-concepts-cpp?view=msvc-170">Basic Concepts</a>  基本概念<br>范围、链接、程序的启动和终止、存储类和类型。</p><blockquote><p>Scope, linkage, program startup and termination, storage classes, and types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/fundamental-types-cpp?view=msvc-170">Built-in types</a> 内置类型<br>C++编译器中内置的基本类型及其取值范围。</p><blockquote><p>The fundamental types that are built into the C++ compiler and their value ranges.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/standard-conversions?view=msvc-170">Standard Conversions</a>  标准转换<br>内置类型之间的类型转换。此外，指针、引用和指向成员的类型之间的算术转换和转换。</p><blockquote><p>Type conversions between built-in types. Also, arithmetic conversions and conversions among pointer, reference, and pointer-to-member types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/declarations-and-definitions-cpp?view=msvc-170">Declarations and definitions</a> 声明和定义<br>声明和定义变量、类型和函数。</p><blockquote><p>Declaring and defining variables, types and functions.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170">Operators, Precedence and Associativity</a><br>运算符、优先级和关联性<br>C++中的运算符。</p><blockquote><p>The operators in C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/expressions-cpp?view=msvc-170">Expressions</a>  表达式<br>表达式的类型、表达式的语义、运算符的参考主题、强制转换和强制转换运算符、运行时类型信息。</p><blockquote><p>Types of expressions, semantics of expressions, reference topics on operators, casting and casting operators, run-time type information.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">Lambda Expressions</a>  Lambda表达式<br>一种隐式定义函数对象类并构造该类类型的函数对象的编程技术。</p><blockquote><p>A programming technique that implicitly defines a function object class and constructs a function object of that class type.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/statements-cpp?view=msvc-170">Statements</a>  语句<br>表达式、null空值、复合语句、选择、迭代、跳转和声明语句。</p><blockquote><p>Expression, null, compound, selection, iteration, jump, and declaration statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/classes-and-structs-cpp?view=msvc-170">Classes and structs</a>  类和结构体<br>对于类、结构体和共用体的介绍。此外也有，成员函数、特殊成员函数、数据成员、位字段、this指针，嵌套类。</p><blockquote><p>Introduction to classes, structures, and unions. Also, member functions, special member functions, data members, bit fields, <strong><code>this</code></strong> pointer, nested classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/unions?view=msvc-170">Unions</a>  联合体<br>用户定义类型，其中所有成员共享同一内存位置。</p><blockquote><p>User-defined types in which all members share the same memory location.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/inheritance-cpp?view=msvc-170">Derived Classes</a>  派生类<br>单个和多个继承、虚函数、多继承、抽象类、范围规则。 此外，还有__super和__interface关键字。</p><blockquote><p>Single and multiple inheritance, <strong><code>virtual</code></strong> functions, multiple base classes, <strong>abstract</strong> classes, scope rules. Also, the <strong><code>__super</code></strong> and <strong><code>__interface</code></strong> keywords.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/member-access-control-cpp?view=msvc-170">Member-Access Control</a>  成员访问控制<br>控制对类成员的访问： public、 private关键字和 protected 关键字。 友元函数和友元类。</p><blockquote><p>Controlling access to class members: <strong><code>public</code></strong>, <strong><code>private</code></strong>, and <strong><code>protected</code></strong> keywords. Friend functions and classes.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/operator-overloading?view=msvc-170">Overloading</a>  重载<br>重载运算符，对运算符重载的规则。</p><blockquote><p>Overloaded operators, rules for operator overloading.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/exception-handling-in-visual-cpp?view=msvc-170">Exception Handling</a>  异常处理<br>C++ 异常处理、结构化异常处理 (SEH)、用于编写异常处理语句的关键字。</p><blockquote><p>C++ exception handling, structured exception handling (SEH), keywords used in writing exception handling statements.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/assertion-and-user-supplied-messages-cpp?view=msvc-170">Assertion and User-Supplied Messages</a>  断言和User-Supplied消息<br>#error 指令， static_assert 关键字， assert 宏。</p><blockquote><p><code>#error</code> directive, the <strong><code>static_assert</code></strong> keyword, the <code>assert</code> macro.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/templates-cpp?view=msvc-170">Templates</a>  模板<br>模板规范、函数模板、类模板、typename 关键字、模板对比于宏定义、模板和智能指针。</p><blockquote><p>Template specifications, function templates, class templates, <strong><code>typename</code></strong> keyword, templates vs. macros, templates and smart pointers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/event-handling?view=msvc-170">Event Handling</a>  事件处理<br>定义事件和事件处理程序</p><blockquote><p>Declaring events and event handlers.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-specific-modifiers?view=msvc-170">Microsoft-Specific Modifiers</a>  独属于微软(msvc)的修饰符<br>Microsoft C++ 专用修饰符。 内存寻址、调用约定、naked函数、扩展存储类属性 (__declspec) 。 __w64</p><blockquote><p>Modifiers specific to Microsoft C++. Memory addressing, calling conventions, <strong><code>naked</code></strong> functions, extended storage-class attributes (<strong><code>__declspec</code></strong>), <strong><code>__w64</code></strong>.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/assembler/inline/inline-assembler?view=msvc-170">Inline Assembler</a>  内联汇编程序<br>在__asm块中使用汇编语言和C++。</p><blockquote><p>Using assembly language and C++ in <strong><code>__asm</code></strong> blocks.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/compiler-com-support?view=msvc-170">Compiler COM Support</a>  编译器对COM的支持<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。">[2]</span></a></sup><br>有关用于支持 COM 类型的 Microsoft 专用类和全局函数的参考。</p><blockquote><p>A reference to Microsoft-specific classes and global functions used to support COM types.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/microsoft-extensions?view=msvc-170">Microsoft Extensions</a>  Microsoft的拓展<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等">[3]</span></a></sup><br>Microsoft微软对C++进行的扩展</p><blockquote><p>Microsoft extensions to C++.</p></blockquote><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/nonstandard-behavior?view=msvc-170">Nonstandard Behavior</a>  非标准行为<br>有关Microsoft C++编译器的非标准行为的信息。<br>Information about nonstandard behavior of the Microsoft C++ compiler.</p><hr><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170">Welcome Back to C++</a>  欢迎回到C++<br>一篇现代C + +编程实践概述，指引编写安全、正确、高效的程序。</p><blockquote><p>An overview of modern C++ programming practices for writing safe, correct and efficient programs.</p></blockquote><hr> <section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>因为由微软实现，所以部分代码有着其平台的独占性，也可以理解为部分函数的特性通过msvc会获得不同的效果<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Microsoft C++ 编译器可以直接读取组件对象模型 (COM) 类型库，并将内容转换为可包含在编译中的 C++ 源代码。 语言扩展可用于促进桌面应用的客户端上的 COM 编程。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>微软对C++制定了许多扩展以及好用的库和框架例如，WIN_API, MFC, Win32等<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Modern-cpp</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一篇闲言碎语</title>
    <link href="/2022/08/07/another-gossip/"/>
    <url>/2022/08/07/another-gossip/</url>
    
    <content type="html"><![CDATA[<h1 id="另一篇闲言碎语"><a href="#另一篇闲言碎语" class="headerlink" title="另一篇闲言碎语"></a>另一篇闲言碎语</h1><p>对于hexo我的技术力实在是太低了，于是乎就在hexo的主题库中找了一个–“anatole”非常的不错。其中一个巨大的原因是因为我发现我忘记怎么设计网页了，回忆以前还知道玩玩什么jqury,boostrapl，如果回到18年甚至可以手撸css,js。奈何现在是一位大专两年级的学生，除了每顿猛造两碗饭，其他的都忘记了。<br>所以坦白一下我是如何做了这个稀烂的主页的。</p><hr><p>首先用日常是开了一个科学上网，用winget把nodejs给整上，迅速的安装一波hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>npm install hexo<br>hexo init &lt;blog-name&gt;<br>cd &lt;blog-name&gt;<br>npm install<br></code></pre></td></tr></table></figure><h2 id="对了，如果不能直接用hexo指令的话可以配置一下1-npx-hexo-lt-command-gt-2-将-Hexo-所在的目录下的-node-modules-添加到环境变量之中即可直接使用-96-hexo"><a href="#对了，如果不能直接用hexo指令的话可以配置一下1-npx-hexo-lt-command-gt-2-将-Hexo-所在的目录下的-node-modules-添加到环境变量之中即可直接使用-96-hexo" class="headerlink" title="对了，如果不能直接用hexo指令的话可以配置一下1.  npx hexo &lt;command&gt;2.  将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 &#96;hexo "></a>对了，如果不能直接用hexo指令的话可以配置一下<br>1.  <code>npx hexo &lt;command&gt;</code><br>2.  将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 &#96;hexo <command><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27; &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure></h2><p>上述步骤完成后，就是抄一个主题下来。感谢hexo设计的很简单，让我一下子就上手了。<br>把主题文件放到themes下就可以了，比如我的是<strong>E:\blog\themes\anatole</strong><br><small><em>什么？如何安装主题，当然是点一个然后 <code>git clone</code>下来哦</em></small></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/Ben02/hexo-theme-Anatole.git themes/anatole<br>cd anatole<br>git pull<br>npm install --save hexo-render-pug hexo-generator-archive hexo-generator-tag hexo-generator-index hexo-generator-category<br></code></pre></td></tr></table></figure><p>然后在_config.yml里填写一个特殊的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">archive_generator:</span><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>每一个主题的安装都不尽相同，所以得按照自己挑选的主题来进行配置。</strong></p><hr><p>按照主题的官网wiki配置一通以后，发现下面那个小蓝鸟，小粪坑不知道怎么关闭2333。在尝试去ejs中修改的我也放弃了。对了，这里要坦白我学会怎么修改favicon以及logo，于是就去主题中修改了源图标[手动狗头]。好了，今日吹水到此结束，明日（或许）开始认真更新一些东西。<br>顺便在下面贴上使用的_config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Hexo Configuration</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/configuration.html</span><br><br><span class="hljs-comment">## Source: https://github.com/hexojs/hexo/</span><br><br>  <br><br><span class="hljs-comment"># Site</span><br><br><span class="hljs-attr">title:</span> <span class="hljs-string">CvRaindays</span><br><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">std::shared_ptr&lt;Blog&gt;</span> <span class="hljs-string">CvRain(this);</span><br><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">keywords:</span> <span class="hljs-string">C,C++,Linux</span><br><br><span class="hljs-attr">author:</span> <span class="hljs-string">CvRaindays,cvraindays@outlook.com</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-cn</span><br><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># URL</span><br><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://example.com</span><br><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><br><span class="hljs-attr">permalink_defaults:</span><br><br><span class="hljs-attr">pretty_urls:</span><br><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><br>  <br><br><span class="hljs-comment"># Directory</span><br><br><span class="hljs-attr">source_dir:</span> <span class="hljs-string">source</span><br><br><span class="hljs-attr">public_dir:</span> <span class="hljs-string">public</span><br><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><br><span class="hljs-attr">code_dir:</span> <span class="hljs-string">downloads/code</span><br><br><span class="hljs-attr">i18n_dir:</span> <span class="hljs-string">:lang</span><br><br><span class="hljs-attr">skip_render:</span> <span class="hljs-string">README.md</span><br><br>  <br><br><span class="hljs-comment"># Writing</span><br><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><br><span class="hljs-attr">external_link:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">highlight:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">prismjs:</span><br><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Home page setting</span><br><br><span class="hljs-comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><br><span class="hljs-comment"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><br><span class="hljs-comment"># order_by: Posts order. (Order by date descending by default)</span><br><br><span class="hljs-attr">index_generator:</span><br><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span><br><br>  <br><br><span class="hljs-comment"># Category &amp; Tag</span><br><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><br><span class="hljs-attr">category_map:</span><br><br><span class="hljs-attr">tag_map:</span><br><br>  <br><br><span class="hljs-comment"># Metadata elements</span><br><br><span class="hljs-comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><br><span class="hljs-attr">meta_generator:</span> <span class="hljs-literal">true</span><br><br>  <br><br><span class="hljs-comment"># Date / Time format</span><br><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-MM-DD</span><br><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">HH:mm:ss</span><br><br><span class="hljs-comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><br><span class="hljs-attr">updated_option:</span> <span class="hljs-string">&#x27;mtime&#x27;</span><br><br>  <br><br><span class="hljs-comment"># Pagination</span><br><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br>  <br><br><span class="hljs-comment"># Include / Exclude file(s)</span><br><br><span class="hljs-comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><br><span class="hljs-attr">include:</span><br><br><span class="hljs-attr">exclude:</span><br><br><span class="hljs-attr">ignore:</span><br><br>  <br><br><span class="hljs-comment"># Extensions</span><br><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><br><span class="hljs-attr">theme:</span> <span class="hljs-string">anatole</span><br><br>  <br><br><span class="hljs-comment"># Deployment</span><br><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><br>  <br><br><span class="hljs-attr">deploy:</span><br><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/CvRain/cvrain.github.io.git</span><br><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br><br>  <br><br><span class="hljs-attr">archive_generator:</span><br><br>  <span class="hljs-attr">per_page:</span> <span class="hljs-number">0</span>  <br><br>  <span class="hljs-attr">yearly:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-attr">monthly:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-attr">daily:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好世界！</title>
    <link href="/2022/08/07/hello-world/"/>
    <url>/2022/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><p>经过了三个小时的辛苦劳作，鱼师傅成功摸出来一个HelloWorld!<br>第一篇blog，准备先写个小记作为一个段子乐呵乐呵。 </p><hr><h2 id="一盘饺子"><a href="#一盘饺子" class="headerlink" title="一盘饺子"></a>一盘饺子</h2><p>属实是有了一壶好醋，也是可怜了我的Surface Go2，跟着我并没有享受到作为“高端”电子设备的万千宠爱，反而是被不断刷机。不是因为购买的是丐版，而且其配置加上Windows11略有拉跨。不得不研究如何在上面刷一套Linux操作系统用来满足个人需求，提高工作效率。具体的相关情况请看后文内容，本篇小作文仅作为一个引子。<br>说回来，Go系列的刷系统确实难受，翻烂了各种帖子，总算是总结出一套目前看最完善的装系统经验。回味过来笔者果然是无聊透顶，可能坚持捣鼓刷系统的也没有多少了吧，当然也可以和个人性格以及家庭有些许关系。<br>准备录制一个视频和大家分享分析，经过一晚上的辗转反侧来看，还是需要写个什么东西使得叙述更完整一点。那就不如自己搞个博客吧！或许也只会发少量的东西，不过说不好也不好说。</p><h2 id="做些什么"><a href="#做些什么" class="headerlink" title="做些什么"></a>做些什么</h2><p>就目前看来，或许会更新一些个人在编程上的小经验，不过和其他奆佬比起来就是腐草荧光了。未来可能尝试自己做一个Hexo的主题（不过感觉60%要泡汤了），然后写一点关于模组教程的小作文。嗯，似乎没了。</p><h2 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h2><p>感觉自己越来越不会说话了，文采也不太行了。还没到老年却也喜欢絮絮叨叨一番。身心格外的疲倦，也不知道为什么，还是按时吃药吧，或许问题不大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gossip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/img/java-example/example-4/"/>
    <url>/1970/01/01/img/java-example/example-4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
